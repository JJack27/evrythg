[ _to('140527224335') ]
Introduction to Robotics Mechanics and Control
Third Edition
John J. Craig
PEARSON Prentice Hail
Pearson Education International
© 2005 Pearson Education, Inc.
Pearson Prentice Hall
Pearson Education, Inc.
Upper Saddle River, NJ 07458

All rights reserved. No part of this book may be reproduced, in any form or by any means, without
permission in writing from the publisher.
If you purchased this book within the United States or Canada you should be aware that it has been
wrongfully imported without the approval of the Publisher or the Author.
Pearson Prentice Hall® is a trademark of Pearson Education, Inc.
Robotics Toolbox for MATLAB (Release7) courtesy of Peter Corke.
The author and publisher of this book have used their best efforts in preparing this book. These efforts
include the development, research, and testing of the theories and programs to determine their effectiveness. The author and publisher make no warranty of any kind, expressed or implied, with regard to these
programs or the documentation contained in this book. The author and publisher shall not be liable in
any event for incidental or consequential damages in connection with, or arising out of, the furnishing,
performance, or use of these programs.
Printed in the United States of America
10 9
8765 43
ISBN
Pearson Education Ltd., London
Pearson Education Australia Pty. Ltd., Sydney
Pearson Education Singapore, Pte. Ltd.
Pearson Education North Asia Ltd., Hong Kong
Pearson Education Canada, Ltd., Toronto
Pearson Educación de Mexico, S.A. de C.V.
Pearson Education—Japan, Tokyo
Pearson Education Malaysia, Pte. Ltd.
Pearson Education, Inc., Upper Saddle River, New Jersey
Contents
Preface
Introduction
Spatial descriptions and transformations
Manipulator kinematics
Inverse manipulator kinematics
Jacobians: velocities and static forces
Manipulator dynamics
Trajectory generation
Manipulator-mechanism design
Linear control of manipulators
10 Nonlinear control of manipulators
11 Force control of manipulators
12 Robot programming languages and systems
13 Off-line programming systems
A Trigonometric identities
B The 24 angle-set conventions
C Some inverse-kinematic formulas
Solutions to selected exercises
Index
Preface
Scientists
often have the feeling that, through their work, they are learning about
some aspect of themselves. Physicists see this connection in their work; so do,
for example, psychologists and chemists. In the study of robotics, the connection
between the field of study and ourselves is unusually obvious. And, unlike a science
that seeks only to analyze, robotics as currently pursued takes the engineering bent
toward synthesis. Perhaps it is for these reasons that the field fascinates so many
The study of robotics concerns itself with the desire to synthesize some aspects
of human function by the use of mechanisms, sensors, actuators, and computers.
Obviously, this is a huge undertaking, which seems certain to require a multitude of
ideas from various "classical" fields.
Currently, different aspects of robotics research are carried out by experts in
various fields. It is usually not the case that any single individual has the entire area
of robotics in his or her grasp. A partitioning of the field is natural to expect. At
a relatively high level of abstraction, splitting robotics into four major areas seems
reasonable: mechanical manipulation, locomotion, computer vision, and artificial
intelligence.
This book introduces the science and engineering of mechanical manipulation.
This subdiscipline of robotics has its foundations in several classical fields. The major
relevant fields are mechanics, control theory, and computer science. In this book,
Chapters 1 through 8 cover topics from mechanical engineering and mathematics,
Chapters 9 through 11 cover control-theoretical material, and Chapters 12 and 13
might be classed as computer-science material. Additionally, the book emphasizes
computational aspects of the problems throughout; for example, each chapter
that is concerned predominantly with mechanics has a brief section devoted to
computational considerations.
This book evolved from class notes used to teach "Introduction to Robotics" at
Stanford University during the autunms of 1983 through 1985. The first and second
editions have been used at many institutions from 1986 through 2002. The third
edition has benefited from this use and incorporates corrections and improvements
due to feedback from many sources. Thanks to all those who sent corrections to the
author.
This book is appropriate for a senior undergraduate- or first-year graduate-
level course. It is helpful if the student has had one basic course in statics and
dynamics and a course in linear algebra and can program in a high-level language.
Additionally, it is helpful, though not absolutely necessary, that the student have
completed an introductory course in control theory. One aim of the book is to
present material in a simple, intuitive way. Specifically, the audience need not be
strictly mechanical engineers, though much of the material is taken from that field.
At Stanford, many electrical engineers, computer scientists, and mathematicians
found the book quite readable.
Directly, this book is of use to those engineers developing robotic systems,
but the material should be viewed as important background material for anyone
who will be involved with robotics. In much the same way that software developers
have usually studied at least some hardware, people not directly involved with the
mechanics and control of robots should have some such background as that offered
by this text.
Like the second edition, the third edition is organized into 13 chapters. The
material wifi fit comfortably into an academic semester; teaching the material within
an academic quarter will probably require the instructor to choose a couple of
chapters to omit. Even at that pace, all of the topics cannot be covered in great
depth. In some ways, the book is organized with this in mind; for example, most
chapters present only one approach to solving the problem at hand. One of the
challenges of writing this book has been in trying to do justice to the topics covered
within the time constraints of usual teaching situations. One method employed to
this end was to consider only material that directly affects the study of mechanical
manipulation.
At the end of each chapter is a set of exercises. Each exercise has been
assigned a difficulty factor, indicated in square brackets following the exercise's
number. Difficulties vary between [00] and [50], where [00] is trivial and [50] is
an unsolved research problem.' Of course, what one person finds difficult, another
might find easy, so some readers will find the factors misleading in some cases.
Nevertheless, an effort has been made to appraise the difficulty of the exercises.
At the end of each chapter there is a programming assignment in which
the student applies the subject matter of the corresponding chapter to a simple
three-jointed planar manipulator. This simple manipulator is complex enough to
demonstrate nearly all the principles of general manipulators without bogging the
student down in too much complexity. Each programming assignment builds upon
the previous ones, until, at the end of the course, the student has an entire library of
manipulator software.
Additionally, with the third edition we have added MATLAB exercises to
the book. There are a total of 12 MATLAB exercises associated with Chapters
1 through 9. These exercises were developed by Prof. Robert L. Williams II of
Ohio University, and we are greatly indebted to him for this contribution. These
exercises can be used with the MATLAB Robotics Toolbox2 created by Peter
Corke, Principal Research Scientist with CSIRO in Australia.
Chapter 1 is an introduction to the field of robotics. It introduces some
background material, a few fundamental ideas, and the adopted notation of the
book, and it previews the material in the later chapters.
Chapter 2 covers the mathematics used to describe positions and orientations
in 3-space. This is extremely important material: By definition, mechanical manipulation concerns itself with moving objects (parts, tools, the robot itself) around in
space. We need ways to describe these actions in a way that is easily understood and
is as intuitive as possible.
have adopted the same scale as in The Art of Computer Pro gramming by D. Knuth (AddisonWesley).
2For the MATLAB Robotics Toolbox, go to http:/www.ict.csiro.au/robotics/ToolBOX7.htm.
Preface
Chapters 3 and 4 deal with the geometry of mechanical manipulators. They
introduce the branch of mechanical engineering known as kinematics, the study of
motion without regard to the forces that cause it. In these chapters, we deal with the
kinematics of manipulators, but restrict ourselves to static positioning problems.
Chapter 5 expands our investigation of kinematics to velocities and static
forces.
In Chapter 6, we deal for the first time with the forces and moments required
to cause motion of a manipulator. This is the problem of manipulator dynamics.
Chapter 7 is concerned with describing motions of the manipulator in terms of
trajectories through space.
Chapter 8 many topics related to the mechanical design of a manipulator. For
example, how many joints are appropriate, of what type should they be, and how
should they be arranged?
In Chapters 9 and 10, we study methods of controffing a manipulator (usually
with a digital computer) so that it wifi faithfully track a desired position trajectory
through space. Chapter 9 restricts attention to linear control methods; Chapter 10
extends these considerations to the nonlinear realm.
Chapter 11 covers the field of active force control with a manipulator. That is,
we discuss how to control the application of forces by the manipulator. This mode of
control is important when the manipulator comes into contact with the environment
around it, such as during the washing of a window with a sponge.
Chapter 12 overviews methods of programming robots, specifically the elements needed in a robot programming system, and the particular problems associated
with programming industrial robots.
Chapter 13 introduces off-line simulation and programming systems, which
represent the latest extension to the man—robot interface.
I would like to thank the many people who have contributed their time to
helping me with this book. First, my thanks to the students of Stanford's ME219 in
the autunm of 1983 through 1985, who suffered through the first drafts, found many
errors, and provided many suggestions. Professor Bernard Roth has contributed in
many ways, both through constructive criticism of the manuscript and by providing
me with an environment in which to complete the first edition. At SILMA Inc.,
I enjoyed a stimulating environment, plus resources that aided in completing the
second edition. Dr. Jeff Kerr wrote the first draft of Chapter 8. Prof. Robert L.
Williams II contributed the MATLAB exercises found at the end of each chapter,
and Peter Corke expanded his Robotics Toolbox to support this book's style of the
Denavit—Hartenberg notation. I owe a debt to my previous mentors in robotics:
Marc Raibert, Carl Ruoff, Tom Binford, and Bernard Roth.
Many others around Stanford, SILMA, Adept, and elsewhere have helped in
various ways—my thanks to John Mark Agosta, Mike All, Lynn Balling, Al Barr,
Stephen Boyd, Chuck Buckley, Joel Burdick, Jim Callan, Brian Carlisle, Monique
Craig, Subas Desa, Tn Dai Do, Karl Garcia, Ashitava Ghosal, Chris Goad, Ron
Goldman, Bill Hamilton, Steve Holland, Peter Jackson, Eric Jacobs, Johann Jager,
Paul James, Jeff Kerr, Oussama Khatib, Jim Kramer, Dave Lowe, Jim Maples, Dave
Marimont, Dave Meer, Kent Ohlund, Madhusudan Raghavan, Richard Roy, Ken
Salisbury, Bruce Shimano, Donalda Speight, Bob Tiove, Sandy Wells, and Dave
Williams.
viii
The students of Prof. Roth's Robotics Class of 2002 at Stanford used the
second edition and forwarded many reminders of the mistakes that needed to get
fixed for the third edition.
Finally I wish to thank Tom Robbins at Prentice Hall for his guidance with the
first edition and now again with the present edition.
CHAPTER
BACKGROUND
THE MECHANICS AND CONTROL OF MECHANICAL MANIPULATORS
NOTATION
The history of industrial automation is characterized by periods of rapid change in
popular methods. Either as a cause or, perhaps, an effect, such periods of change in
automation techniques seem closely tied to world economics. Use of the industrial
robot, which became identifiable as a unique device in the 1960s [1], along with
computer-aided design (CAD) systems and computer-aided manufacturing (CAM)
systems, characterizes the latest trends in the automation of the manufacturing
process. These technologies are leading industrial automation through another
transition, the scope of which is stifi unknown [2].
In North America, there was much adoption of robotic equipment in the early
1980s, followed by a brief pull-back in the late 1980s. Since that time, the market has
been growing (Fig. 1.1), although it is subject to economic swings, as are all markets.
Figure 1.2 shows the number of robots being installed per year in the major
industrial regions of the world. Note that Japan reports numbers somewhat differently from the way that other regions do: they count some machines as robots
that in other parts of the world are not considered robots (rather, they would be
simply considered "factory machines"). Hence, the numbers reported for Japan are
somewhat inflated.
A major reason for the growth in the use of industrial robots is their declining
cost. Figure 1.3 indicates that, through the decade of the 1990s, robot prices dropped
while human labor costs increased. Also, robots are not just getting cheaper, they
are becoming more effective—faster, more accurate, more flexible. If we factor
these quality adjustments into the numbers, the cost of using robots is dropping even
faster than their price tag is. As robots become more cost effective at their jobs,
and as human labor continues to become more expensive, more and more industrial
jobs become candidates for robotic automation. This is the single most important
trend propelling growth of the industrial robot market. A secondary trend is that,
economics aside, as robots become more capable they become able to do more and
more tasks that might be dangerous or impossible for human workers to perform.
The applications that industrial robots perform are gradually getting more
sophisticated, but it is stifi the case that, in the year 2000, approximately 78%
of the robots installed in the US were welding or material-handling robots [3].
Chapter 1
Shipments of industrial robots in North America, millions of US dollars
1200
1100
1000
0 700
FIGURE 1.1:
1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000
Shipments of industrial robots in North America in millions of US
dollars [3].
2004
2003
1996
1995
All other countries
Japan (all types of U United States [1111 European Union
industrial robots)
FIGURE 1.2: Yearly installations of multipurpose industrial robots for 1995—2000 and
forecasts for 2001—2004 [3].
160.00
140.00
120.00
Labour costs
100.00
80.00
Robot prices, not quality adj.
60.00
40.00')fl
fin -
-A-—
—A
1990
FIGURE 1.3:
—a
Robot prices, quality adjusted
1991
1992
1993
1994 1995 1996
1997
1998
1999
2000
Robot prices compared with human labor costs in the 1990s [3].
Section 1.1
Background
FIG U RE 1.4: The Adept 6 manipulator has six rotational joints and is popular in many
applications. Courtesy of Adept Tecimology, Inc.
A more challenging domain, assembly by industrial robot, accounted for 10% of
installations.
This book focuses on the mechanics and control of the most important form
of the industrial robot, the mechanical manipulator. Exactly what constitutes an
industrial robot is sometimes debated. Devices such as that shown in Fig. 1.4 are
always included, while numerically controlled (NC) milling machines are usually
not. The distinction lies somewhere in the sophistication of the programmability of
the device—if a mechanical device can be programmed to perform a wide variety
of applications, it is probably an industrial robot. Machines which are for the most
part limited to one class of task are considered fixed automation. For the purposes
of this text, the distinctions need not be debated; most material is of a basic nature
that applies to a wide variety of programmable machines.
By and large, the study of the mechanics and control of manipulators is
not a new science, but merely a collection of topics taken from "classical" fields.
Mechanical engineering contributes methodologies for the study of machines in
static and dynamic situations. Mathematics supplies tools for describing spatial
motions and other attributes of manipulators. Control theory provides tools for
designing and evaluating algorithms to realize desired motions or force applications.
Electrical-engineering techniques are brought to bear in the design of sensors
and interfaces for industrial robots, and computer science contributes a basis for
programming these devices to perform a desired task.
12 THE MECHANICS AND CONTROL OF MECHANICAL MANIPULATORS
The following sections introduce some terminology and briefly preview each of the
topics that will be covered in the text.
Description of position and orientation
In the study of robotics, we are constantly concerned with the location of objects in
three-dimensional space. These objects are the links of the manipulator, the parts
and tools with which it deals, and other objects in the manipulator's environment.
At a crude but important level, these objects are described by just two attributes:
position and orientation. Naturally, one topic of immediate interest is the manner
in which we represent these quantities and manipulate them mathematically.
In order to describe the position and orientation of a body in space, we wifi
always attach a coordinate system, or frame, rigidly to the object. We then proceed
to describe the position and orientation of this frame with respect to some reference
coordinate system. (See Fig. 1.5.)
Any frame can serve as a reference system within which to express the
position and orientation of a body, so we often think of transforming or changing
the description of these attributes of a body from one frame to another. Chapter 2
discusses conventions and methodologies for dealing with the description of position
and orientation and the mathematics of manipulating these quantities with respect
to various coordinate systems.
Developing good skifis concerning the description of position and rotation of
rigid bodies is highly useful even in fields outside of robotics.
Forward kinematics of manipulators
Kinematics is the science of motion that treats motion without regard to the forces
which cause it. Within the science of kinematics, one studies position, velocity,
FiGURE 1.5: Coordinate systems or "frames" are attached to the manipulator and to
objects in the environment.
Section 1.2
The mechanics and control of mechanical manipulators
acceleration, and all higher order derivatives of the position variables (with respect
to time or any other variable(s)). Hence, the study of the kinematics of manipulators
refers to all the geometrical and time-based properties of the motion.
Manipulators consist of nearly rigid links, which are connected by joints that
allow relative motion of neighboring links. These joints are usually instrumented
with position sensors, which allow the relative position of neighboring links to be
measured. In the case of rotary or revolute joints, these displacements are called
joint angles. Some manipulators contain sliding (or prismatic) joints, in which the
relative displacement between links is a translation, sometimes called the joint
offset.
The number of degrees of freedom that a manipulator possesses is the number
of independent position variables that would have to be specified in order to locate
all parts of the mechanism. This is a general term used for any mechanism. For
example, a four-bar linkage has only one degree of freedom (even though there
are three moving members). In the case of typical industrial robots, because a
manipulator is usually an open kinematic chain, and because each joint position is
usually defined with a single variable, the number of joints equals the number of
degrees of freedom.
At the free end of the chain of links that make up the manipulator is the endeffector. Depending on the intended application of the robot, the end-effector could
be a gripper, a welding torch, an electromagnet, or another device. We generally
describe the position of the manipulator by giving a description of the tool frame,
which is attached to the end-effector, relative to the base frame, which is attached
to the nonmoving base of the manipulator. (See Fig. 1.6.)
A very basic problem in the study of mechanical manipulation is called forward
kinematics. This is the static geometrical problem of computing the position and
orientation of the end-effector of the manipulator. Specifically, given a set of joint
fBasel
FIGURE 1.6: Kinematic equations describe the tool frame relative to the base frame
as a function of the joint variables.
the forward kinematic problem is to compute the position and orientation of
the tool frame relative to the base frame. Sometimes, we think of this as changing
the representation of manipulator position from a joint space description into a
Cartesian space description.' This problem wifi be explored in Chapter 3.
angles,
Inverse kinematics of manipulators
In Chapter 4, we wifi consider the problem of inverse kinematics. This problem
is posed as follows: Given the position and orientation of the end-effector of the
manipulator, calculate all possible sets of joint angles that could be used to attain
this given position and orientation. (See Fig. 1.7.) This is a fundamental problem in
the practical use of manipulators.
This is a rather complicated geometrical problem that is routinely solved
thousands of times daily in human and other biological systems. In the case of an
artificial system like a robot, we wifi need to create an algorithm in the control
computer that can make this calculation. In some ways, solution of this problem is
the most important element in a manipulator system.
We can think of this problem as a mapping of "locations" in 3-D Cartesian
space to "locations" in the robot's internal joint space. This need naturally arises
anytime a goal is specified in external 3-D space coordinates. Some early robots
lacked this algorithm—they were simply moved (sometimes by hand) to desired
locations, which were then recorded as a set of joint values (i.e., as a location in
joint space) for later playback. Obviously, if the robot is used purely in the mode
of recording and playback of joint locations and motions, no algorithm relating
(Tool)
FIGURE 1.7: For a given position and orientation of the tool frame, values for the
joint variables can be calculated via the inverse kinematics.
1By Cartesian space, we mean the space in which the position of a point is given with three numbers,
and in which the orientation of a body is given with three numbers. It is sometimes called task space or
operational space.
joint space to Cartesian space is needed. These days, however, it is rare to find an
industrial robot that lacks this basic inverse kinematic algorithm.
The inverse kinematics problem is not as simple as the forward kinematics
one. Because the kinematic equations are nonlinear, their solution is not always
easy (or even possible) in a closed form. Also, questions about the existence of a
solution and about multiple solutions arise.
Study of these issues gives one an appreciation for what the human mind and
nervous system are accomplishing when we, seemingly without conscious thought,
move and manipulate objects with our arms and hands.
The existence or nonexistence of a kinematic solution defines the workspace
of a given manipulator. The lack of a solution means that the manipulator cannot
attain the desired position and orientation because it lies outside of the manipulator's
workspace.
Velocities, static forces, singularities
In addition to dealing with static positioning problems, we may wish to analyze
manipulators in motion. Often, in performing velocity analysis of a mechanism, it is
convenient to define a matrix quantity called the Jacobian of the manipulator. The
Jacobian specifies a mapping from velocities in joint space to velocities in Cartesian
space. (See Fig. 1.8.) The nature of this mapping changes as the configuration of
the manipulator varies. At certain points, called singularities, this mapping is not
invertible. An understanding of the phenomenon is important to designers and users
of manipulators.
Consider the rear gunner in a World War I—vintage biplane fighter plane
(ifiustrated in Fig. 1.9). While the pilot ifies the plane from the front cockpit, the rear
gunner's job is to shoot at enemy aircraft. To perform this task, his gun is mounted
in a mechanism that rotates about two axes, the motions being called azimuth and
elevation. Using these two motions (two degrees of freedom), the gunner can direct
his stream of bullets in any direction he desires in the upper hemisphere.
FIGURE 1.8: The geometrical relationship between joint rates and velocity of the
end-effector can be described in a matrix called the Jacobian.
9 A World War I biplane with a pilot and a rear gunner The rear gunner
mechanism is subject to the problem of singular positions.
FIGURE 1
An enemy plane is spotted at azimuth one o'clock and elevation 25 degrees!
The gunner trains his stream of bullets on the enemy plane and tracks its motion so
as to hit it with a continuous stream of bullets for as long as possible. He succeeds
and thereby downs the enemy aircraft.
A second enemy plane is seen at azimuth one o'clock and elevation 70 degrees!
The gunner orients his gun and begins firing. The enemy plane is moving so as to
obtain a higher and higher elevation relative to the gunner's plane. Soon the enemy
plane is passing nearly overhead. What's this? The gunner is no longer able to keep
his stream of bullets trained on the enemy plane! He found that, as the enemy plane
flew overhead, he was required to change his azimuth at a very high rate. He was
not able to swing his gun in azimuth quickly enough, and the enemy plane escaped!
In the latter scenario, the lucky enemy pilot was saved by a singularity! The
gun's orienting mechanism, while working well over most of its operating range,
becomes less than ideal when the gun is directed straight upwards or nearly so. To
track targets that pass through the position directly overhead, a very fast motion
around the azimuth axis is required. The closer the target passes to the point directly
overhead, the faster the gunner must turn the azimuth axis to track the target. If
the target flies directly over the gunner's head, he would have to spin the gun on its
azimuth axis at infinite speed!
Should the gunner complain to the mechanism designer about this problem?
Could a better mechanism be designed to avoid this problem? It turns out that
you really can't avoid the problem very easily. In fact, any two-degree-of-freedom
orienting mechanism that has exactly two rotational joints cannot avoid having
this problem. In the case of this mechanism, with the stream of bullets directed
straight up, their direction aligns with the axis of rotation of the azimuth rotation.
This means that, at exactly this point, the azimuth rotation does not cause a
change in the direction of the stream of bullets. We know we need two degrees
of freedom to orient the stream of bullets, but, at this point, we have lost the
effective use of one of the joints. Our mechanism has become locally degenerate
at this location and behaves as if it only has one degree of freedom (the elevation
direction).
This kind of phenomenon is caused by what is called a singularity of the
mechanism. All mechanisms are prone to these difficulties, including robots. Just
as with the rear gunner's mechanism, these singularity conditions do not prevent
a robot arm from positioning anywhere within its workspace. However, they can
cause problems with motions of the arm in their neighborhood.
Manipulators do not always move through space; sometimes they are also
required to touch a workpiece or work surface and apply a static force. In this
case the problem arises: Given a desired contact force and moment, what set of
joint torques is required to generate them? Once again, the Jacobian matrix of the
manipulator arises quite naturally in the solution of this problem.
Dynamics
Dynamics is a huge field of study devoted to studying the forces required to cause
motion. In order to accelerate a manipulator from rest, glide at a constant endeffector velocity, and finally decelerate to a stop, a complex set of torque functions
must be applied by the joint actuators.2 The exact form of the required functions of
actuator torque depend on the spatial and temporal attributes of the path taken by
the end-effector and on the mass properties of the links and payload, friction in the
joints, and so on. One method of controlling a manipulator to follow a desired path
involves calculating these actuator torque functions by using the dynamic equations
of motion of the manipulator.
Many of us have experienced lifting an object that is actually much lighter
than we
(e.g., getting a container of milk from the refrigerator which
we thought was full, but was nearly empty). Such a misjudgment of payload can
cause an unusual lifting motion. This kind of observation indicates that the human
control system is more sophisticated than a purely kinematic scheme. Rather, our
manipulation control system makes use of knowledge of mass and other dynamic
effects. Likewise, algorithms that we construct to
the motions of a robot
manipulator should take dynamics into account.
A second use of the dynamic equations of motion is in simulation. By reformulating the dynamic equations so that acceleration is computed as a function of
actuator torque, it is possible to simulate how a manipulator would move under
application of a set of actuator torques. (See Fig. 1.10.) As computing power
becomes more and more cost effective, the use of simulations is growing in use and
importance in many fields.
In Chapter 6, we develop dynamic equations of motion, which may be used to
control or simulate the motion of manipulators.
2We use joint actuators as the generic term for devices that power a manipulator—for example,
electric motors, hydraulic and pneumatic actuators, and muscles.
The relationship between the torques applied by the actuators and
the resulting motion of the manipulator is embodied in the dynamic equations of
FIG URE 1.10:
motion.
A common way of causing a manipulator to move from here to there in a smooth,
controlled fashion is to cause each joint to move as specified by a smooth function
of time. Commonly, each joint starts and ends its motion at the same time, so that
appears coordinated. Exactly how to compute these motion
functions is the problem of trajectory generation. (See Fig. 1.11.)
Often, a path is described not only by a desired destination but also by some
intermediate locations, or via points, through which the manipulator must pass en
route to the destination. In such instances the term spline is sometimes used to refer
to a smooth function that passes through a set of via points.
In order to force the end-effector to follow a straight line (or other geometric
shape) through space, the desired motion must be converted to an equivalent set
of joint motions. This Cartesian trajectory generation wifi also be considered in
Chapter 7.
Manipulator design and sensors
Although manipulators are, in theory, universal devices applicable to many situations, economics generally dictates that the intended task domain influence the
mechanical design of the manipulator. Along with issues such as size, speed, and
load capability, the designer must also consider the number of joints and their
geometric arrangement. These considerations affect the manipulator's workspace
size and quality, the stiffness of the manipulator structure, and other attributes.
The more joints a robot arm contains, the more dextrous and capable it wifi
be. Of course, it wifi also be harder to build and more expensive. In order to build
FIGURE 1.1 1: In order to move the end-effector through space from point A to point
B, we must compute a trajectory for each joint to follow.
a useful robot, that can take two approaches: build a specialized robot for a specific
task, or build a universal robot that would able to perform a wide variety of tasks.
In the case of a specialized robot, some careful thinking will yield a solution for
how many joints are needed. For example, a specialized robot designed solely to
place electronic components on a flat circuit board does not need to have more
than four joints. Three joints allow the position of the hand to attain any position
in three-dimensional space, with a fourth joint added to allow the hand to rotate
the grasped component about a vertical axis. In the case of a universal robot, it is
interesting that fundamental properties of the physical world we live in dictate the
"correct" minimum number of joints—that minimum number is six.
Integral to the design of the manipulator are issues involving the choice and
location of actuators, transmission systems, and internal-position (and sometimes
force) sensors. (See Fig. 1.12.) These and other design issues will be discussed in
Chapter 8.
Linear position control
Some manipulators are equipped with stepper motors or other actuators that can
execute a desired trajectory directly. However, the vast majority of manipulators
are driven by actuators that supply a force or a torque to cause motion of the links.
In this case, an algorithm is needed to compute torques that will cause the desired
motion. The problem of dynamics is central to the design of such algorithms, but
does not in itself constitute a solution. A primary concern of a position control
system is to compensate automatically for errors in knowledge of the parameters
of a system and to suppress disturbances that tend to perturb the system from the
desired trajectory. To accomplish this, position and velocity sensors are monitored
by the control algorithm, which computes torque commands for the actuators. (See
The design of a mechanical manipulator must address issues of actuator
choice, location, transmission system, structural stiffness, sensor location, and more.
FIGURE 1.12:
FIG U RE 1.13: In order to cause the manipulator to follow the desired trajectory, a
position-control system must be implemented. Such a system uses feedback from
joint sensors to keep the manipulator on course.
Fig. 1.13.) In Chapter 9, we wifi consider control algorithms whose synthesis is based
on linear approximations to the dynamics of a manipulator. These linear methods
are prevalent in current industrial practice.
Nonlinear position control
Although control systems based on approximate linear models are popular in current
industrial robots, it is important to consider the complete nonlinear dynamics of
the manipulator when synthesizing control algorithms. Some industrial robots are
now being introduced which make use of nonlinear control algorithms in their
controllers. These nonlinear techniques of controlling a manipulator promise better
performance than do simpler linear schemes. Chapter 10 will introduce nonlinear
control systems for mechanical manipulators.
Force control
The ability of a manipulator to control forces of contact when it touches parts,
tools, or work surfaces seems to be of great importance in applying manipulators
to many real-world tasks. Force control is complementary to position control, in
that we usually think of only one or the other as applicable in a certain situation.
When a manipulator is moving in free space, only position control makes sense,
because there is no surface to react against. When a manipulator is touching a
rigid surface, however, position-control schemes can cause excessive forces to build
up at the contact or cause contact to be lost with the surface when it was desired
for some application. Manipulators are rarely constrained by reaction surfaces in
all directions simultaneously, so a mixed or hybrid control is required, with some
directions controlled by a position-control law and remaining directions controlled
by a force-control law. (See Fig. 1.14.) Chapter 11 introduces a methodology for
implementing such a force-control scheme.
A robot should be instructed to wash a window by maintaining a certain
force in the direction perpendicular to the plane of the glass, while following a
motion trajectory in directions tangent to the plane. Such split or hybrid control
specifications are natural for such tasks.
Programming robots
A robot progranuning language serves as the interface between the human user
and the industrial robot. Central questions arise: How are motions through space
described easily by the programmer? How are multiple manipulators programmed
FIG U RE 1.14: In order for a manipulator to slide across a surface while applying a
constant force, a hybrid position—force control system must be used.
Desired motions of the manipulator and end-effector, desired contact
forces, and complex manipulation strategies can be described in a robotprograrnming
language.
FIGURE 1.15:
so that they can work in parallel? How are sensor-based actions described in a
language?
Robot manipulators differentiate themselves from fixed automation by being
"flexible," which means programmable. Not only are the movements of manipulators
programmable, but, through the use of sensors and communications with other
factory automation, manipulators can adapt to variations as the task proceeds. (See
Fig. 1.15.)
In typical robot systems, there is a shorthand way for a human user to instruct
the robot which path it is to follow. First of all, a special point on the hand
(or perhaps on a grasped tool) is specified by the user as the operational point,
sometimes also called the TCP (for Tool Center Point). Motions of the robot wifi
be described by the user in terms of desired locations of the operational point
relative to a user-specified coordinate system. Generally, the user wifi define this
reference coordinate system relative to the robot's base coordinate system in some
task-relevant location.
Most often, paths are constructed by specifying a sequence of via points. Via
points are specified relative to the reference coordinate system and denote locations
along the path through which the TCP should pass. Along with specifying the via
points, the user may also indicate that certain speeds of the TCP be used over
various portions of the path. Sometimes, other modifiers can also be specified to
affect the motion of the robot (e.g., different smoothness criteria, etc.). From these
inputs, the trajectory-generation algorithm must plan all the details of the motion:
velocity profiles for the joints, time duration of the move, and so on. Hence, input
to the trajectory-generation problem is generally given by constructs in the robot
programming language.
The sophistication of the user interface is becoming extremely important
as manipulators and other programmable automation are applied to more and
more demanding industrial applications. The problem of programming manipulators encompasses all the issues of "traditional" computer programming and so
is an extensive subject in itself. Additionally, some particular attributes of the
manipulator-programming problem cause additional issues to arise. Some of these
topics will be discussed in Chapter 12.
Off-line programming and simulation
An off-line programming system is a robot programming environment that has
been sufficiently extended, generally by means of computer graphics, that the
development of robot programs can take place without access to the robot itself. A
common argument raised in their favor is that an off-line programming system wifi
not cause production equipment (i.e., the robot) to be tied up when it needs to be
reprogrammed; hence, automated factories can stay in production mode a greater
percentage of the time. (See Fig. 1.16.)
They also serve as a natural vehicle to tie computer-aided design (CAD) data
bases used in the design phase of a product to the actual manufacturing of the
product. In some cases, this direct use of CAD data can dramatically reduce the
programming time required for the manufacturing process. Chapter 13 discusses the
elements of industrial robot off-line programming systems.
FIGURE 1.16: Off-line programming systems, generally providing a computer graphics
interface, allow robots to be programmed without access to the robot itself during
programming.
Notation is always an issue in science and engineering. In this book, we use the
following conventions:
1. Usually, variables written in uppercase represent vectors or matrices. Lowercase variables are scalars.
2. Leading subscripts and superscripts identify which coordinate system a quantity
is written in. For example, A P represents a position vector written in coordinate
system {A}, and R is a rotation matrix3 that specifies the relationship between
coordinate systems {A} and {B}.
3. Trailing superscripts are used (as widely accepted) for indicating the inverse
or transpose of a matrix (e.g., R1, RT).
4. Trailing subscripts are not subject to any strict convention but may indicate a
vector component (e.g., x, y, or z) or maybe used as a description—as in
the position of a bolt.
5. We will use many trigonometric fi.mctions. Our notation for the cosine of an
angle may take any of the following forms: cos = c01 = c1.
Vectors are taken to be column vectors; hence, row vectors wifi have the
transpose indicated explicitly.
A note on vector notation in general: Many mechanics texts treat vector
quantities at a very abstract level and routinely use vectors defined relative to
different coordinate systems in expressions. The clearest example is that of addition
of vectors which are given or known relative to differing reference systems. This is
often very convenient and leads to compact and somewhat elegant formulas. For
example, consider the angular velocity, 0w4 of the last body in a series connection
of four rigid bodies (as in the links of a manipulator) relative to the fixed base of the
chain. Because angular velocities sum vectorially, we may write a very simple vector
equation for the angular velocity of the final link:
+ 2w3 +
(1.1)
However, unless these quantities are expressed with respect to a common coordinate
system, they cannot be summed, and so, though elegant, equation (1.1) has hidden
much of the "work" of the computation. For the particular case of the study of
mechanical manipulators, statements like that of (1.1) hide the chore of bookkeeping
of coordinate systems, which is often the very idea that we need to deal with in practice.
Therefore, in this book, we carry frame-of-reference information in the notation for vectors, and we do not sum vectors unless they are in the same coordinate
system. In this way, we derive expressions that solve the "bookkeeping" problem
and can be applied directly to actual numerical computation.
BIBLIOGRAPHY
[1] B. Roth, "Principles of Automation," Future Directions in Manufacturing Technology, Based on the Unilever Research and Engineering Division Symposium held at
Port Sunlight, April 1983, Published by Unilever Research, UK.
3This term wifi be introduced in Chapter 2.
Exercises
[2] R. Brooks, "Flesh and Machines," Pantheon Books, New York, 2002.
[3] The International Federation of Robotics, and the United Nations, "World Robotics
2001," Statistics, Market Analysis, Forecasts, Case Studies and Profitability of Robot
Investment, United Nations Publication, New York and Geneva, 2001.
General-reference books
[4] R. Paul, Robot Manipulators, MIT Press, Cambridge, IvIA, 1981.
[5] M. Brady et al., Robot Motion, MIT Press, Cambridge, MA, 1983.
[6] W. Synder, Industrial Robots: Computer Interfacing and Control, Prentice-Hall, Englewood Cliffs, NJ, 1985.
[7] Y. Koren, Robotics for Engineers, McGraw-Hill, New York, 1985.
[8] H. Asada and J.J. Slotine, Robot Analysis and Control, Wiley, New York, 1986.
[9] K. Fu, R. Gonzalez, and C.S.G. Lee, Robotics: Control, Sensing, Vision, and Intelligence, McGraw-Hill, New York, 1987.
[10] E. Riven, Mechanical Design of Robots, McGraw-Hill, New York, 1988.
[II] J.C. Latombe, Robot Motion Planning, Kiuwer Academic Publishers, Boston, 1991.
[12] M. Spong, Robot Control: Dynamics, Motion Planning, and Analysis, HiEE Press,
New York, 1992.
[13] S.Y. Nof, Handbook of Industrial Robotics, 2nd Edition, Wiley, New York, 1999.
[14] L.W. Tsai, Robot Analysis: The Mechanics of Serial and Parallel Manipulators, Wiley,
New York, 1999.
[15] L. Sciavicco and B. Siciliano, Modelling and Control of Robot Manipulators, 2nd
Edition, Springer-Verlag, London, 2000.
[16] G. Schmierer and R. Schraft, Service Robots, A.K. Peters, Natick, MA, 2000.
General-reference journals and magazines
[17] Robotics World.
[18] IEEE Transactions on Robotics and Automation.
[19] International Journal of Robotics Research (MIT Press).
[20] ASME Journal of Dynamic Systems, Measurement, and Control.
[21] International Journal of Robotics & Automation (lASTED).
EXERCISES
[20] Make a chronology of major events in the development of industrial robots
over the past 40 years. See Bibliography and general references.
1.2 [20] Make a chart showing the major applications of industrial robots (e.g., spot
welding, assembly, etc.) and the percentage of installed robots in use in each
application area. Base your chart on the most recent data you can find. See
Bibliography and general references.
1.3 [40] Figure 1.3 shows how the cost of industrial robots has declined over the years.
Find data on the cost of human labor in various specific industries (e.g., labor in
the auto industry, labor in the electronics assembly industry, labor in agriculture,
etc.) and create a graph showing how these costs compare to the use of robotics.
You should see that the robot cost curve "crosses" various the human cost curves
of different industries at different times. From this, derive approximate dates
when robotics first became cost effective for use in various industries.
1.4 [10] In a sentence or two, define kinematics, workspace, and trajectory.
1.5 [10] In a sentence or two, define frame, degree of freedom, and position control.
1.6 [10] In a sentence or two, define force control, and robot programming language.
1.7 [10] In a sentence or two, define nonlinear control, and off-line programming.
1.8 [20] Make a chart indicating how labor costs have risen over the past 20 years.
1.9 [20] Make a chart indicating how the computer performance—price ratio has
increased over the past 20 years.
1.10 [20] Make a chart showing the major users of industrial robots (e.g., aerospace,
automotive, etc.) and the percentage of installed robots in use in each industry.
Base your chart on the most recent data you can find. (See reference section.)
PROGRAMMING EXERCISE (PART 1)
Familiarize yourself with the computer you will use to do the programming exercises at
the end of each chapter. Make sure you can create and edit files and can compile and
execute programs.
MATLAB EXERCISE 1
At the end of most chapters in this textbook, a MATLAB exercise is given. Generally,
these exercises ask the student to program the pertinent robotics mathematics in
MATLAB and then check the results of the IvIATLAB Robotics Toolbox. The textbook
assumes familiarity with MATLAB and linear algebra (matrix theory). Also, the student
must become familiar with the MATLAB Robotics Toolbox. ForMATLAB Exercise 1,
a) Familiarize yours elf with the MATLAB programming environment if necessary. At
the MATLAB software prompt, try typing demo and help. Using the color-coded
MATLAB editor, learn how to create, edit, save, run, and debug rn-files (ASCII
ifies with series of MATLAB statements). Learn how to create arrays (matrices and
vectors), and explore the built-in MATLAB linear-algebra functions for matrix
and vector multiplication, dot and cross products, transposes, determinants, and
inverses, and for the solution of linear equations. MATLAB is based on the
language C, but is generally much easier to use. Learn how to program logical
constructs and loops in MATLAB. Learn how to use subprograms and functions.
Learn how to use comments (%) for explaining your programs and tabs for easy
readability. Check out www.mathworks.com for more information and tutorials.
Advanced MATLAB users should become familiar with Simulink, the graphical
interface of MATLAB, and with the MATLAB Symbolic Toolbox.
b) Familiarize yourself with the IVIATLAB Robotics Toolbox, a third-party toolbox
developed by Peter I. Corke of CSIRO, Pinjarra Hills, Australia. This product
can be downloaded for free from www.cat.csiro.au/cmst/stafflpic/robot. The source
code is readable and changeable, and there is an international community of
users, at robot-toolbox@lists.rnsa.cmst.csiro.au. Download the MATLAB Robotics
Toolbox, and install it on your computer by using the .zip ifie and following the
instructions. Read the README ifie, and familiarize yourself with the various
functions available to the user. Find the robot.pdf ifie—this is the user manual
giving background information and detailed usage of all of the Toolbox functions.
Don't worry if you can't understand the purpose of these functions yet; they deal
with robotics mathematics concepts covered in Chapters 2 through 7 of this book.
Spatial descriptions
and transformations
INTRODUCTION
2.2 DESCRIPTIONS: POSITIONS, ORIENTATIONS, AND FRAMES
2.3 MAPPINGS: CHANGING DESCRIPTIONS FROM FRAME TO FRAME
2.4 OPERATORS: TRANSLATIONS, ROTATIONS, AND TRANSFORMATIONS
2.5 SUMMARY OF INTERPRETATIONS
2.6 TRANSFORMATION ARITHMETIC
2.7 TRANSFORM EQUATIONS
2.8 MORE ON REPRESENTATION OF ORIENTATION
2.9 TRANSFORMATION OF FREE VECTORS
2.10 COMPUTATIONAL CONSIDERATIONS
Robotic manipulation, by definition, implies that parts and tools wifi be moved
around in space by some sort of mechanism. This naturally leads to a need for
representing positions and orientations of parts, of tools, and of the mechanism
itself. To define and manipulate mathematical quantities that represent position
and orientation, we must define coordinate systems and develop conventions for
representation. Many of the ideas developed here in the context of position and
orientation will form a basis for our later consideration of linear and rotational
velocities, forces, and torques.
We adopt the philosophy that somewhere there is a universe coordinate system
to which everything we discuss can be referenced. We wifi describe all positions
and orientations with respect to the universe coordinate system or with respect to
other Cartesian coordinate systems that are (or could be) defined relative to the
universe system.
DESCRIPTIONS: POSITIONS, ORIENTATIONS, AND FRAMES
A description is used to specify attributes of various objects with which a manipulation system deals. These objects are parts, tools, and the manipulator itself. In this
section, we discuss the description of positions, of orientations, and of an entity that
contains both of these descriptions: the frame.
Chapter 2
Description of a position
Once a coordinate system is established, we can locate any point in the universe with
a 3 x 1 position vector. Because we wifi often define many coordinate systems in
addition to the universe coordinate system, vectors must be tagged with information
identifying which coordinate system they are defined within. In this book, vectors
are written with a leading superscript indicating the coordinate system to which
they are referenced (unless it is clear from context)—for example, Ap This means
that the components of A P have numerical values that indicate distances along the
axes of {A}. Each of these distances along an axis can be thought of as the result of
projecting the vector onto the corresponding axis.
Figure 2.1 pictorially represents a coordinate system, {A}, with three mutually
orthogonal unit vectors with solid heads. A point A P is represented as a vector and
can equivalently be thought of as a position in space, or simply as an ordered set of
three numbers. Individual elements of a vector are given the subscripts x, y, and z:
(2.1)
In summary, we wifi describe the position of a point in space with a position vector.
Other 3-tuple descriptions of the position of points, such as spherical or cylindrical
coordinate representations, are discussed in the exercises at the end of the chapter.
Description of an orientation
Often, we wifi find it necessary not only to represent a point in space but also to
describe the orientation of a body in space. For example, if vector Ap in Fig. 2.2
locates the point directly between the fingertips of a manipulator's hand, the
complete location of the hand is still not specified until its orientation is also given.
Assuming that the manipulator has a sufficient number of joints,1 the hand could
be oriented arbitrarily while keeping the point between the fingertips at the same
FIGURE 2.1: Vector relative to frame (example).
1How many are "sufficient" wifi be discussed in Chapters 3 and 4.
Section 2.2
Descriptions: positions, orientations, and frames
FIGURE 2.2: Locating an object in position and orientation.
position in space. In order to describe the orientation of a body, we wifi attach a
coordinate system to the body and then give a description of this coordinate system
relative to the reference system. In Fig. 2.2, coordinate system (B) has been attached
to the body in a known way. A description of {B} relative to (A) now suffices to give
the orientation of the body.
Thus, positions of points are described with vectors and orientations of bodies
are described with an attached coordinate system. One way to describe the bodyattached coordinate system, (B), is to write the unit vectors of its three principal
axes2 in terms of the coordinate system {A}.
We denote the unit vectors giving the principal directions of coordinate system
(B } as XB,
and ZB. 'When written in terms of coordinate system {A}, they are
called A XB, A
and A ZB. It will be convenient if we stack these three unit vectors
together as the columns of a 3 x 3 matrix, in the order AXB, AyB, AZB. We will call
this matrix a rotation matrix, and, because this particular rotation matrix describes
{B } relative to {A}, we name it with the notation R (the choice of leading suband superscripts in the definition of rotation matrices wifi become clear in following
sections):
= [AkB Af
r r11 r12
r21 r22 r23
L r31
(2.2)
r32 r33
In summary, a set of three vectors may be used to specify an orientation. For
convenience, we wifi construct a 3 x 3 matrix that has these three vectors as its
colunms. Hence, whereas the position of a point is represented with a vector, the
is often convenient to use three, although any two would suffice. (The third can always be recovered
by taking the cross product of the two given.)
orientation of a body is represented with a matrix. In Section 2.8, we will consider
some other descriptions of orientation that require only three parameters.
We can give expressions for the scalars in (2.2) by noting that the components
of any vector are simply the projections of that vector onto the unit directions of its
reference frame. Hence, each component of
in (2.2) can be written as the dot
product of a pair of unit vectors:
rxB•xA YBXA ZB.XA1
AfT A2]_H
(2.3)
LXB.ZA YB.ZA ZB.ZAJ
For brevity, we have omitted the leading superscripts in the rightmost matrix of
(2.3). In fact, the choice of frame in which to describe the unit vectors is arbitrary as
long as it is the same for each pair being dotted. The dot product of two unit vectors
yields the cosine of the angle between them, so it is clear why the components of
rotation matrices are often referred to as direcfion cosines.
Further inspection of (2.3) shows that the rows of the matrix are the unit
vectors of {A} expressed in {B}; that is,
BItT
Hence,
the description of frame {A} relative to {B}, is given by the transpose of
(2.3); that is,
(2.5)
This suggests that the inverse of a rotation matrix is equal to its transpose, a fact
that can be easily verified as
AItT
[AItB AfTB
(2.6)
where 13 is the 3 x 3 identity matrix. Hence,
(2.7)
Indeed, from linear algebra [1], we know that the inverse of a matrix with
orthonormal columns is equal to its transpose. We have just shown this geometrically.
Description of a frame
The information needed to completely specify the whereabouts of the manipulator
hand in Fig. 2.2 is a position and an orientation. The point on the body whose
position we describe could be chosen arbitrarily, however. For convenience, the
point whose position we will describe is chosen as the origin of the body-attached
frame. The situation of a position and an orientation pair arises so often in robotics
that we define an entity called a frame, which is a set of four vectors giving position
and orientation information. For example, in Fig. 2.2, one vector locates the fingertip
position and three more describe its orientation. Equivalently, the description of a
frame can be thought of as a position vector and a rotation matrix. Note that a frame
is a coordinate system where, in addition to the orientation, we give a position vector
which locates its origin relative to some other embedding frame. For example, frame
and A
where ApBORG is the vector that locates the
{B} is described by
origin of the frame {B}:
(2.8)
In Fig. 2.3, there are three frames that are shown along with the universe coordinate
system. Frames {A} and {B} are known relative to the universe coordinate system,
and frame {C} is known relative to frame {A}.
In Fig. 2.3, we introduce a graphical representation of frames, which is convenient in visualizing frames. A frame is depicted by three arrows representing unit
vectors defining the principal axes of the frame. An arrow representing a vector is
drawn from one origin to another. This vector represents the position of the origin
at the head of the arrow in tenns of the frame at the tail of the arrow. The direction
of this locating arrow tells us, for example, in Fig. 2.3, that {C} is known relative to
{A} and not vice versa.
In summary, a frame can be used as a description of one coordinate system
relative to another. A frame encompasses two ideas by representing both position
and orientation and so may be thought of as a generalization of those two ideas.
Positions could be represented by a frame whose rotation-matrix part is the identity
matrix and whose position-vector part locates the point being described. Likewise,
an orientation could be represented by a frame whose position-vector part was the
zero vector.
FIGURE 2.3:
Example of several frames.
MAPPINGS: CHANGING DESCRIPTIONS FROM FRAME TO FRAME
In a great many of the problems in robotics, we are concerned with expressing the
same quantity in terms of various reference coordinate systems. The previous section
introduced descriptions of positions, orientations, and frames; we now consider the
mathematics of mapping in order to change descriptions from frame to frame.
Mappings involving translated frames
In Fig. 2.4, we have a position defined by the vector
We wish to express this
point in space in terms of frame {A}, when {A} has the same orientation as {B}. In
this case, {B} differs from {A} only by a translation, which is given by ApBORG, a
vector that locates the origin of {B} relative to {A}.
Because both vectors are defined relative to frames of the same orientation,
we calculate the description of point P relative to {A}, Ap, by vector addition:
A _B
(2.9)
Note that only in the special case of equivalent orientations may we add vectors that
are defined in terms of different frames.
In this simple example, we have illustrated mapping a vector from one frame
to another. This idea of mapping, or changing the description from one frame to
another, is an extremely important concept. The quantity itself (here, a point in
space) is not changed; only its description is changed. This is illustrated in Fig. 2.4,
where the point described by B P is not translated, but remains the same, and instead
we have computed a new description of the same point, but now with respect to
system {A}.
FIGURE 2.4:
Translational mapping.
Section 2.3
Mappings: changing descriptions from frame to frame
We say that the vector
defines this mapping because all the informaA
(along
tion needed to perform the change in description is contained in
with the knowledge that the frames had equivalent orientation).
Mappings involving rotated frames
Section 2.2 introduced the notion of describing an orientation by three unit vectors
denoting the principal axes of a body-attached coordinate system. For convenience,
we stack these three unit vectors together as the columns of a 3 x 3 matrix. We wifi
call this matrix a rotation matrix, and, if this particular rotation matrix describes {B}
relative to {A}, we name it with the notation
Note that, by our definition, the columns of a rotation matrix all have unit
magnitude, and, further, that these unit vectors are orthogonal. As we saw earlier, a
consequence of this is that
(2.10)
are the unit vectors of {B} written in {A}, the
Therefore, because the columns of
are the unit vectors of {A} written in {B}.
So a rotation matrix can be interpreted as a set of three column vectors or as a
set of three row vectors, as follows:
(2.11)
As in Fig. 2.5, the situation wifi arise often where we know the definition of a vector
with respect to some frame, {B}, and we would like to know its definition with
respect to another frame, (A}, where the origins of the two frames are coincident.
FIGURE 2.5:
Rotating the description of a vector.
This computation is possible when a description of the orientation of {B} is known
relative to {A}. This orientation is given by the rotation matrix
whose columns
are the unit vectors of {B} written in {A}.
In order to calculate A P, we note that the components of any vector are simply
the projections of that vector onto the unit directions of its frame. The projection is
calculated as the vector dot product. Thus, we see that the components of Ap may
be calculated as
(2.12)
B2A . Bp
In order to express (2.13) in terms of a rotation matrix multiplication, we note
from (2.11) that the rows of
are BXA ByA and BZA. So (2.13) may be written
compactly, by using a rotation matrix, as
APARBP
(2.13)
Equation 2.13 implements a mapping—that is, it changes the description of a
vector—from Bp which describes a point in space relative to {B}, into Ap, which is
a description of the same point, but expressed relative to {A}.
We now see that our notation is of great help in keeping track of mappings
and frames of reference. A helpful way of viewing the notation we have introduced
is to imagine that leading subscripts cancel the leading superscripts of the following
entity, for example the Bs in (2.13).
EXAMPLE 2.1
Figure 2.6 shows a frame {B} that is rotated relative to frame {A} about Z by
30 degrees. Here, Z is pointing out of the page.
FIGURE 2.6: (B} rotated 30 degrees about 2.
Section 23
Writing the unit vectors of {B} in terms of {A} and stacking them as the cohmms
of the rotation matrix, we obtain
r 0.866
0.500
Lo.000
Given
—0.500 0.000 1
0.866 0.000
0.000 1.000]
(2.14)
[0.0 1
(2.15)
L 0.0]
we calculate A p as
= AR Bp =
[—1.0001
1.732
(2.16)
0.000]
Here, R acts as a mapping that is used to describe B P relative to frame {A},
Ap As was introduced in the case of translations, it is important to remember that,
viewed as a mapping, the original vector P is not changed in space. Rather, we
compute a new description of the vector relative to another frame.
Mappings involving general frames
Very often, we know the description of a vector with respect to some frame {B}, and
we would like to know its description with respect to another frame, {A}. We now
consider the general case of mapping. Here, the origin of frame {B} is not coincident
with that of frame {A} but has a general vector offset. The vector that locates {B}'s
Also {B} is rotated with respect to {A}, as described by
origin is called A
Given Bp we wish to compute Ap as in Fig. 2.7.
FIGURE 2.7:
General transform of a vector.
P to its description relative to an intermediate frame
that has the same orientation as {A}, but whose origin is coincident with the origin
of {B}. This is done by premultiplying by
as in the last section. We then account
for the translation between origins by simple vector addition, as before, and obtain
We can first change
Bp + ApBQRG
(2.17)
Equation 2.17 describes a general transformation mapping of a vector from its
description in one frame to a description in a second frame. Note the following
interpretation of our notation as exemplified in (2.17): the B's cancel, leaving all
quantities as vectors written in terms of A, which may then be added.
The form of (2.17) is not as appealing as the conceptual form
AP_ATBP
(2.18)
That is, we would like to think of a mapping from one frame to another as an
operator in matrix form. This aids in writing compact equations and is conceptually
clearer than (2.17). In order that we may write the mathematics given in (2.17) in
the matrix operator form suggested by (2.18), we define a 4 x 4 matrix operator and
use 4 x 1 position vectors, so that (2.18) has the structure
[Ap1[
APBQRG1[Bpl
L1J [0 0
(2.19)
In other words,
1. a "1" is added as the last element of the 4 x 1 vectors;
2. a row "[0001]" is added as the last row of the 4 x 4 matrix.
We adopt the convention that a position vector is 3 x 1 or 4 x 1, depending on
whether it appears multiplied by a 3 x 3 matrix or by a 4 x 4 matrix. It is readily
seen that (2.19) implements
Bp + ApBQRQ
Ap =
(2.20)
The 4 x 4 matrix in (2.19) is called a homogeneous transform. For our purposes,
it can be regarded purely as a construction used to cast the rotation and translation
of the general transform into a single matrix form. In other fields of study, it can be
used to compute perspective and scaling operations (when the last row is other than
"[0 0 0 1]" or the rotation matrix is not orthonormal). The interested reader should
see [2].
Often, we wifi write an equation like (2.18) without any notation indicating
that it is a homogeneous representation, because it is obvious from context. Note
that, although homogeneous transforms are useful in writing compact equations, a
computer program to transform vectors would generally not use them, because of
time wasted multiplying ones and zeros. Thus, this representation is mainly for our
convenience when thinking and writing equations down on paper.
Mappings: changing descriptions from frame to frame
Section 2.3
as we used rotation matrices to specify an orientation, we will use
transforms (usually in homogeneous representation) to specify a frame. Observe
that, although we have introduced homogeneous transforms in the context of
mappings, they also serve as descriptions of frames. The description of frame {B}
relative to (A} is
EXAMPLE 2.2
Figure 2.8 shows a frame {B}, which is rotated relative to frame (A} about 2 by 30
degrees, translated 10 units in XA, and translated 5 units in
Bp = [307000]T
The definition of frame (B) is
0.866 —0.500 0.000 10.0
0.500 0.866 0.000 5.0
0.000
0.000 1.000 0.0
Find Ap, where
2 21
[3.0 1
(2.22)
0.0]
we use the definition of (B } just given as a transformation:
9.098 1
12.562
(2.23)
FIGURE 2.8:
Frame {B} rotated and translated.
OPERATORS: TRANSLATIONS, ROTATIONS, AND TRANSFORMATIONS
The same mathematical forms used to map points between frames can also be
interpreted as operators that translate points, rotate vectors, or do both. This section
illustrates this interpretation of the mathematics we have already developed.
Translational operators
A translation moves a point in space a finite distance along a given vector direction. With this interpretation of actually translating the point in space, only one
coordinate system need be involved. It turns out that translating the point in space
is accomplished with the same mathematics as mapping the point to a second
frame. Almost always, it is very important to understand which interpretation of
the mathematics is being used. The distinction is as simple as this: When a vector is
moved "forward" relative to a frame, we may consider either that the vector moved
"forward" or that the frame moved "backward." The mathematics involved in the
two cases is identical; only our view of the situation is different. Figure 2.9 indicates
pictorially how a vector A P1 is translated by a vector A
Here, the vector A gives
the information needed to perform the translation.
The result of the operation is a new vector A P2, calculated as
Ap2 = Ap1 + AQ
(2.24)
To write this translation operation as a matrix operator, we use the notation
DQ(q) Ap1
(2.25)
where q is the signed magnitude of the translation along the vector direction
The DQ operator may be thought of as a homogeneous transform of a special
FIGURE 2.9:
Translation operator.
Section 2.4
Operators: translations, rotations, and transformations
simple form:
DQ(q) =
(2.26)
000 1
where
1/q2
are the components of the translation vector Q and q =
+ q2. Equations (2.9) and (2.24) implement the same mathematics. Note
that, if we had defined BpAORG (instead of ApBORG) in Fig. 2.4 and had used it in
(2.9), then we would have seen a sign change between (2.9) and (2.24). This sign
change would indicate the difference between moving the vector "forward" and
moving the coordinate system "backward." By defining the location of {B} relative
we cause the mathematics of the two interpretations to be
to {A} (with A
the same. Now that the "DQ" notation has been introduced, we may also use it to
describe frames and as a mapping.
Rotational operators
Another interpretation of a rotation matrix is as a rotational operator that operates
on a vector A P1 and changes that vector to a new vector, A P2, by means of a rotation,
R. Usually, when a rotation matrix is shown as an operator, no sub- or superscripts
appear, because it is not viewed as relating two frames. That is, we may write
APRAP
(2.27)
Again, as in the case of translations, the mathematics described in (2.13) and in
(2.27) is the same; only our interpretation is different. This fact also allows us to see
how to obtain rotational matrices that are to be used as operators:
The rotation matrix that rotates vectors through some rotation, R, is the same as
the rotation matrix that describes a frame rotated by R relative to the reference frame.
Although a rotation matrix is easily viewed as an operator, we will also define
another notation for a rotational operator that clearly indicates which axis is being
rotated about:
(2.28)
= RK(O) Ap1
In this notation, "RK (0)" is a rotational operator that performs a rotation about
the axis direction K by 0 degrees. This operator can be written as a homogeneous
transform whose position-vector part is zero. For example, substitution into (2.11)
yields the operator that rotates about the Z axis by 0 as
cos0 —sinG 0 0
= [sinG cos0
(2.29)
Of course, to rotate a position vector, we could just as well use the 3 x 3 rotationmatrix part of the homogeneous transform. The "RK" notation, therefore, may be
considered to represent a 3 x 3 or a 4 x 4 matrix. Later in this chapter, we will see
how to write the rotation matrix for a rotation about a general axis K.
FIGURE 2.10: The vector Ap1
rotated 30 degrees about 2.
EXAMPLE 2.3
Figure 2.10 shows a vector A P1. We wish to compute the vector obtained by rotating
this vector about 2 by 30 degrees. Call the new vector
The rotation matrix that rotates vectors by 30 degrees about 2 is the same as
the rotation matrix that describes a frame rotated 30 degrees about Z relative to the
reference frame. Thus, the correct rotational operator is
[0.866 —0.500 0.000 1
[0.000 0.000 1.000]
(2.30)
(2.31)
we calculate Ap2 as
r—i.000l
(2.32)
Equations (2.13) and (2.27) implement the same mathematics. Note that, if we
had defined R (instead of R) in (2.13), then the inverse of R would appear in (2.27).
This change would indicate the difference between rotating the vector "forward"
versus rotating the coordinate system "backward." By defining the location of {B}
relative to {A} (by R), we cause the mathematics of the two interpretations to be
the same.
Operators: translations, rotations, and transformations
Section 2.4
Transformation operators
with vectors and rotation matrices, a frame has another interpretation as
a transformation operator. In this interpretation, only one coordinate system is
involved, and so the symbol T is used without sub- or superscripts. The operator T
rotates and translates a vector A P1 to compute a new vector,
AP_TAP
(2.33)
Again, as in the case of rotations, the mathematics described in (2.18) and in (2.33)
is the same, only our interpretation is different. This fact also allows us to see how
to obtain homogeneous transforms that are to be used as operators:
The transform that rotates by R and translates by Q is the same as the transform
that describes afraine rotated by Rand translated by Q relative to the reference frame.
A transform is usually thought of as being in the form of a homogeneous
transform with general rotation-matrix and position-vector parts.
EXAMPLE 2.4
Figure 2.11 shows a vector A P1. We wish to rotate it about 2 by 30 degrees and
translate it 10 units in XA and 5 units in
Find Ap2 where Ap1 = [3.0 7.0 0•01T•
The operator T, which performs the translation and rotation, is
FIGURE 2.11:
The vector Ap1 rotated and translated to form Ap2
(2.34)
r 3.0 1
(2.35)
L0.0]
we use T as an operator:
T Ap1
9.0981
(2.36)
Note that this example is numerically exactly the same as Example 2.2, but the
interpretation is quite different.
SUMMARY OF INTERPRETATIONS
We have introduced concepts first for the case of translation only, then for the
case of rotation only, and finally for the general case of rotation about a point
and translation of that point. Having understood the general case of rotation and
translation, we wifi not need to explicitly consider the two simpler cases since they
are contained within the general framework.
As a general tool to represent frames, we have introduced the homogeneous
transform, a 4 x 4 matrix containing orientation and position information.
We have introduced three interpretations of this homogeneous transform:
It is a description of a frame.
describes the frame {B} relative to the frame
{A}. Specifically, the colunms of
are unit vectors defining the directions of
the principal axes of {B}, and A
locates the position of the origin of {B}.
Bp -÷ Ap
2. It is a transform mapping.
maps
3. It is a transform operator. T operates on Ap1 to create Ap2
From this point on, the terms frame and transform wifi both be used to refer
to a position vector plus an orientation. Frame is the term favored in speaking of a
description, and transform is used most frequently when function as a mapping or
operator is implied. Note that transformations are generalizations of (and subsume)
translations and rotations; we wifi often use the term transform when speaking of a
pure rotation (or translation).
TRANSFORMATION ARITHMETIC
In this section, we look at the multiplication of transforms and the inversion of
transforms. These two elementary operations form a functionally complete set of
transform operators.
Compound transformations
In Fig. 2.12, we have Cp and wish to find Ap
Transformation arithmetic
Section 2.6
FIGURE 2.12:
Compound frames: Each is known relative to the previous one.
Frame {C} is known relative to frame {B}, and frame {B} is known relative to
frame (A}. We can transform Cp into Bp as
then we can transform B P into A P as
(2.37)
(2.38)
Combining (2.37) and (2.38), we get the (not unexpected) result
APATBTCP
from which we could define
(2.39)
AT_ATBT
Again, note that familiarity with the sub- and superscript notation makes these
manipulations simple. In terms of the known descriptions of {B} and {C}, we can
give the expression for
(2.41)
Inverting a transform
Consider a frame {B} that is known with respect to a frame {A}—that is, we know
Sometimes we will wish to invert this transform, in order to get a
the value of
description of {A} relative to {B}—that is, T. A straightforward way of calculating
the inverse is to compute the inverse of the 4 x 4 homogeneous transform. However,
advantage of the structure inherent in the
transform. It is easy to find a computationally simpler method of computing the
inverse, one that does take advantage of this structure.
if we do so, we are not taking full
To find
we must compute
and BPAORG from
First,
recall from our discussion of rotation matrices that
(2.42)
Next, we change the description of A
into {B} by using (2.13):
_BRApBORG+
BORGYA
AORG
The left-hand side of (2.43) must be zero, so we have
BRApBORG__BR TAp
2. 44
Using (2.42) and (2.44), we can write the form of T as
ARTAPBORG 1
Note that, with our notation,
(2.45)
BT _AT_i
Equation (2.45) is a general and extremely useful way of computing the inverse of a
homogeneous transform.
EXAMPLE 2.5
Figure 2.13 shows a frame {B} that is rotated relative to frame {A} about Z by 30
degrees and translated four units in XA and three units in
Thus, we have a
description of
Find
The frame defining {B} is
0.866 —0.500 0.000 4.0
0.500 0.866 0.000 3.0
0.000 0.000 1.000 0.0
(2.46)
FIGURE 2.13: {B} relative to {A}.
Section 2.7
Transform equations
Using (2.45), we compute
0.866 0.500 0.000 —4.964
—0.500 0.866 0.000 —0.598
0.000 0.000 1.000
(2.47)
Figure 2.14 indicates a situation in which a frame {D} can be expressed as products
of transformations in two different ways. First,
UT — UT AT.
(2.48)
second;
equal to construct a transform
We can set these two descriptions of
equation:
(2.49)
UTAT — UT BT CT
(2.50)
FIGURE 2.14:
Set of transforms forming
Transform equations can be used to solve for transforms in the case of n unknown
transforms and n transform equations. Consider (2.50) in the case that all transforms
are known except
Here, we have one transform equation and one unknown
transform; hence, we easily find its solution to be
BT — UT_i UT AT CT—i
(2.51)
Figure 2.15 indicates a similar situation.
Note that, in all figures, we have introduced a graphical representation of
frames as an arrow pointing from one origin to another origin. The arrow's direction
indicates which way the frames are defined: In Fig. 2.14, frame {D} is defined relative
to [A}; in Fig. 2.15, frame {A} is defined relative to {D}. In order to compound frames
when the arrows line up, we simply compute the product of the transforms. If an
arrow points the opposite way in a chain of transforms, we simply compute its
inverse first. In Fig. 2.15, two possible descriptions of {C} are
UT — UT DT-i D
(2.52)
(2.53)
FIGURE 2.15:
Example of a transform equation.
More on representation of orientation
Section 2.8
(B }
FIGURE 2.16:
Manipulator reaching for a bolt.
Again, we might equate (2.52) and (2.53) to solve for, say,
(2.54)
EXAMPLE 2.6
Assume that we know the transform T in Fig. 2.16, which describes the frame at
the manipulator's fingertips {T} relative to the base of the manipulator, {B}, that
we know where the tabletop is located in space relative to the manipulator's base
(because we have a description of the frame {S} that is attached to the table as
shown, T), and that we know the location of the frame attached to the bolt lying
Calculate the position and
on the table relative to the table frame—that is,
orientation of the bolt relative to the manipulator's hand, T.
Guided by our notation (and, it is hoped, our understanding), we compute the
bolt frame relative to the hand frame as
(2.55)
So far, our only means of representing an orientation is by giving a 3 x 3 rotation
matrix. As shown, rotation matrices are special in that all columns are mutually
orthogonal and have unit magnitude. Further, we wifi see that the determinant of a
rotation matrix is always equal to +1. Rotation matrices may also be called proper
orthonormal matrices, where "proper" refers to the fact that the determinant is +1
(nonproper orthonormal matrices have the determinant —1).
It is natural to ask whether it is possible to describe an orientation with fewer
than nine numbers. A result from linear algebra (known as Cayley's formula for
orthonormal matrices [3]) states that, for any proper orthonormal matrix R, there
exists a skew-symmetric matrix S such that
+ 5),
(13 —
(2.56)
where 13 is a 3 x 3 unit matrix. Now a skew-symmetric matrix (i.e., S = _ST) of
dimension 3 is specified by three parameters (si,
sy 1
(2.57)
Therefore, an immediate consequence of formula (2.56) is that any 3 x 3 rotation
matrix can be specified by just three parameters.
Clearly, the nine elements of a rotation matrix are not all independent. In fact,
given a rotation matrix, R, it is easy to write down the six dependencies between the
elements. Imagine R as three columns, as originally introduced:
(2.58)
As we know from Section 2.2, these three vectors are the unit axes of some frame
written in terms of the reference frame. Each is a unit vector, and all three must be
mutually perpendicular, so we see that there are six constraints on the nine matrix
elements:
iic' 1= 1,
(2.59)
.2=0.
It is natural then to ask whether representations of orientation can be devised such
that the representation is conveniently specified with three parameters. This section
will present several such representations.
Whereas translations along three mutually perpendicular axes are quite easy
to visualize, rotations seem less intuitive. Unfortunately, people have a hard time
describing and specifying orientations in three-dimensional space. One difficulty is
that rotations don't generally commute. That is,
is not•the same as
Section 2.8
More on representation of orientation
EXAMPLE 2.7
Consider two rotations, one about 2 by 30 degrees and one about
by 30 degTees:
0.866 —0.500 0.000 1
[0.000
(2.60)
1.000 0.000
0.000 1
0.000 0.866 —0.500
0.866]
L 0.000 0.500
r 0.87
0.50
[0.00
0.43
L 0.25
(2.61)
0.25
0.75 —0.43
0.50 0.87
—0.43
—0.50
0.00 1
0.75 —0.50
0.87]
(2.62)
The fact that the order of rotations is important should not be surprising; furthermore, it is captured in the fact that we use matrices to represent rotations, because
multiplication of matrices is not commutative in general.
Because rotations can be thought of either as operators or as descriptions of
orientation, it is not surprising that different representations are favored for each
of these uses. Rotation matrices are useful as operators. Their matrix form is such
that, when multiplied by a vector, they perform the rotation operation. However,
rotation matrices are somewhat unwieldy when used to specify an orientation. A
human operator at a computer terminal who wishes to type in the specification
of the desired orientation of a robot's hand would have a hard time inputting a
nine-element matrix with orthonormal colunms. A representation that requires only
three numbers would be simpler. The following sections introduce several such
representations.
fixed angles
One method of describing the orientation of a frame (B} is as follows:
Start with the frame coincident with a known reference frame {A}.
Rotate {B} first about XA by an angle y, then about
by an angle
and, finally, about 2A by an angle a.
Each of the three rotations takes place about an axis in the fixed reference
frame {A}. We will call this convention for specifying an orientation X—Y—Z fixed
angles. The word "fixed" refers to the fact that the rotations are specified about
the fixed (i.e., nonmoving) reference frame (Fig. 2.17). Sometimes this convention
is referred to as roll, pitch, yaw angles, but care must be used, as this name is often
given to other related but different conventions.
X—Y—Z fixed angles. Rotations are performed in the order
Rz(a).
FIGURE 2.17:
The derivation of the equivalent rotation matrix,
(y, fi, a), is straightforward, because all rotations occur about axes of the reference frame; that is,
0 cy —sy
(2.63)
1] [—sfi 0 c,8j [0 sy cy ]
where ca is shorthand for cos a, sa for sin a, and so on. It is extremely important to
understand the order of rotations used in (2.63). Thinking in terms of rotations as
(y), then (p), and
operators, we have applied the rotations (from the right) of
Multiplying (2.63) out, we obtain
then
r cac,8 cas,8sy—sacy casficy+sasyl
+ cacy
sac,8
c18cy
casy
(2.64)
Keep in mind that the definition given here specifies the order of the three rotations.
Equation (2.64) is correct only for rotations performed in the order: about XA by y,
about
by $, about ZA by a.
The inverse problem, that of extracting equivalent X—Y—Z fixed angles from
a rotation matrix, is often of interest. The solution depends on solving a set of
transcendental equations: there are nine equations and three unknowns if (2.64) is
equated to a given rotation matrix. Among the nine equations are six dependencies,
so, essentially, we have three equations and three unknowns. Let
r r11
r12 r13 1
(2.65)
r33 ]
From (2.64), we see that, by taking the square root of the sum of the squares
we can compute cos Then, we can solve for with the arc tangent
over the computed cosine. Then, as long as cfi
0, we can solve for a by
taking the arc tangent of r21/c,8 over r11/c13 and we can solve for y by taking the arc
tangent of r32/c,8 over
In summary,
r11/c,8),
(2.66)
where Atan2(y, x) is a two-argument arc tangent function.3
Although a second solution exists, by using the positive square root in the
formula for
we always compute the single solution for which —90.0°
< 90.00.
This is usually a good practice, because we can then define one-to-one mapping
functions between various representations of orientation. However, in some cases,
calculating all solutions is important (more on this in Chapter 4). If = ±90.0° (so
that
= 0), the solution of (2.67) degenerates. In those cases, only the sum or
the difference of a and y can be computed. One possible convention is to choose
a = 0.0 in these cases, which has the results given next.
If = 90.0°, then a solution can be calculated to be
= 90.0°,
a = 0.0,
—90.0°,
(2.67)
r22).
then a solution can be calculated to be
= —90.0°,
0.0,
(2.68)
—Atan2(r12, r92).
Z—Y--X Euler angles
Another possible description of a frame (B] is as follows:
Start with the frame coincident with a known frame {A}. Rotate {B} first
about ZB by an angle a, then about
and, finally, about
XB by an angle y.
In this representation, each rotation is performed about an axis of the moving
system (B] rather than one of the fixed reference {A}. Such sets of three rotations
3Atan2(y, x) computes tan1
but uses the signs of both x and y to identify the quadrant in which
the resulting angle lies. For example, Atan 2(—2.0, —2.0) = —135°, whereas Atan 2(2.0, 2.0) = 45°, a
distinction which would be lost with a single-argument arc tangent function. We are frequently computing
angles that can range over a full 360°, so we will make use of the Atan2 function regularly. Note that
Atan2 becomes undefflied when both arguments are zero. It is sometimes called a "4-quadrant arc
tangent," and some programming-language libraries have it predeSned.
FIGURE 2.18:
Z—Y—X Euler angles.
called Euler angles. Note that each rotation takes place about an axis whose
location depends upon the preceding rotations. Because the three rotations occur
about the axes Z, Y, and X, we wifi call this representation Z—Y—X Euler angles.
Figure 2.18 shows the axes of {B} after each Euler-angle rotation is applied.
Rotation about Z causes X to rotate into X', Y to rotate into Y', and so on. An
additional "prime" gets added to each axis with each rotation. A rotation matrix
which is parameterized by Z—Y—X Euler angles wifi be indicated by the notation
y). Note that we have added "primes" to the subscripts to indicate
that this rotation is described by Euler angles.
With reference to Fig. 2.18, we can use the intermediate frames {B'} and {B"}
y). Thinking of the rotations as
in order to give an expression for
descriptions of these frames, we can immediately write
Ap_AQB'QB"R
where each of the relative descriptions on the right-hand side of (2.69) is given by
the statement of the Z—Y--X-Euler-angle convention. Namely, the final orientation
of {B} is given relative to {A} as
ca = cosa, sa = sina, and so on. Multiplying out, we obtain
[cac,8
$, y) =
sacy
sas,Bsy + cacy
+ sasy 1
c,6cy
(2.71)
Note that the result is exactly the same as that obtained for the same three rotations
taken in the opposite order about fixed axes! This somewhat nonintuitive result holds
in general: three rotations taken about fixed axes yield the same final orientation
as the same three rotations taken in opposite order about the axes of the moving
frame.
Because (2.71) is equivalent to (2.64), there is no need to repeat the solution
for extracting Z—Y—X Euler angles from a rotation matrix. That is, (2.66) can also
be used to solve for Z—Y—X Euler angles that correspond to a given rotation matrix.
Euler angles
Another possible description of a frame {B} is
Zb by an angle y.
Rotations are described relative to the frame we are moving, namely, {B}, so
this is an Euler-angle description. Because the three rotations occur about the axes
Z, Y, and Z, we will call this representation Z—Y—Z Euler angles.
Following the development exactly as in the last section, we arrive at the
equivalent rotation matrix
T cac,8cy —
sasy
— sacy
cask 1
+ casy —sac,Bsy + cacy sas,8 J.
(2.72)
The solution for extracting Z—Y--Z Euler angles from a rotation matrix is
stated next.
then, if sin
0, it follows that
'33),
= Atan2(r23/sfl, r13/s$),
= Atan2(r32/s$,
(2.74)
Although a second solution exists (which we find by using the positive square root in
< 180.00.
the formula for
we always compute the single solution for which 0.0 <
If = 0.0 or 180.0°, the solution of (2.74) degenerates. In those cases, only the sum
or the difference of a and y may be computed. One possible convention is to choose
If = 0.0, then a solution can be calculated to be
= 0.0,
= Atan2(—r12,
(2.75)
r11).
= 180.0°, then a solution can be calculated to be
= 180.0°,
(2.76)
= Atan2(r12,
Other angle-set conventions
In the preceding subsections we have seen three conventions for specifying orientation: X—Y—Z fixed angles, Z—Y—X Euler angles, and Z—Y—Z Euler angles. Each
of these conventions requires performing three rotations about principal axes in a
certain order. These conventions are examples of a set of 24 conventions that we
will call angle-set conventions. Of these, 12 conventions are for fixed-angle sets,
and 12 are for Euler-angle sets. Note that, because of the duality of fixed-angle
sets with Euler-angle sets, there are really only 12 unique parameterizations of a
rotation matrix by using successive rotations about principal axes. There is often
no particular reason to favor one convention over another, but various authors
adopt different ones, so it is useful to list the equivalent rotation matrices for all 24
conventions. Appendix B (in the back of the book) gives the equivalent rotation
matrices for all 24 conventions.
Equivalent angle—axis representation
With the notation Rx (30.0) we give the description of an orientation by giving an
axis, X, and an angle, 30.0 degrees. This is an example of an equivalent angle—axis
representation. If the axis is a general direction (rather than one of the unit directions)
any orientation may be obtained through proper axis and angle selection. Consider
the following description of a frame {B}:
Start with the frame coincident with a known frame {A}; then rotate {B}
about the vector AK by an angle 9 according to the right-hand rule.
Vector K is sometimes called the equivalent axis of a finite rotation. A general
9) or RK(O) and wifi
orientation of {B} relative to {A} may be written as
be called the equivalent angle—axis representation.4 The specification of the vector
AK requires only two parameters, because its length is always taken to be one. The
angle specifies a third parameter. Often, we wifi multiply the unit direction, K, with
the amount of rotation, 9, to form a compact 3 x 1 vector description of orientation,
denoted by K (no "hat"). See Fig. 2.19.
When the axis of rotation is chosen from among the principal axes of {A}, then
the equivalent rotation matrix takes on the familiar form of planar rotations:
Rx(8) =
cos9 —sin9
L0 sin9
(2.77)
4That such a k and 0 exist for any orientation of (B} relative to
and is known as Euler's theorem on rotation [3].
was shown originally by Euler
FIG U RE 2.19:
Equivalent angle— axis representation.
sinol
(2.78)
[cos9 —sib
sin0
Rz(9) =
(2.79)
If the axis of rotation is a general axis, it can be shown (as in Exercise 2.6) that the
equivalent rotation matrix is
RK(O)= I
(2.80)
where c9 = cos9, sO = sin9, vO = 1— cos0, and
The sign of 9 is
determined by the right-hand rule, with the thumb pointing along the positive sense
Equation (2.80) converts from angle—axis representation to rotation-matrix
representation. Note that, given any axis of rotation and any angular amount, we
can easily construct an equivalent rotation matrix.
The inverse problem, namely, that of computing K and 0 from a given rotation
matrix, is mostly left for the exercises (Exercises 2.6 and 2.7), but a partial result is
given here [3]. If
RK (9)
(2.81)
r32 r33 J
0 = Acos
(ru + r22± r33
2 sinG
(2.82)
L r21 —
This solution always computes a value of 0 between 0 and 180 degrees. For any
axis—angle pair (AK, 0), there is another pair, namely, (_AK, —0), which results in
the same orientation in space, with the same rotation matrix describing it. Therefore,
in converting from a rotation-matrix into an angle—axis representation, we are faced
with choosing between solutions. A more serious problem is that, for small angular
rotations, the axis becomes ill-defined. Clearly, if the amount of rotation goes to
zero, the axis of rotation becomes completely undefined. The solution given by
(2.82) fails if 0 = 00 or 0 = 180°.
EXAMPLE 2.8
A frame {B)is described as initially coincident with {A}. We then rotate {B} about
the vector A K = [0.7070 7070 0]T (passing through the origin) by an amount 0 = 30
degrees. Give the frame description of {B}.
Substituting into (2.80) yields the rotation-matrix part of the frame description.
There was no translation of the origin, so the position vector is [0, 0,
0.933 0.067 0.354 0.0
0.067 0.933 —0.354 0.0
0.866 0.0
—0.354 0.354
2 83
Up to this point, all rotations we have discussed have been about axes that pass
through the origin of the reference system. If we encounter a problem for which
this is not true, we can reduce the problem to the "axis through the origin" case by
defining additional frames whose origins lie on the axis and then solving a transform
equation.
EXAMPLE 2.9
A frame {B} is described as initially coincident with {A). We then rotate {B} about
the vector AK = [0.707 0.707 001T (passing through the point Ap = [1.0 2.0 3.0])
by an amount 0 = 30 degrees. Give the frame description of {B}.
Before the rotation, (A} and {B} are coincident. As is shown in Fig. 2.20, we
define two new frames, {A'} and {B'}, which are coincident with each other and have
the same orientation as {A} and {B} respectively, but are translated relative to {A}
by an offset that places their origins on the axis of rotation. We wifi choose
1.0 0.0 0.0 1.0
0.0 1.0 0.0 2.0
0.0 0.0 1.0 3.0
0.0 0.0 0.0 1.0
2 84
(B')
2.20: Rotation about an axis that does not pass through the origin of {A}.
Initially, {B} was coincident with {A}.
FIGURE
Similarly, the description of {B} in terms of {B'} is
1.0 0.0 0.0 —1.0
0.0 1.0 0.0 —2.0
0.0 0.0 1.0 —3.0
2 85
Now, keeping other relationships fixed, we can rotate {B'} relative to {A'}. This is a
rotation about an axis that passes through the origin, so we can use (2.80) to compute
{B'} relative to {A'}. Substituting into (2.80) yields the rotation-matrix part of the
frame description. There was no translation of the origin, so the position vector is
[0, 0, OjT. Thus, we have
—0.354 0.354 0.866 0.0
2 86
Finally, we can write a transform equation to compute the desired frame,
(2.87)
which evaluates to
0.933 0.067 0.354 —1.13
0.067 0.933 —0.354 1.13
0.866
0.05
0.000 0.000
1.00
2 88
A rotation about an axis that does not pass through the origin causes a change in
position, plus the same final orientation as if the axis had passed through the origin.
Note that we could have used any definition of {A'} and {B'} such that their origins
were on the axis of rotation. Our particular choice of orientation was arbitrary, and
our choice of the position of the origin was one of an infinity of possible choices
lying along the axis of rotation. (See also Exercise 2.14.)
Euler parameters
Another representation of orientation is by means of four numbers called the Euler
parameters. Although complete discussion is beyond the scope of the book, we state
the convention here for reference.
and the equivalent angle 8, the
In terms of the equivalent axis K =
Euler parameters are given by
€1
= icy sin
€3 =
(2.89)
€4 = cos
It is then clear that these four quantities are not independent:
(2.90)
must always hold. Hence, an orientation might be visualized as a point on a unit
hypersphere in four-dimensional space.
Sometimes, the Euler parameters are viewed as a 3 x 1 vector plus a scalar.
However, as a 4 x 1 vector, the Euler parameters are known as a unit quaternion.
The rotation matrix that is equivalent to a set of Euler parameters is
2(ElE7 — E3E4)
2(E1e3 + E7E4)
2(E1E2 + E3E4)
1 —
2(e2E3 —
2(E1e3 — E2E4)
2(E263 + E1E4)
RE =
1—
(2.91)
Given a rotation matrix, the equivalent Euler parameters are
— r32 — r23
-tE4
€2
r13 —
(2.92)
— r21 — r12
€3 —
€4 =
+ r11 + r22 + r33.
Section 2.9
Transformation of free vectors
Note that (2.92) is not useful in a computational sense
if the rotation matrix
represents a rotation of 180 degrees about some axis, because c4 goes to zero.
However, it can be shown that, in the limit, all the expressions in (2.92) remain finite
even for this case. In fact, from the definitions in (2.88), it is clear that all e, remain
in the interval [—1, 1].
Taught and predefined orientations
In many robot systems, it wifi be possible to "teach" positions and orientations
by using the robot itself. The manipulator is moved to a desired location, and this
position is recorded. A frame taught in this manner need not necessarily be one to
which the robot wifi be commanded to return; it could be a part location or a fixture
location. In other words, the robot is used as a measuring tool having six degrees
of freedom. Teaching an orientation like this completely obviates the need for the
human programmer to deal with orientation representation at all. In the computer,
the taught point is stored as a rotation matrix (or however), but the user never has
to see or understand it. Robot systems that allow teaching of frames by using the
robot are thus highly recommended.
Besides teaching frames, some systems have a set of predefined orientations,
such as "pointing down" or "pointing left." These specifications are very easy
for humans to deal with. However, if this were the only means of describing and
specifying orientation, the system would be very limited.
We have been concerned mostly with position vectors in this chapter. In later
chapters, we wifi discuss velocity and force vectors as well. These vectors will
transform differently because they are a different type of vector.
In mechanics, one makes a distinction between the equality and the equivalence
of vectors. Two vectors are equal if they have the same dimensions, magnitude, and
direction. Two vectors that are considered equal could have different lines of
action—for example, the three equal vectors in Fig 2.21. These velocity vectors
have the same dimensions, magnitude, and direction and so are equal according to
our definition.
Two vectors are equivalent in a certain capacity if each produces the very same
effect in this capacity. Thus, if the criterion in Fig. 2.21 is distance traveled, all three
vectors give the same result and are thus equivalent in this capacity. If the criterion is
height above the xy plane, then the vectors are not equivalent despite their equality.
Thus, relationships between vectors and notions of equivalence depend entirely on
the situation at hand. Furthermore, vectors that are not equal might cause equivalent
effects in certain cases.
We wifi define two basic classes of vector quantities that might be helpful.
The term line vector refers to a vector that is dependent on its line of action,
along with direction and magnitude, for causing its effects. Often, the effects of a
force vector depend upon its line of action (or point of application), so it would then
be considered a line vector.
A free vector refers to a vector that may be positioned anywhere in space without loss or change of meaning, provided that magnitude and direction are preserved.
FIG URE 2.21:
Equal velocity vectors.
For example, a pure moment vector is always a free vector. If we have a
moment vector BN that is known in terms of {B}, then we calculate the same
moment in terms of frame {A} as
AN_ARBN
(2.93)
In other words, all that counts is the magnitude and direction (in the case of a free
vector), so only the rotation matrix relating the two systems is used in transforming.
The relative locations of the origins do not enter into the calculation.
Likewise, a velocity vector written in {B},
v, is written in {A} as
(2.94)
The velocity of a point is a free vector, so all that is important is its direction and
magnitude. The operation of rotation (as in (2.94)) does not affect the magnitude,
yet accomplishes the rotation that changes the description of the vector from {B}
which would appear in a position-vector transformation,
to {A). Note that A
does not appear in a velocity transform. For example, in Fig. 2.22, if B v = 5X, then
Velocity vectors and force and moment vectors wifi be introduced more fully
in Chapter 5.
2.10
COMPUTATIONAL CONSIDERATIONS
The availability of inexpensive computing power is largely responsible for the
growth of the robotics industry; yet, for some time to come, efficient computation
will remain an important issue in the design of a manipulation system.
The homogeneous representation is useful as a conceptual entity, but transformation software typically used in industrial manipulation systems does not make
use of it directly, because the time spent multiplying by zeros and ones is wasteful.
Section 2.10
Computational considerations
FIGURE 2.22:
Transforming velocities.
Usually, the computations shown in (2.41) and (2.45) are performed, rather than the
direct multiplication or inversion of 4 x 4 matrices.
The order in which transformations are applied can make a large difference
in the amount of computation required to compute the same quantity. Consider
performing multiple rotations of a vector, as in
APARBRCRDP
One choice is to first multiply the three rotation matrices together, to form
the expression
(2.95)
R from its three constituents requires 54 multiplications and 36 additions.
Performing the final matrix-vector multiplication of (2.96) requires an additional
9 multiplications and 6 additions, bringing the totals to 63 multiplications and 42
additions.
If, instead, we transform the vector through the matrices one at a time, that is,
AR BR CR Dp
APARBRCP
(2.97)
Ap = Ap
then the total computation requires only 27 multiplications and 18 additions, fewer
than half the computations required by the other method.
Of course, in some cases, the relationships
are constant, while
there are many Dp. that need to be transformed into Ap. In such a case, it is more
efficient to calculate
once, and then use it for all future mappings. See also
Exercise 2.16.
Chapter 2
EXAMPLE 2.10
Give a method of computing the product of two rotation matrices, R
R, that uses
fewer than 27 multiplications and 18 additions.
and C, are the three columns of the result,
Where L. are the columns of
compute
C1 =
(2.98)
which requires 24 multiplications and 15 additions.
[1] B. Noble, Applied Linear Algebra, Prentice-Hall, Englewood Cliffs, NJ, 1969.
[2] D. Ballard and C. Brown, Computer Vision, Prentice-Hall, Englewood Cliffs, NJ, 1982.
[3] 0. Bottema and B. Roth, Theoretical Kinematics, North Holland, Amsterdam, 1979.
[4] R.P. Paul, Robot Manipulators, MIT Press, Cambridge, MA, 1981.
[5] I. Shames, Engineering Mechanics, 2nd edition, Prentice-Hall, Englewood Cliffs, NJ,
1967.
[6] Symon, Mechanics, 3rd edition, Addison-Wesley, Reading, IvIA, 1971.
[71 B. Gorla and M. Renaud, Robots Manipulateurs, Cepadues-Editions, Toulouse, 1984.
[15] A vector Ap is rotated about ZA by 9 degrees and is subsequently rotated
about XA by degrees. Give the rotation matrix that accomplishes these rotations
in the given order.
by 30 degrees and is subsequently rotated
2.2 [15] A vector Ap is rotated about
about XA by 45 degrees. Give the rotation matrix that accomplishes these rotations
2.3 [16] A frame {B} is located initially coincident with a frame {A}. We rotate {B}
about ZB by 9 degrees, and then we rotate the resulting frame about XB by 0
degrees. Give the rotation matrix that will change the descriptions of vectors from
Bp to Ap
2.4 [16] A frame {B} is located initially coincident with a frame {A}. We rotate {B}
about ZB by 30 degrees, and then we rotate the resulting frame about XB by 45
degrees. Give the rotation matrix that will change the description of vectors from
B p to A p.
What
and e_W, where i =
2.5 [13] R is a 3 x 3 matrix with eigenvalues 1,
is the physical meaning of the eigenvector of R associated with the eigenvalue 1?
2.6 [21] Derive equation (2.80).
2.7 [24] Describe (or program) an algorithm that extracts the equivalent angle and
axis of a rotation matrix. Equation (2.82) is a good start, but make sure that your
algorithm handles the special cases 8 = 0° and 9 = 180°.
[29] Write a subroutine that changes representation of orientation from rotationmatrix form to equivalent angle—axis form. A Pascal-style procedure declaration
would begin
Procedure RNTOAA (VAR R:mat33; VAR K:vec3; VAR theta: real);
Write another subroutine that changes from equivalent angle—axis representation
to rotation-matrix representation:
Procedure AATORN(VAR K:vec3; VAR theta: real: VAR R:nat33);
Write the routines in C if you prefer.
Run these procedures on several cases of test data back-to-back and verify that
you get back what you put in. Include some of the difficult cases!
2.9 [27] Do Exercise 2.8 for roll, pitch, yaw angles about fixed axes.
2.10 [27] Do Exercise 2.8 for Z—Y—Z Euler angles.
2.11 [10] Under what condition do two rotation matrices representing finite rotations
commute? A proof is not required.
2.12 [14] A velocity vector is given by
r 10.0
Bv1200
0.866 —0.500 0.000 11.0
0.500 0.866 0.000 —3.0
0.000 1.000 9.0
30.0
compute A
2.13 [21] The following frame definitions are given as known:
1.000 0.000 0.000
0.000 0.866 —0.500 10.0
0.000 0.500
0.866 —20.0
0.866 0.000 —1.0
0.000 1.000 8.0
—0.500 0.000 11.0
0.433
0.250
0.000 —3.0
0.750 —0.500 —3.0
—0.500
Draw a frame diagram (like that of Fig. 2.15) to show their arrangement qualitatively, and solve for
2.14 [31] Develop a general formula to obtain T, where, starting from initial coincidence, {B} is rotated by about where passes through the point Ap (not
through the origin of {A} in general).
2.15 [34] {A} and {B) are frames differing only in orientation. {B} is attained as
follows: starting coincident with {A}, (B] is rotated by radians about unit vector
K—that is,
AR —
2.16 [22] A vector must be mapped through three rotation matrices:
Another choice is to transform the vector through the matrices one at a time—that
D P is changing at 100 Hz, we would have to recalculate A P at the same rate.
However, the three rotation matrices are also changing, as reported by a vision
system that gives us new values for R, R, and
at 30 Hz. What is the best way
to organize the computation to minimize the calculation effort (multiplications
and additions)?
2.17 [16] Another familiar set of three coordinates that can be used to describe a point
in space is cylindrical coordinates. The three coordinates are defined as illustrated
in Fig. 2.23. The coordinate 0 gives a direction in the xy plane along which to
translate radially by an amount r. Finally, z is given to specify the height above
the xy plane. Compute the Cartesian coordinates of the point A P in terms of the
cylindrical coordinates 9, r, and z.
2.18 [18] Another set of three coordinates that can be used to describe a point in
space is spherical coordinates. The three coordinates are defined as illustrated
in Fig. 2.24. The angles a and can be thought of as describing azimuth and
elevation of a ray projecting into space. The third coordinate, r, is the radial
distance along that ray to the point being described. Calculate the Cartesian
coordinates of the point A p in terms of the spherical coordinates a, and r.
2.19 [24] An object is rotated about its X axis by an amount and then it is rotated
about its new axis by an amount i/i. From our study of Euler angles, we know
that the resulting orientation is given by
whereas, if the two rotations had occurred about axes of the fixed reference frame,
the result would have been
FIG U RE
2.23:
Cylindrical coordinates.
FIGURE 2.24: Spherical coordinates.
It appears that the order of multiplication depends upon whether rotations are
described relative to fixed axes or those of the frame being moved. It is more
appropriate, however, to realize that, in the case of specifying a rotation about
an axis of the frame being moved, we are specifying a rotation in the fixed system
given by (for this example)
This similarity transform [1], multiplying the original
on the left, reduces to
the resulting expression in which it looks as if the order of matrix multiplication
has been reversed. Taldng this viewpoint, give a derivation for the form of the
rotation matrix that is equivalent to the Z—Y—Z Euler-angle set (ci, $, y). (The
result is given by (2.72).)
2.20 [2011 Imagine rotating a vector Q about a vector K by an amount 6 to form a new
vector, Q'—that is,
Use (2.80) to derive Rodriques's formula,
Q' = Qcos6
+ sin0(1 x Q) + (1— C058)(le.
2.21 [15] For rotations sufficiently small that the approximations sin 8 = 6, cos 6 = 1,
and 62 = 0 hold, derive the rotation-matrix equivalent to a rotation of 8 about a
Start with (2.80) for your derivation.
general axis,
2.22 [20] Using the result from Exercise 2.21, show that two infinitesimal rotations
commute (i.e., the order in which the rotations are performed is not important).
2.23 [25] Give an algorithm to construct the definition of a frame T from three points
Up1 Up2 and Up3 where the following is known about these points:
1 Up1 js at the origin of {A};
2. Up2 lies somewhere on the positive X axis of {A};
3• Up3 lies near the positive axis in the XY plane of {A).
2.24 [45] Prove Cayley's formula for proper orthonormal matrices.
2.25 [30] Show that the eigenvalues of a rotation matrix are 1,
[33] Prove that any Euler-angle set is sufficient to express all possible rotation
matrices.
2.27 [15] Referring to Fig. 2.25, give the value
2.28 [15] Referring to Fig. 2.25, give the value
2.29 [15] Referring to Fig. 2.25, give the value of T.
2.30 [15] Referring to Fig. 2.25, give the value of T.
2.31 [15] Referring to Fig. 2.26, give the value of T.
2.26
FIGURE 2.25: Frames at the corners of a wedge.
Programming exercise (Part 2)
FIGURE 2.26: Frames
at the corners of a wedge.
2.32 [15] Referring to Fig. 2.26, give the value
2.33 [15] Referring to Fig. 2.26, give the value of T.
2.34 [15] Referring to Fig. 2.26, give the value of
2.35 [20] Prove that the determinant of any rotation matrix is always equal to 1.
2.36 [36] A rigid body moving in a plane (i.e., in 2-space) has three degrees of freedom.
A rigid body moving in 3-space has six degrees of freedom. Show that a body in
N-space has (N2 + N) degrees of freedom.
2.37 [15] Given
0.86
0.87 —0.50 0.00 —4.0
0.75 —0.50 3.0
what is the (2,4) element of T?
2.38 [25] Imagine two unit vectors, v1 and v2, embedded in a rigid body. Note that, no
matter how the body is rotated, the geometric angle between these two vectors is
preserved (i.e., rigid-body rotation is an "angle-preserving" operation). Use this
fact to give a concise (four- or five-line) proof that the inverse of a rotation matrix
must equal its transpose and that a rotation matrix is orthonormal.
2.39 [37] Give an algorithm (perhaps in the form of a C program) that computes the
unit quaternion corresponding to a given rotation matrix. Use (2.91) as starting
point.
2.40 [33] Give an algorithm (perhaps in the form of a C program) that computes the
Z—X—Z Euler angles corresponding to a given rotation matrix. See Appendix B.
2.41 [33] Give an algorithm (perhaps in the form of a C program) that computes the
X—Y—X fixed angles corresponding to a given rotation matrix. See Appendix B.
PROGRAMMING EXERCISE (PART 2)
If your function library does not include an Atan2 function subroutine, write one.
2. To make a friendly user interface, we wish to describe orientations in the planar
world by a single angle, 9, instead of by a 2 x 2 rotation matrix. The user wifi always
communicate in terms of angle 9, but internally we will need the rotation-matrix
form. For the position-vector part of a frame, the user will specify an x and a
y value. So, we want to allow the user to specify a frame as a 3-tuple: (x, y, 9).
Internally, we wish to use a 2 x 1 position vector and a 2 x 2 rotation matrix, so we
need conversion routines. Write a subroutine whose Pascal definition would begin
Procedure UTOI (VAR uforni: vec3; VAR if orm: frame);
where "UTOI" stands for "User form TO Internal form." The first argument is
the 3-tuple (x, y, 0), and the second argument is of type "frame," consists of a
(2 x 1) position vector and a (2 x 2) rotation matrix. If you wish, you may represent
the frame with a (3 x 3) homogeneous transform in which the third row is [0 0 1].
The inverse routine will also be necessary:
Procedure IT{JU (VAR if orm: frame; VAR uform: vec3);
3. Write a subroutine to multiply two transforms together. Use the following procedure heading:
Procedure TMULT (VAR brela, creib, crela: frame);
The first two arguments are inputs, and the third is an output. Note that the names
of the arguments document what the program does (brela =
4. Write a subroutine to invert a transform. Use the following procedure heading:
Procedure TINVERT (VAR brela, areib: frame);
The first argument is the input, the second the output. Note that the names of the
arguments document what the program does (brela
5. The following frame definitions are given as known:
[11.0
1.0 30.0],
=[xy0]=z[0.07.0 45.0],
[x y 9] = [—3.0 —3.0 —30.0].
These frames are input in the user representation [x, y, 9] (where 9 is in degrees).
Draw a frame diagram (like Fig. 2.15, only in 2-D) that qualitatively shows their
arrangement. Write a program that calls TMIJLT and TINVERT (defined in
programming exercises 3 and 4) as many times as needed to solve for T. Then
print out T in both internal and user representation.
MATLAB EXERCISE 2A
a) Using the Z—Y—X (a
y) Euler angle convention, write a MATLAB program
to calculate the rotation matrix R when the user enters the Euler angles a —y.
Test for two examples:
i) a = 10°,
ii) a = 30°,
20°,
90°,
30°.
—55°.
For case (i), demonstrate the six constraints for unitary orthonormal rotation
matrices (i.e., there are nine numbers in a 3 x 3 matrix, but only three are
independent). Also, demonstrate the beautiful property,
for case i.
MATLAB Exercise 2B
b) Write a MATLAB program to calculate the Euler angles a—$—y when the user
enters the rotation matrix R (the inverse problem). Calculate both possible
solutions. Demonstrate this inverse solution for the two cases from part (a). Use
a circular check to verify your results (i.e., enter Euler angles in code a from part
(a); take the resulting rotation matrix
and use this as the input to code b; you
get two sets of answers—one should be the original user input, and the second can
be verified by once again using the code in part (a).
e) For a simple rotation of about the Y axis only, for $ = 200 and B P = {1 0 1 }T,
calculate A F; demonstrate with a sketch that your results are correct.
d) Check all results, by means of the Corke MATLAB Robotics Toolbox. Try the
functions rp y2tr() , tr2rpyQ, rotxQ,
and rotzQ.
MATLAB EXERCISE 2B
a) Write
MATLAB program to calculate the homogeneous transformation matrix
— y and the position vector
T when the user enters Z— V —x Euler angles a —
i) a=10°, fl=20°, y=300,andAPB={1 2
ii) For ,8 = 20° (a =j, = 00), A '3B = (3 0 1 }T•
b) For8 =200
3}T.
=0°),APB ={3 0 1}T,andBP ={1 0 1}T,115eMATLABt0
calculate A P; demonstrate with a sketch that your results are correct. Also, using
the same numbers, demonstrate all three interpretations of the homogeneous
transformation matrix—the (b) assignment is the second interpretation, transform
mapping.
c) Write a MATLAB program to calculate the inverse homogeneous transformation
matrix T1 = T, using the symbolic formula. Compare your result with a
numerical MATLAB function (e.g., mv). Demonstrate that both methods yield
correct results (i.e.,
14). Demonstrate this for examples (i)
and (ii) from (a) above.
d) Define
to be the result from (a)(i) and
to be the result from (a)(ii).
i) Calculate
ii) Given
T, and show the relationship via a transform graph. Do the same
(d)(i)—assume you don't know
calculate it,
compare your result with the answer you know.
and T from (d)(i) —assume you don't know
iii) Given T
e) Check all results by means of the Corke MATLAB Robotics
functions rpy2tr() and translQ.
3.2 LINK DESCRIPTION
3.3 LINK-CONNECTION DESCRIPTION
3.4 CONVENTION FOR AFFIXING FRAMES TO LINKS
3.5 MANIPULATOR KINEMATICS
3.6 ACTUATOR SPACE, JOINT SPACE, AND CARTESIAN SPACE
3.7 EXAMPLES: KINEMATICS OF TWO INDUSTRIAL ROBOTS
3.8 FRAMES WITH STANDARD NAMES
3.9 WHERE IS THE TOOL?
3.10 COMPUTATIONAL CONSIDERATIONS
Kinematics is the science of motion that treats the subject without regard to the
forces that cause it. Within the science of kinematics, one studies the position, the
velocity, the acceleration, and all higher order derivatives of the position variables
(with respect to time or any other variable(s)). Hence, the study of the kinematics of
manipulators refers to all the geometrical and time-based properties of the motion.
The relationships between these motions and the forces and torques that cause them
constitute the problem of dynamics, which is the subject of Chapter 6.
In this chapter, we consider position and orientation of the manipulator
linkages in static situations. In Chapters 5 and 6, we wifi consider the kinematics
when velocities and accelerations are involved.
In order to deal with the complex geometry of a manipulator, we wifi affix
frames to the various parts of the mechanism and then describe the relationships
between these frames. The study of manipulator kinematics involves, among other
things, how the locations of these frames change as the mechanism articulates. The
central topic of this chapter is a method to compute the position and orientation of
the manipulator's end-effector relative to the base of the manipulator as a function
of the joint variables.
LINK DESCRIPTION
A manipulator may be thought of as a set of bodies connected in a chain by joints.
These bodies are called links. Joints form a connection between a neighboring pair
of links. The term lower pair is used to describe the connection between a pair of
Section 3.2
Revolute
Planar
Screw
Prismatic
Cylindrical
Link description
Spherical
FIGURE 3.1:
The six possible lower-pair joints.
bodies when the relative motion is characterized by two surfaces sliding over one
another. Figure 3.1 shows the six possible lower pair joints.
Mechanical-design considerations favor manipulators' generally being constructed from joints that exhibit just one degree of freedom. Most manipulators
have revolute joints or have sliding joints called prismatic joints. In the rare case
that a mechanism is built with a joint having n degrees of freedom, it can be modeled
as n joints of one degree of freedom connected with n — 1 links of zero length.
Therefore, without loss of generality, we wifi consider only manipulators that have
joints with a single degree of freedom.
The links are numbered starting from the immobile base of the arm, which
might be called link 0. The first moving body is link 1, and so on, out to the free
end of the arm, which is link n. In order to position an end-effector generally in
3-space, a minimum of six joints is required.1 Typical manipulators have five or six
joints. Some robots are not actually as simple as a single kinematic chain—these
have parallelogram linkages or other closed kinematic structures. We wifi consider
one such manipulator later in this chapter.
A single link of a typical robot has many attributes that a mechanical designer
had to consider during its design: the type of material used, the strength and stiffness
1This makes good intuitive sense, because the description of an object in space requires six parameters—three for position and three for orientation.
Chapter 3
Axisi—1
Link i
Axisi
FIGURE 3.2: The kinematic function of a link is to maintain a fixed relationship
between the two joint axes it supports. This relationship can be described with two
parameters: the link length, a, and the link twist, a.
of the link, the location and type of the joint bearings, the external shape, the
weight and inertia, and more. However, for the purposes of obtaining the kinematic
equations of the mechanism, a link is considered only as a rigid body that defines
the relationship between two neighboring joint axes of a manipulator. Joint axes are
defined by lines in space. Joint axis i is defined by a line in space, or a vector
direction, about which link i rotates relative to link i 1. It turns out that, for
kinematic purposes, a link can be specified with two numbers, which define the
relative location of the two axes in space.
For any two axes in 3-space, there exists a well-defined measure of distance
between them. This distance is measured along a line that is mutually perpendicular
to both axes. This mutual perpendicular always exists; it is unique except when
both axes are parallel, in which case there are many mutual perpendiculars of equal
length. Figure 3.2 shows link i — 1 and the mutually perpendicular line along which
is measured. Another way to visualize the link parameter
the link length,
is to imagine an expanding cylinder whose axis is the joint i — 1 axis—when it just
touches joint axis i, the radius of the cylinder is equal to
The second parameter needed to define the relative location of the two
axes is called the link twist. If we imagine a plane whose normal is the mutually
perpendicular line just constructed, we can project the axes i — 1 and i onto this
plane and measure the angle between them. This angle is measured from axis i — 1
to axis i in the right-hand sense about a1_1.2 We wifi use this definition of the twist
this case,
is given the direction pointing from axis i
ito axis t•
Section 3.3
Bearing "A"
Link-connection description
Bearing "B"
2in.
H—2mn.
FIGURE 3.3:
5in.
2in.—H
A simple link that supports two revolute axes.
In Fig. 3.2,
is indicated as the angle between axis i — 1 and
axis i. (The lines with the triple hash marks are parallel.) In the case of intersecting
axes, twist is measured in the plane containing both axes, but the sense of
lost. In this special case, one is free to assign the sign of a1_1 arbitrarily.
You should convince yourself that these two parameters, length and twist, as
defined above, can be used to define the relationship between any two lines (in this
case axes) in space.
of link i —
EXAMPLE 3.1
Figure 3.3 shows the mechanical drawings of a robot link. If this link is used in a
robot, with bearing "A" used for the lower-numbered joint, give the length and
twist of this link. Assume that holes are centered in each bearing.
By inspection, the common perpendicular lies right down the middle of
the metal bar connecting the bearings, so the link length is 7 inches. The end view
actually shows a projection of the bearings onto the plane whose normal is the mutual
perpendicular. Link twist is measured in the right-hand sense about the common
perpendicular from axis i — 1 to axis i, so, in this example, it is clearly +45 degrees.
LINK-CONNECTION DESCRIPTION
The problem of connecting the links of a robot together is again one filled with
many questions for the mechanical designer to resolve. These include the strength
of the joint, its lubrication, and the bearing and gearing mounting. However, for
the investigation of kinematics, we need only worry about two quantities, which wifi
completely specify the way in which links are connected together.
FIGURE 3.4: The link offset, d, and the joint angle, 9, are two parameters that may be
used to describe the nature of the connection between neighboring links.
Intermediate links in the chain
Neighboring links have a common joint axis between them. One parameter of
interconnection has to do with the distance along this common axis from one link
to the next. This parameter is called the link offset. The offset at joint axis i is called
The second parameter describes the amount of rotation about this common axis
between one link and its neighbor. This is called the joint angle,
Figure 3.4 shows the interconnection of link i 1 and link i. Recall that at_i
is the
is the mutual perpendicular between the two axes of link i — 1. Likewise,
mutual perpendicular defined for link i. The first parameter of interconnection is the
link offset,
which is the signed distance measured along the axis of joint i from
intersects the axis to the point where intersects the axis. The
the point where
is variable if joint i is prismatic.
offset
is indicated in Fig. 3.4. The link offset
The second parameter of interconnection is the angle made between an extension
and measured about the axis of joint i. This is indicated in Fig. 3.4, where
the lines with the double hash marks are parallel. This parameter is named and is
variable for a revolute joint.
First and last links in the chain
depend on joint axes i and i + 1. Hence, a1 through
Link length,
and link twist,
are defined as was discussed in this section. At the ends
a,,4 and
of the chain, it wifi be our convention to assign zero to these quantities. That is,
Link offset,
and joint angle, are well defined
a0 = a,, = 0.0 and
fact, a,, and
do not need to be defined at all.
Section 3.4
Convention for affixing frames to links
for joints 2 through n — 1 according to the conventions discussed in this section. If
joint 1 is revolute, the zero position for
may be chosen arbitrarily; d1 = 0.0 will
be our convention. Similarly, if joint 1 is prismatic, the zero position of d1 may be
chosen arbitrarily;
= 0.0 wifi be our convention. Exactly the same statements
apply to joint n.
These conventions have been chosen so that, in a case where a quantity could
be assigned arbitrarily, a zero value is assigned so that later calculations wifi be as
simple as possible.
Link parameters
Hence, any robot can be described kinematically by giving the values of four
quantities for each link. Two describe the link itself, and two describe the link's
connection to a neighboring link. In the usual case of a revolute joint, is called
the joint variable, and the other three quantities would be fixed link parameters.
For prismatic joints, d1 is the joint variable, and the other three quantities are fixed
link parameters. The definition of mechanisms by means of these quantities is a
convention usually called the Denavit—Hartenberg notation
Other methods of
describing mechanisms are available, but are not presented here.
At this point, we could inspect any mechanism and determine the
Denavit—Hartenberg parameters that describe it. For a six-jointed robot, 18 numbers would be required to describe the fixed portion of its kinematics completely.
In the case of a six-jointed robot with all revolute joints, the 18 numbers are in the
form of six sets of
di).
EXAMPLE 3.2
Two links, as described in Fig. 3.3, are connected as links 1 and 2 of a robot. Joint 2
is composed of a "B" bearing of link 1 and an "A" bearing of link 2, arranged so
that the flat surfaces of the "A" and "B" bearings lie flush against each other. What
is d2?
The link offset d2 is the offset at joint 2, which is the distance, measured along
the joint 2 axis, between the mutual perpendicular of link 1 and that of link 2. From
the drawings in Fig. 3.3, this is 2.5 inches.
Before introducing more examples, we wifi define a convention for attaching
a frame to each link of the manipulator.
CONVENTION FOR AFFIXING FRAMES TO LINKS
In order to describe the location of each link relative to its neighbors, we define a
frame attached to each link. The link frames are named by number according to the
link to which they are attached. That is, frame {i } is attached rigidly to link i.
4Note that many related conventions go by the name Denavit—Hartenberg, but differ in a few details.
For example, the version used in this book differs from some of the robotic literature in the manner of
frame numbering. Unlike some other conventions, in this book frame {i} is attached to link i and has its
origin lying on joint axis i.
The convention we wifi use to locate frames on the links is as follows: The 2-axis
of frame {i}, called Z1, is coincident with the joint axis i. The origin of frame {i} is
located where the perpendicular intersects the joint i axis. X1 points along a1 in
the direction from joint ito joint i + 1.
In the case of a1 = 0, X1 is normal to the plane of Z1 and
We define a1 as
being measured in the right-hand sense about
and so we see that the freedom of
choosing the sign of in this case corresponds to two choices for the direction of
is formed by the right-hand rule to complete the ith frame. Figure 3.5 shows
the location of frames {i — 1} and {i I for a general manipulator.
We attach a frame to the base of the robot, or link 0, called frame {0}. This
frame does not move; for the problem of arm kinematics, it can be considered the
reference frame. We may describe the position of all other link frames in terms of
this frame.
Frame {0} is arbitrary, so it always simplifies matters to choose Z0 along axis 1
and to locate frame {0} so that it coincides with frame {1} when joint variable 1 is
zero. Using this convention, we wifi always have a0 = 0.0, a0 = 0.0. Additionally,
this ensures that d1 = 0.0 if joint 1 is revolute, or 01 = 0.0 if joint 1 is prismatic.
For joint n revolute, the direction of XN is chosen so that it aligns with XN_j
when
= 0.0, and the origin of frame {N} is chosen so that = 0.0. For joint n
prismatic, the direction of XN is chosen so that = 0.0, and the origin of frame {N}
is chosen at the intersection of XN.1 and joint axis n when d,, = 0.0.
— 1
FIGURE 3.5:
Link frames are attached so that frame {i} is attached rigidly to link i.
Convention for affixing frames to links
Section 3.4
Summary of the link parameters in terms of the link frames
If the link frames have been attached to the links according to our convention, the
following definitions of the link parameters are valid:
the angle from
the distance from
distance from Z1 to
=the angle from
measured along
measured about
measured about Z•
We usually choose a1 > 0, because it corresponds to a distance; however,
and are signed quantities.
A final note on uniqueness is warranted. The convention outlined above does
not result in a unique attachment of frames to links. First of all, when we first align
the Z, axis withjoint axis i, there are two choices of direction in which to point
Z. Furthermore, in the case of intersecting joint axes (i.e., = 0), there are two
choices for the direction of
corresponding to the choice of signs for the normal
to the plane containing 2, and 2i+1• When axes i and i + 1 are parallel, the choice
of origin location for {i } is arbitrary (though generally chosen in order to cause d1 to
be zero). Also, when prismatic joints are present, there is quite a bit of freedom in
frame assignment. (See also Example 3.5.)
Summary of link-frame attachment procedure
The following is a summary of the procedure to follow when faced with a new
mechanism, in order to properly attach the link frames:
1. Identify the joint axes and imagine (or draw) infinite lines along them.
steps 2 through 5 below, consider two of these neighboring lines (at axes i and
i + 1).
2. Identify the common perpendicular between them, or point of intersection.
At the point of intersection, or at the point where the common perpendicular
meets the ith axis, assign the link-frame origin.
3. Assign the Z1 axis pointing along the ith joint axis.
4. Assign the
axis pointing along the common perpendicular, or, if the axes
intersect, assign k1 to be normal to the plane containing the two axes.
5. Assign the axis to complete a right-hand coordinate system.
6. Assign {0} to match {1} when the first joint variable is zero. For {N}, choose an
origin location and XN direction freely, but generally so as to cause as many
linkage parameters as possible to become zero.
EXAMPLE 3.3
Figure 3.6(a) shows a three-link planar arm. Because all three joints are revolute,
this manipulator is sometimes called an RRR (or 3R) mechanism. Fig. 3.6(b) is a
schematic representation of the same manipulator. Note the double hash marks
FIGURE 3.6: A three-link planar arm. On the right, we show the same manipulator
by means of a simple schematic notation. Hash marks on the axes indicate that they
are mutually parallel.
indicated on each of the three axes, which indicate that these axes are parallel.
Assign link frames to the mechanism and give the Denavit—Hartenberg parameters.
We start by defining the reference frame, frame {O}. It is fixed to the base and
aligns with frame {i} when the first joint variable (9k) is zero. Therefore, we position
frame {O} as shown in Fig. 3.7 with Z0 aligned with the joint-i axis. For this arm,
all joint axes are oriented perpendicular to the plane of the arm. Because the arm
FIGURE 3.7: Link-frame assignments.
FIGURE 3.8:
Link parameters of the three-link planar manipulator.
lies in a plane with all 2 axes parallel, there are no link offsets—all are zero. All
joints are rotational, so when they are at zero degrees, all X axes must align.
With these comments in mind, it is easy to find the frame assignments shown
in Fig. 3.7. The corresponding link parameters are shown in Fig. 3.8.
Note that, because the joint axes are all parallel and all the Z axes are taken as
pointing out of the paper, all
a very simple mechanism.
Note also that our kinematic analysis always ends at a frame whose origin lies on
the last joint axis; therefore, 13 does not appear in the link parameters. Such final
offsets to the end-effector are dealt with separately later.
EXAMPLE 3.4
Figure 3.9(a) shows a robot having three degrees of freedom and one prismatic joint.
This manipulator can be called an "RPR mechanism," in a notation that specifies
the type and order of the joints. It is a "cylindrical" robot whose first two joints
are analogous to polar coordinates when viewed from above. The last joint (joint 3)
provides "roll" for the hand. Figure 3.9(b) shows the same manipulator in schematic
Joint 2
Joint 3
Joint 1
FIGURE 3.9:
Manipulator having three degrees of freedom and one prismatic joint.
FIGURE 3.10:
Link-frame assignments.
form. Note the symbol used to represent prismatic joints, and note that a "dot" is
used to indicate the point at which two adjacent axes intersect. Also, the fact that
axes 1 and 2 are orthogonal has been indicated.
Figure 3.10(a) shows the manipulator with the prismatic joint at minimum
extension; the assignment of link frames is shown in Fig. 3.10(b).
Note that frame {0} and frame {1} are shown as exactly coincident in this figure,
because the robot is drawn for the position = 0. Note that frame {0}, although not
at the bottom of the flanged base of the robot, is nonetheless rigidly affixed to link 0,
the nonmoving part of the robot. Just as our link frames are not used to describe the
kinematics all the way out to the hand, they need not be attached all the way back
to the lowest part of the base of the robot. It is sufficient that frame {O} be attached
anywhere to the nonmoving link 0, and that frame {N}, the final frame, be attached
anywhere to the last link of the manipulator. Other offsets can be handled later in a
general way.
Note that rotational joints rotate about the Z axis of the associated frame, but
prismatic joints slide along Z. In the case where joint i is prismatic, is a fixed
constant, and is the variable. If d1 is zero at minimum extension of the link, then
frame {2} should be attached where shown, so that d2 wifi give the true offset. The
link parameters are shown in Fig. 3.11.
Note that 87 is zero for this robot and that d7 is a variable. Axes 1 and 2
must be 90 degrees in order to rotate
so as to
intersect, so a1 is zero. Angle
align with 1, (about X1).
EXAMPLE 3.5
Figure 3.12(a) shows a three-link, 3R manipulator for which joint axes 1 and 2
intersect and axes 2 and 3 are parallel. Figure 3.12(b) shows the kinematic schematic
of the manipulator. Note that the schematic includes annotations indicating that the
first two axes are orthogonal and that the last two are parallel.
Demonstrate the nonuniqueness of frame assignments and of the Denavit—
Hartenberg parameters by showing several possible correct assignments of frames
(1}and{2}.
Section 3.5
a1_1
0j—1
FIGURE 3.11:
Link parameters for the RPR manipulator of Example 3.4.
FIGURE 3.12:
Three-link, nonpianar manipulator.
Figure 3.13 shows two possible frame assignments and corresponding parameters for the two possible choices of direction of Z2.
In general, when 2, and 2j+1 intersect, there are two choices for
In this
example, joint axes 1 and 2 intersect, so there are two choices for the direction of
X1. Figure 3.14 shows two more possible frame assignments, corresponding to the
second choice of X1.
In fact, there are four more possibilities, corresponding to the preceding four
choices, but with Z1 pointing downward.
MANIPULATOR KINEMATICS
In this section, we derive the general form of the transformation that relates
the frames attached to neighboring links. We then concatenate these individual
transformations to solve for the position and orientation of link n relative to link 0.
a2 =
FIGURE 3.13: Two possible frame assignments.
a1 = 0
a2 = 0
02 =
d1=0
FIGURE 3.14: Two more possible frame assignments.
Derivation of link transformations
We wish to construct the transform that defines frame {i } relative to the frame {i — 1}.
In general, this transformation will be a function of the four link parameters. For
any given robot, this transformation wifi be a function of only one variable, the other
three parameters being fixed by mechanical design. By defining a frame for each
link, we have broken the kinematics problem into a subproblems. In order to solve
each of these subproblems, namely
we will further break each subproblem
into four subsubproblems. Each of these four transformations will be a function of
one link parameter oniy and will be simple enough that we can write down its form
by inspection. We begin by defining three intermediate frames for each link—{P},
{Q}, and {R}.
Figure 3.15 shows the same pair of joints as before with frames {P}, {Q}, and
{R} defined. Note that only the X and Z axes are shown for each frame, to make
the drawing clearer. Frame {R} differs from frame {i 1} only by a rotation of
Adsi
FIGURE 3.15: Location of intermediate frames {P}, {Q}, and {R}.
Frame (Q} differs from {R} by a translation
Frame {P} differs from {Q} by a
rotation
and frame {i} differs from {P} by a translation d1. If we wish to write the
transformation that transforms vectors defined in {i} to their description in {i —
we may write
i—lp
(3.1)
(3.2)
(3.3)
Considering each of these transformations, we see that (3.3) may be written
(3.4)
(3.5)
where the notation ScrewQ (r, q') stands for the combination of a translation along an
axis
by a distance r and a rotation about the same axis by an angle Multiplying
out (3.4), we obtain the general form of
(3.6)
EXAMPLE 3.6
Using the link parameters shown in Fig. 3.11 for the robot of Fig. 3.9, compute the
individual transformations for each link.
Substituting the parameters into (3.6), we obtain
0T—
c91 00
(3.7)
c93 —sO3 0 0
2T—
Once having derived these link transformations, we wifi find it a good idea to check
them against common sense. For example, the elements of the fourth column of
each transform should give the coordinates of the origin of the next higher frame.
Concatenating link transformations
Once the link frames have been defined and the corresponding link parameters
found, developing the kinematic equations is straightforward. From the values of the
link parameters, the individual link-transformation matrices can be computed. Then,
the link transformations can be multiplied together to find the single transformation
that relates frame [N} to frame {0}:
(3.8)
This transformation, T, wifi be a function of all ii joint variables. If the robot's
joint-position sensors are queried, the Cartesian position and orientation of the last
link can be computed by
The position of all the links of a manipulator of n degrees of freedom can be
specified with a set of n joint variables. This set of variables is often referred to as
the a x 1 joint vector. The space of all such joint vectors is referred to as joint space.
Thus far in this chapter, we have been concerned with computing the Cartesian
space description from knowledge of the joint-space description. We use the term
Cartesian space when position is measured along orthogonal axes and orientation
is measured according to any of the conventions outlined in Chapter 2. Sometimes,
the terms task-oriented space and operational space are used for what we will call
Cartesian space.
Section 3.7
Actuator
space
FIG U RE 3.16:
Examples: kinematics of two industrial robots
Joint
Cartesian
Mappings between kinematic descriptions.
So far, we have implicitly assumed that each kinematic joint is actuated directly
by some sort of actuator. However, in the case of many industrial robots, this is not so.
For example, sometimes two actuators work together in a differential pair to move a
single joint, or sometimes a linear actuator is used to rotate a revolute joint, through
the use of a four-bar linkage. In these cases, it is helpful to consider the notion of
actuator positions. The sensors that measure the position of the manipulator are
often located at the actuators, so some computations must be performed to realize
the joint vector as a function of a set of actuator values, or actuator vector.
As is indicated in Fig. 3.16, there are three representations of a manipulator's
position and orientation: descriptions in actuator space, in joint space, and in
Cartesian space. In this chapter, we are concerned with the mappings between
representations, as indicated by the solid arrows in Fig. 3.16. In Chapter 4, we will
consider the inverse mappings, indicated by the dashed arrows.
The ways in which actuators might be connected to move a joint are quite
varied; they might be catalogued, but we wifi not do so here. For each robot we
design or seek to analyze, the correspondence between actuator positions and joint
positions must be solved. In the next section, we will solve an example problem for
an industrial robot.
EXAMPLES: KINEMATICS OF TWO INDUSTRIAL ROBOTS
Current industrial robots are available in many different kinematic configurations [2],
[3]. In this section, we work out the kinematics of two typical industrial robots. First
we consider the Unimation PUMA 560, a rotary-joint manipulator with six degrees
of freedom. We will solve for the kinematic equations as functions of the joint angles.
For this example, we wifi skip the additional problem of the relationship between
actuator space and joint space. Second, we consider the Yasukawa Motoman L-3, a
robot with five degrees of freedom and rotary joints. This example is done in detail,
including the actuator-to-joint transformations. This example may be skipped on
first reading of the book.
The PUMA 560
The Unimation PUMA 560 (Fig. 3.17) is a robot with six degrees of freedom
and all rotational joints (i.e., it is a 6R mechanism). It is shown in Fig. 3.18, with
FIGURE 3.17: The Unimation PUMA 560. Courtesy of Unimation Incorporated,
Shelter Rock Lane, Danbury, Conn.
link-frame assignments in the position corresponding to all joint angles equal to
zero.5 Figure 3.19 shows a detail of the forearm of the robot.
Note that the frame {0} (not shown) is coincident with frame [1} when is
zero. Note also that, for this robot, as for many industrial robots, the joint axes
of joints 4, 5, and 6 all intersect at a common point, and this point of intersection
coincides with the origin of frames {4}, {5}, and {6}. Furthermore, the joint axes 4, 5,
and 6 are mutually orthogonal. This wrist mechanism is ifiustrated schematically in
Fig. 3.20.
The link parameters corresponding to this placement of link frames are shown
in Fig. 3.21. In the case of the PUMA 560, a gearing arrangement in the wrist of
the manipulator couples together the motions of joints 4, 5, and 6. What this means
is that, for these three joints, we must make a distinction between joint space and
actuator space and solve the complete kinematics in two steps. However, in this
example, we will consider only the kinematics from joint space to Cartesian space.
5Unimation has used a slightly different assignment of zero location of the joints, such that
1800, where
is the position of joint 3 in Unimation's convention.
FIG U RE 3.18:
Some kinematic parameters and frame assignments for the PUMA 560
manipulator.
Kinematic parameters and frame assignments for the forearm of the
PUMA 560 manipulator.
FIG U RE 3.19:
Schematic of a 3R wrist in which all three axes intersect at a point and
are mutually orthogonal. This design is used in the PUMA 560 manipulator and
many other industrial robots.
FIGURE 3.20:
a,—1
—90°
FIGURE 3.21:
Link parameters of the PUMA 560.
Examples: kinematics of two industrial robots
Section 3.7
Using (3.6), we compute each of the link transformations:
c91 —sO1 0
(3.9)
We now form
by matrix multiplication of the individual link matrices.
While forming this product, we wifi derive some subresults that wifi be useful when
solving the inverse kinematic problem in Chapter 4. We start by multiplying
that is,
c5c6 —c5s6 —s5 0
= 4T 5T =
where c5 is shorthand for cos 05, S5 for sin
C4C5C6 —
s5C6
and so on.6 Then we have
C4C5S6 — S4C6
—C4S5
(3.11)
6Depending on the amount of space available to show expressions, we use any of the following three
forms: cos 95, C95, or c5.
joints 2 and 3 are always parallel, multiplying
first and then
applying sum-of-angle formulas wifi yield a somewhat simpler final expression. This
can be done whenever two rotational joints have parallel axes and we have
Because
a2c2
(3.12)
where we have used the sum-of-angle formulas (from Appendix A):
C23 = C2C3 —
S23 = C2S3 +
Then we have
1T 3T —
1r22 1r23 ipy
= c73[c4c5c6
= —S4C5c6 — c4S6,
= —s23[c4c5c6
+ s4c6] + s23s5s6,
—c23[c4c5s6
s4s6] — c23s5c6,
= S4C5S6 — C4C6,
= s93[c4c5s6
+ s4c6] + c23s5s6,
—C23C4S5 —
S23C4S5 — C23C5,
a2c2 + a3 C23
d4s73,
—a3s23 — a2s2 — d4c23.
Finally, we obtain the product of all six link transforms:
0001
(3.13)
Here,
— s4s5) — s23s5c5] + s1(s4c5c6 + c4s6),
s4s6) — s23s5c6 — c1(s4c5c6 + c4s6),
r31 = —s23(c4c5c6 — s4s6) — c23s5c6,
= c1[c23(—c4c5s6 — s4c6) + s23s5s6] + s1(c4c6 — s4c5s6),
r22 = s1[c23(—c4c5s6 — s4c6) + s23s5s6]
c1(c4c6 — s4c5s6),
r32 = —s23(—c4c5s5 — s4c6) + c23s5s6,
r13 = —c1(c23c4s5 + s23c5) — s1s4s5,
r23 = —sj(c23c4s5 + s23c5) + c1s4s5,
r33 = 523C4S5 —
+ a3c23 — d4s23] — d3s1,
P) = s1[a2c2 + a3c23 — d4s23] + d3c1,
= —a3s23 — a2s2 — d4c23.
(3.14)
Equations (3.14) constitute the kinematics of the PUMA 560. They specify how to
compute the position and orientation of frame {6} relative to frame {O} of the robot.
These are the basic equations for all kinematic analysis of this manipulator.
The Yasukawa Motoman L-3
The Yasukawa Motoman L-3 is a popular industrial manipulator with five degrees
of freedom (Fig. 3.22). Unlike the examples we have seen thus far, the Motoman
is not a simple open kinematic chain, but rather makes use of two linear actuators
coupled to links 2 and 3 with four-bar linkages. Also, through a chain drive, joints 4
and 5 are operated by two actuators in a differential arrangement.
In this example, we wifi solve the kinematics in two stages. First, we wifi solve
for joint angles from actuator positions; second, we will solve for Cartesian position
and orientation of the last link from joint angles. In this second stage, we can treat
the system as if it were a simple open-kinematic-chain SR device.
Figure 3.23 shows the linkage mechanism that connects actuator number 2 to
links 2 and 3 of the robot. The actuator is a linear one that directly controls the
length of the segment labeled DC. Triangle ABC is ftxed, as is the length BD. Joint
2 pivots about point B, and the actuator pivots slightly about point C as the linkage
moves. We give the following names to the constants (lengths and angles) associated
with actuator 2:
= AB,
= AC, a2 = BC,
= BD, c, = LJBD, 12 = BJ,
FIGURE 3.22:
The Yasukawa Motoman L-3. Courtesy of Yasukawa.
we give the following names to the variables:
= /CBD, g2 = DC.
Figure 3.24 shows the linkage mechanism that connects actuator number 3 to
length of the segment labeled HG. Triangle EFG is fixed, as is the length FH. Joint
3 pivots about point J, and the actuator pivots slightly about point G as the linkage
with actuator 3:
= EF,
= EG, a3 = GF,
13 =
We give the following names to the variables:
03 = LPJK,
1/13
= LGFH, g3 = GH.
This arrangement of actuators and linkages has the following functional effect.
Actuator 2 is used to position joint 2; while it is doing so, link 3 remains in the
same orientation relative to the base of the robot. Actuator 3 is used to adjust
FIGURE 3.23:
Kinematic details of the Yasukawa actuator-2 linkage.
the orientation of link 3 relative to the base of the robot (rather than relative to
the preceding link as in a serial-kinematic-chain robot). One purpose of such a
linkage arrangement is to increase the structural rigidity of the main linkages of
the robot. This often pays off in terms of an increased ability to position the robot
precisely.
The actuators for joints 4 and 5 are attached to link 1 of the robot with their axes
aligned with that ofjoint 2 (points B and F in Figs. 3.23 and 3.24). They operate the
wrist joints through two sets of chains—one set located interior to link 2, the second
set interior to link 3. The effect of this transmission system, along with its interaction
with the actuation of links 2 and 3, is described functionally as follows: Actuator 4
is used to position joint 4 relative to the base of the robot, rather than relative to the
preceding link 3. This means that holding actuator 4 constant wifi keep link 4 at a
constant orientation relative to the base of the robot, regardless of the positions of
joints 2 and 3. Finally, actuator 5 behaves as if directly connected to joint 5.
We now state the equations that map a set of actuator values (A1) to the
equivalent set of joint values (0,). In this case, these equations were derived by
straightforward plane geometry—mostly just application of the "law of cosines."7
71f a triangle's angles are labeled a, b, and c, where angle a is opposite side A, and so on, then
A2 = B2 + C2 — 2BC cos a.
FIGURE 3.24:
Kinematic details of th3 Yasukawa actuator-3 linkage.
Appearing in these equations are scale (k1) and offset
constants for each
actuator. For example, actuator 1 is directly connected to joint axis 1, and so the
conversion is simple; it is just a matter of a scale factor plus an offset. Thus,
k1A1
+ x1,
+ tan1
+ Q2 —
2700,
93 —cos
94= —k4A4—92—03+A4+180°,
= k5A5
— 90°,
(3.15)
+ A5.
Figure 3.25 shows the attachment of the link frames. In this figure, the manipulator is shown in a position corresponding to the joint vector 0 = (0, —90°, 90°, 90°, 0).
Figure 3.26 shows the link parameters for this manipulator. The resulting linktransformation matrices are
Examples: kinematics of two industrial robots 87
c81 —s91 0
—sO2 0 0
— —sO, —c02 0 0
CO3 —SO3 0
503 c03
(3.16)
—504 0 13
3T—
FIGURE 3.25:
Assignment of link frames for the Yasukawa L-3.
a1—1
FIGURE 3.26:
Link parameters of the Yasukawa L-3 manipulator.
Forming the product to obtain T, we obtain
r11 r12 r13
r39 r33
r11 = c1c234c5
r21 = S1C234C5 + C1S5,
r31 = —s234c5,
r12 = —c1c234s5 —
S1C234S5 + C1C5,
r13 = C1S234,
/33 =
Section 3.8
+ 13c23),
= s1(12c7
Frames with standard names
— 13s93.
(3.17)
We developed the kinematic equations for the Yasukawa Motoman in two
steps. In the first step, we computed a joint vector from an actuator vector; in the
second step, we computed a position and orientation of the wrist frame from the
joint vector. If we wish to compute only Cartesian position and not joint angles, it
is possible to derive equations that map directly from actuator space to Cartesian
space. These equations are somewhat simpler computationally than the two-step
approach. (See Exercise 3.10.)
FRAMES WITH STANDARD NAMES
As a matter of convention, it wifi be helpful if we assign specific names and locations
to certain "standard" frames associated with a robot and its workspace. Figure 3.27
shows a typical situation in which a robot has grasped some sort of tool and is
to position the tool tip to a user-defined location. The five frames indicated in
Fig. 3.27 are so often referred to that we will define names for them. The naming
and subsequent use of these five frames in a robot programming and control system
facilitates providing general capabilities in an easily understandable way. All robot
motions will be described in terms of these frames.
Brief definitions of the frames shown in Fig. 3.27 follow.
The base frame, {B}
{B} is located at the base of the manipulator. It is merely another name for frame
{0}. It is affixed to a nonmoving part of the robot, sometimes called link 0.
FIGURE 3.27:
The standard frames.
The station frame, {S}
{S} is located in a task-relevant location. In Fig. 3.28, it is at the corner of a table
upon which the robot is to work. As far as the user of this robot system is concerned,
{S} is the universe frame, and all actions of the robot are performed relative to it.
It is sometimes called the task frame, the world frame, or the universe frame. The
station frame is always specified with respect to the base frame, that is,
The wrist frame, {W}
{W} is affixed to the last link of the manipulator. It is another name for frame {N}, the
link frame attached to the last link of the robot. Very often, {W} has its origin fixed
at a point called the wrist of the manipulator, and {W} moves with the last link of
the manipulator. It is defined relative to the base frame—that is, {W} =
The tool frame, {T}
{T} is affixed to the end of any tool the robot happens to be holding. When the
hand is empty, {T} is usually located with its origin between the fingertips of
the robot. The tool frame is always specified with respect to the wrist frame. In
Fig. 3.28, the tool frame is defined with its origin at the tip of a pin that the robot is
holding.
Tool frame
Base frame
FIGURE 3.28:
Example of the assignment of standard frames.
Section 3.9
Where is the tool?
The goal frame, {G}
{G} is a description of the location to which the robot is to move the tool. Specifically
this means that, at the end of the motion, the tool frame should be brought to
coincidence with the goal frame. {G} is always specified relative to the station frame.
In Fig. 3.28, the goal is located at a hole into which we want the pin to be inserted.
All robot motions may be described in terms of these frames without loss
of generality. Their use helps to give us a standard language for talking about
robot tasks.
WHERE IS THE TOOL?
One of the first capabilities a robot must have is to be able to calculate the position
and orientation of the tool it is holding (or of its empty hand) with respect to a
convenient coordinate system. That is, we wish to calculate the value of the tool
frame, {T}, relative to the station frame, {S}. Once
has been computed via the
kinematic equations, we can use Cartesian transforms, as studied in Chapter 2, to
calculate {T} relative to {S}. Solving a simple transform equation leads to
= T1
(3.18)
Equation (3.18) implements what is called the WHERE function in some robot
systems. It computes "where" the arm is. For the situation in Fig. 3.28, the output of
WHERE would be the position and orientation of the pin relative to the table top.
Equation (3.18) can be thought of as generalizing the kinematics. T computes
the kinematics due to the geometry of the linkages, along with a general transform
(which might be considered a fixed link) at the base end T) and another at the
end-effector
These extra transforms allow us to include tools with offsets and
twists and to operate with respect to an arbitrary station frame.
3.10
In many practical manipulator systems, the time required to perform kinematic
calculations is a consideration. In this section, we briefly discuss various issues
involved in computing manipulator kinematics, as exemplified by (3.14), for the case
of the PUMA 560.
One choice to be made is the use of fixed- or floating-point representation
of the quantities involved. Many implementations use floating point for ease of
software development, because the programmer does not have to be concerned
with scaling operations capturing the relative magnitudes of the variables. However,
when speed is crucial, fixed-point representation is quite possible, because the
variables do not have a large dynamic range, and these ranges are fairly well known.
Rough estimations of the number of bits needed in fixed-point representation seem
to indicate that 24 are sufficient [4].
By factoring equations such as (3.14), it is possible to reduce the number of
multiplications and additions—at the cost of creating local variables (usually a good
trade-off). The point is to avoid computing common terms over and over throughout
the computation. There has been some application of computer-assisted automatic
factorization of such equations [5].
Chapter 3
The major expense in calculating kinematics is often the calculation of the
transcendental functions (sine and cosine). When these functions are available as
part of a standard library, they are often computed from a series expansion at
the cost of many multiply times. At the expense of some required memory, many
manipulation systems employ table-lookup implementations of the transcendental
functions. Depending on the scheme, this reduces the amount of time required to
calculate a sine or cosine to two or three multiply times or less [6].
The computation of the kinematics as in (3.14) is redundant, in that nine
quantities are calculated to represent orientation. One means that usually reduces
computation is to calculate only two columns of the rotation matrix and then to
compute a cross product (requiring only six multiplications and three additions)
to compute the third column. Obviously, one chooses the two least complicated
columns to compute.
[1] J. Denavit and R.S. Hartenberg, "A Kinematic Notation for Lower-Pair Mechanisms
Based on Matrices," Journal of Applied Mechanics, pp. 215—221, June 1955.
"Kinematics," in The International Encyclopedia of Robotics, R. Dorf and
S. Nof, Editors, John C. Wiley and Sons, New York, 1988.
[2] J.
J. Colson and N.D. Perreira, "Kinematic Arrangements Used in Industrial Robots,"
13th Industrial Robots Conference Proceedings, April 1983.
[4] T. Turner, J. Craig, and W. Gruver, "A Microprocessor Architecture for Advanced
Robot Control," 14th ISIR, Stockholm, Sweden, October 1984.
[5] W. Schiehien, "Computer Generation of Equations of Motion," in Computer Aided
Analysis and Optimization of Mechanical System Dynamics, E.J. Haug, Editor, SpringerVerlag, Berlin & New York, 1984.
[61 C. Ruoff, "Fast Trigonometric Functions for Robot Control," Robotics Age, November
1981.
3.1 [15] Compute the kinematics of the planar arm from Example 3.3.
3.2 [37] Imagine an arm like the PUMA 560, except that joint 3 is replaced with
a prismatic joint. Assume the prismatic joint slides along the direction of X1 in
Fig. 3.18; however, there is still an offset equivalent to d3 to be accounted for.
Make any additional assumptions needed. Derive the kinematic equations.
3.3 [25] The arm with three degrees of freedom shown in Fig. 3.29 is like the one in
Example 3.3, except that joint l's axis is not parallel to the other two. Instead,
there is a twist of 90 degrees in magnitude between axes 1 and 2. Derive link
Note that no 13 need be defined.
parameters and the kinematic equations for
3.4 [22] The arm with three degrees of freedom shown in Fig. 3.30 has joints 1
and 2 perpendicular and joints 2 and 3 parallel. As pictured, all joints are at
their zero location. Note that the positive sense of the joint angle is indicated.
Assign link frames {0} through {3} for this arm—that is, sketch the arm, showing
the attachment of the frames. Then derive the transformation matrices
FIGURE 3.29: The 3R
nonpianar arm (Exercise 3.3).
FIGURE 3.30:
Two views of a 3R manipulator (Exercise 3.4).
3.5 [26] Write a subroutine to compute the kinematics of a PUMA 560. Code for
speed, trying to minimize the number of multiplications as much as possible. Use
the procedure heading (or equivalent in C)
Procedure KIN(VAR theta: vec6; VAR wreib: frame);
Count a sine or cosine evaluation as costing 5 multiply times. Count additions
as costing 0.333 multiply times and assignment statements as 0.2 multiply times.
Count a square-root computation as costing 4 multiply times. How many multiply
times do you need?
3.6 [2011 Write a subroutine to compute the kinematics of the cylindrical arm in
Example 3.4. Use the procedure heading (or equivalent in C)
Procedure KIN(VAR jointvar: vec3; VAR wreib: frames);
3.7 [22] Write a subroutine to compute the kinematics of the arm in Exercise 3.3. Use
Procedure KIN(VAR theta: vec3; VAR wreib: frame);
3.8 [13] In Fig. 3.31, the location of the tool, T, is not accurately known. Using force
control, the robot feels around with the tool tip until it inserts it into the socket
(or Goal) at location T. Once in this "calibration" configuration (in which {G}
is figured out by reading
and {T) are coincident), the position of the robot,
the joint angle sensors and computing the kinematics. Assuming T and T are
known, give the transform equation to compute the unknown tool frame, T.
FIGURE 3.31:
Determination of the tool frame (Exercise 3.8).
FIGURE 3.32: Two-link arm with frame assignments (Exercise 3.9).
3.9 [11] For the two-link manipulator shown in Fig. 3.32(a), the link-transformation
matrices,
were constructed. Their product is
c91c02 —c91s92
11c01
s01c92 —s01s02 —c01 11s01
The link-frame assignments used are indicated in Fig. 3.32(b). Note that frame
{0) is coincident with frame {1} when 01 = 0. The length of the second link is 12.
Find an expression for the vector 0
which locates the tip of the arm relative
to the {0} frame.
3.10 [39]
Derive kinematic equations for the Yasukawa Motoman robot (see
Section 3.7) that compute the position and orientation of the wrist frame directly
from actuator values, rather than by first computing the joint angles. A solution
is possible that requires only 33 multiplications, two square roots, and six sine or
cosine evaluations.
3.11 [17] Figure 3.33 shows the schematic of a wrist which has three intersecting axes
that are not orthogonal. Assign link frames to this wrist (as if it were a 3-DOF
manipulator), and give the link parameters.
3.12 [08] Can an arbitrary rigid-body transformation always be expressed with four
parameters (a, a, d, 0) in the form of equation (3.6)?
3.13 [15]
Show the attachment of link frames for the 5-DOF manipulator shown
schematically in Fig. 3.34.
3.14 [20] As was stated, the relative position of any two lines in space can be given
with two parameters, a and a, where a is the length of the common perpendicular
joining the two and a is the angle made by the two axes when projected onto
a plane normal to the common perpendicular. Given a line defined as passing
through point p with unit-vector direction th and a second passing through point
q with unit-vector direction ii, write expressions for a and a.
3.15 [15] Show the attachment of link frames for the 3-DOF manipulator shown
schematically in Fig. 3.35.
3.16 [15] Assign link frames to the RPR planar robot shown in Fig. 3.36, and give the
linkage parameters.
3.17 [15] Show the attachment of link frames on the three-link robot shown in Fig. 3.37.
FIGURE 3.33:
3R nonorthogonal-axis robot (Exercise 3.11).
FIGURE 3.34:
3.18
3.19
3.20
3.21
3.22
Schematic of a 2RP2R manipulator (Exercise 3.13).
[15] Show the attachment of link frames on the three-link robot shown in Fig. 3.38.
[15] Show the attachment of link frames on the three-link robot shown in Fig. 3.39.
[15] Show the attachment of link frames on the three-link robot shown in Fig. 3.40.
[15] Show the attachment of link frames on the three-link robot shown in Fig. 3.41.
[18] Show the attachment of link frames on the P3R robot shown in Fig. 3.42.
Given your frame assignments, what are the signs of d2, d3, and a2?
FIGURE 3.35:
Schematic of a 3R manipulator (Exercise 3.15).
FIGURE 3.36:
RPR planar robot (Exercise 3.16).
FIGURE 3.37:
Three-link RRP manipulator (Exercise 3.17).
--fl--03
FIGURE 3.38:
Three-link RRR manipulator (Exercise 3.18).
3.39: Three-link RPP manipulator (Exercise 3.19).
FIGURE 3.40:
Three-link PRR manipulator (Exercise 3.20).
Programming exercise (Part 3)
FIGURE 3.41: Three-link PPP manipulator (Exercise 3.21).
FIGURE 3.42:
Schematic of a P3R manipulator (Exercise 3.22).
PROGRAMMING EXERCISE (PART 3)
1. Write a subroutine to compute the kinematics of the planar 3R robot in Example 3.3—that is, a routine with the joint angles' values as input, and a frame (the
wrist frame relative to the base frame) as output. Use the procedure heading (or
equivalent in C)
Proceduie KIN(VAR theta: vec3; VAR wreib: franie);
where "wreib" is the wrist frame relative to the base frame,
The type "frame"
consists of a 2 x 2 rotation matrix and a 2 x 1 position vector. If desired, you may
represent the frame with a 3 x 3 homogeneous transform in which the third row is
[0 0 1]. (The manipulator data are 11 = 12 = 0.5 meters.)
100
Write a routine that calculates where the tool is, relative to the station frame. The
input to the routine is a vector of joint angles:
Procedure
WHERE(VAR theta: vec3; VAR trels: frame);
Obviously, WI-IFRE must make use of descriptions of the tool frame and the
robot base frame in order to compute the location of the tool relative to the station
frame. The values of T and T should be stored in global memory (or, as a
second choice, you may pass them as arguments in 'WHERE).
3. A tool frame and a station frame for a certain task are defined as follows by the
user:
=[xy9]=[0.1 0.2 30.0],
[x y 9] = [—0.1 0.3 0.0].
Calculate the position and orientation of the tool relative to the station frame for
the following three configurations (in units of degrees) of the arm:
93] =
[0.0 90.0 —90.0],
93] = [—23.6
[°i
—30.3 48.0],
[130.0 40.0 12.0].
MATLAB EXERCISE 3
This exercise focuses on DII parameters and on the forward-pose (position and orien-
tation) kinematics transformation for the planar 3-DOF, 3R robot (of Figures 3.6 and
3.7). The following fixed-length parameters are given: L1 = 4, L7 = 3, and L3 = 2 (m).
a) Derive the DH parameters. You can check your results against Figure 3.8.
i = 1, 2, 3.
b) Derive the neighboring homogeneous transformation matrices
i = 1, 2, 3. Also, derive the
These are functions of the joint-angle variables
by inspection: The origin of {H} is in the center of the gripper fingers,
constant
and the orientation of {H} is always the same as the orientation of {3}.
c) Use Symbolic MATLAB to derive the forward-pose kinematics solution T and
Abbreviate your answer, using s1 = sin(91),
T symbolically (as a function of
cos(01), and so on. Also, there is a
+ + 93) simplification, by using sumof-angle formulas, that is due to the parallel Z1 axes. Calculate the forward-pose
via MATLAB for the following input cases:
kinematics results (both
i) e =
ii) 0 =
iii) 0 = {90°
{0 0 O}T•
{10° 20° 300}T
90°
For all three cases, check your results by sketching the manipulator configuration
and deriving the forward-pose kinematics transformation by inspection. (Think of
the definition of °HT in terms of a rotation matrix and a position vector.) Include
frames {H}, {3), and {0} in your sketches.
d) Check all your results by means of the Corke MATLAB Robotics Toolbox. Try
functions link() , robotQ, and fkineQ.
4.2 SOLVABILITY
4.3 THE NOTION OF MANIPULATOR SUBSPACE WHEN n <6
4.4 ALGEBRAIC VS. GEOMETRIC
4.5 ALGEBRAIC SOLUTION BY REDUCTION TO POLYNOMIAL
4.6 PIEPER'S SOLUTION WHEN THREE AXES INTERSECT
4.7 EXAMPLES OF INVERSE MANIPULATOR KINEMATICS
4.8 THE STANDARD FRAMES
4.9 SOLVE-ING A MANIPULATOR
4.10 REPEATABILITY AND ACCURACY
4.11 COMPUTATIONAL CONSIDERATIONS
In the last chapter, we considered the problem of computing the position and
orientation of the tool relative to the user's workstation when given the joint angles
of the manipulator. In this chapter, we investigate the more difficult converse
problem: Given the desired position and orientation of the tool relative to the
station, how do we compute the set of joint angles which wifi achieve this desired
result? Whereas Chapter 3 focused on the direct kinematics of manipulators, here
the focus is the inverse kinematics of manipulators.
Solving the problem of finding the required joint angles to place the tool
frame, {T}, relative to the station frame, {S}, is split into two parts. First, frame
transformations are performed to find the wrist frame, {W}, relative to the base
frame, {B}, and then the inverse kinematics are used to solve for the joint angles.
SOLVABILITY
The problem of solving the kinematic equations of a manipulator is a nonlinear one.
Given the numerical value of T, we attempt to find values of
Consider
the equations given in (3.14). In the case of the PUMA 560 manipulator, the precise
statement of our current problem is as follows: Given
as sixteen numeric values
(four of which are trivial), solve (3.14) for the six joint angles through £96.
For the case of an arm with six degrees of freedom (like the one corresponding
to the equations in (3.14)), we have 12 equations and six unknowns. However,
among the 9 equations arising from the rotation-matrix portion of
only 3 are
independent. These, added to the 3 equations from the position-vector portion of
102
Chapter 4
6 equations with six unknowns. These equations are nonlinear, transcendental
equations, which can be quite difficult to solve. The equations of (3.14) are those of a
robot that had very simple link parameters—many of the were 0 or ±90 degrees.
Many link offsets and lengths were zero. It is easy to imagine that, for the case of a
general mechanism with six degrees of freedom (with all link parameters nonzero)
the kinematic equations would be much more complex than those of (3.14). As with
give
any nonlinear set of equations, we must concern ourselves with the existence of
solutions, with multiple solutions, and with the method of solution.
Existence of solutions
question of whether any solution exists at all raises the question of the
manipulator's workspace. Roughly speaking, workspace is that volume of space that
the end-effector of the manipulator can reach. For a solution to exist, the specified
goal point must lie within the workspace. Sometimes, it is useful to consider two
definitions of workspace: Dextrous workspace is that volume of space that the robot
end-effector can reach with all orientations. That is, at each point in the dextrous
workspace, the end-effector can be arbitrarily oriented. The reachable workspace is
that volume of space that the robot can reach in at least one orientation. Clearly,
the dextrous workspace is a subset of the reachable workspace.
Consider the workspace of the two-link manipulator in Fig. 4.1. If = 12, then
The dextrous workspace
the reachable workspace consists of a disc of radius
l2, then there is no dextrous
consists of only a single point, the origin. If
workspace, and the reachable workspace becomes a ring of outer radius + 12
and inner radius
— 121. Inside the reachable workspace there are two possible
orientations of the end-effector. On the boundaries of the workspace there is only
one possible orientation.
These considerations of workspace for the two-link manipulator have assumed
that all the joints can rotate 360 degrees. This is rarely true for actual mechanisms.
When joint limits are a subset of the full 360 degrees, then the workspace is obviously
correspondingly reduced, either in extent, or in the number of possible orientations
FIG U RE 4.1: Two-link manipulator with link lengths l1 and 12.
Section 4.2
Solvability
attainable. For example, if the arm in Fig. 4.1 has full 360-degree motion for 01, but
only 0 <02 <180°, then the reachable workspace has the same extent, but only one
orientation is attainable at each point.
When a manipulator has fewer than six degrees of freedom, it cannot attain
general goal positions and orientations in 3-space. Clearly, the planar manipulator
in Fig. 4.1 cannot reach out of the plane, so any goal point with a nonzero Zcoordinate value can be quickly rejected as unreachable. In many realistic situations,
manipulators with four or five degrees of freedom are employed that operate out
of a plane, but that clearly cannot reach general goals. Each such manipulator
must be studied to understand its workspace. In general, the workspace of such a
robot is a subset of a subspace that can be associated with any particular robot.
Given a general goal-frame specification, an interesting problem arises in connection
with manipulators having fewer than six degrees of freedom: What is the nearest
attainable goal frame?
Workspace also depends on the tool-frame transformation, because it is usually
the tool-tip that is discussed when we speak of reachable points in space. Generally,
the tool transformation is performed independently of the manipulator kinematics
and inverse kinematics, so we are often led to consider the workspace of the wrist
frame, {W}. For a given end-effector, a tool frame, {T}, is defined; given a goal frame,
{G}, the corresponding {W} frame is calculated, and then we ask: Does this desired
position and orientation of {W} lie in the workspace? In this way, the workspace
that we must concern ourselves with (in a computational sense) is different from the
one imagined by the user, who is concerned with the workspace of the end-effector
(the {T} frame).
If the desired position and orientation of the wrist frame is in the workspace,
then at least one solution exists.
Multiple solutions
Another possible problem encountered in solving kinematic equations is that of
multiple solutions. A planar arm with three revolute joints has a large dextrous
workspace in the plane (given "good" link lengths and large joint ranges), because
any position in the interior of its workspace can be reached with any orientation.
Figure 4.2 shows a three-link planar arm with its end-effector at a certain position
FIGURE 4.2: Three-link manipulator. Dashed lines indicate a second solution.
104
FIGURE 4.3: One of the two possible solutions to reach point B causes a collision.
and orientation. The dashed lines indicate a second possible configuration in which
the same end-effector position and orientation are achieved.
The fact that a manipulator has multiple solutions can cause problems, because
the system has to be able to choose one. The criteria upon which to base a decision
vary, but a very reasonable choice would be the closest solution. For example, if the
manipulator is at point A, as in Fig. 4.3, and we wish to move it to point B, a good
choice would be the solution that minimizes the amount that each joint is required
to move. Hence, in the absence of the obstacle, the upper dashed configuration in
Fig. 4.3 would be chosen. This suggests that one input argument to our kinematic
inverse procedure might be the present position of the manipulator. In this way,
if there is a choice, our algorithm can choose the solution closest in joint-space.
However, the notion of "close" might be defined in several ways. For example,
typical robots could have three large links followed by three smaller, orienting links
near the end-effector. In this case, weights might be applied in the calculation of
which solution is "closer" so that the selection favors moving smaller joints rather
than moving the large joints, when a choice exists. The presence of obstacles might
force a "farther" solution to be chosen in cases where the "closer" solution would
cause a collision—in general, then, we need to be able to calculate all the possible
solutions. Thus, in Fig. 4.3, the presence of the obstacle implies that the lower dashed
configuration is to be used to reach point B.
The number of solutions depends upon the number ofjoints in the manipulator
for a rotary joint
but is also a function of the link parameters (a1, a1, and
manipulator) and the allowable ranges of motion of the joints. For example, the
PUMA 560 can reach certain goals with eight different solutions. Figure 4.4 shows
four solutions; all place the hand with the same position and orientation. For each
solution pictured, there is another solution in which the last three joints "ifip" to an
alternate configuration according to the following formulas:
94 = 94 + 180
(4.1)
95 =
+ 1800.
So, in total, there can be eight solutions for a single goal. Because of limits on joint
ranges, some of these eight could be inaccessible.
FIGURE 4.4:
Four solutions of the PUMA 560.
In general, the more nonzero link parameters there are, the more ways there
wifi be to reach a certain goal. For example, consider a manipulator with six
rotational joints. Figure 4.5 shows how the maximum number of solutions is related
to how many of the link length parameters (the
are zero. The more that are
nonzero, the bigger is the maximum number of solutions. For a completely general
rotary-jointed manipulator with six degrees of freedom, there are up to sixteen
solutions possible [1, 6].
Method of solution
Unlike linear equations, there are no general algorithms that may be employed to
solve a set of nonlinear equations. In considering methods of solution, it wifi be wise
to define what constitutes the "solution" of a given manipulator.
A manipulator wifi be considered solvable if the joint variables can be
determined by an algorithm that allows one to determine all the sets of joint
variables associated with a given position and orientation [2].
106
Number of solutions
a1a3a5=O
a3=a50
a3=O
FIGURE 4.5: Number of solutions vs. nonzero a1.
The main point of this definition is that we require, in the case of multiple
solutions, that it be possible to calculate all solutions. Hence, we do not consider
some numerical iterative procedures as solving the manipulator—namely, those
methods not guaranteed to find all the solutions.
We wifi split all proposed manipulator solution strategies into two broad
classes: closed-form solutions and numerical solutions. Because of their iterative
nature, numerical solutions generally are much slower than the corresponding
closed-form solution; so much so, in fact, that, for most uses, we are not interested
in the numerical approach to solution of kinematics. Iterative numerical solution to
kinematic equations is a whole field of study in itself (see [6,11,12]) and is beyond
the scope of this text.
We wifi restrict our attention to closed-form solution methods. In this context,
"closed form" means a solution method based on analytic expressions or on the
solution of a polynomial of degree 4 or less, such that noniterative calculations suffice
to arrive at a solution. Within the class of closed-form solutions, we distinguish two
methods of obtaining the solution: algebraic and geometric. These distinctions are
somewhat hazy: Any geometric methods brought to bear are applied by means of
algebraic expressions, so the two methods are similar. The methods differ perhaps
in approach only.
A major recent result in kinematics is that, according to our definition of
solvability, all systems with revolute and prismatic joints having a total of six degrees
in a single series chain are solvable. However, this general solution is
a numerical one. Only in special cases can robots with six degrees of freedom be
solved analytically. These robots for which an analytic (or closed-form) solution
exists are characterized either by having several intersecting joint axes or by having
many equal to 0 or ±90 degrees. Calculating numerical solutions is generally time
consuming relative to evaluating analytic expressions; hence, it is considered very
important to design a manipulator so that a closed-form solution exists. Manipulator
designers discovered this very soon, and now virtually all industrial manipulators
are designed sufficiently simply that a closed-form solution can be developed.
A sufficient condition that a manipulator with six revolute joints have a closedform solution is that three neighboring joint axes intersect at a point. Section 4.6
discusses this condition. Almost every manipulator with six degrees of freedom built
today has three axes intersecting. For example, axes 4, 5, and 6 of the PUMA 560
intersect.
of freedom
Section 4.3
The notion of manipulator subspace when n < 6
THE NOTION OF MANIPULATOR SUBSPACE WHEN n <6
The set of reachable goal frames for a given manipulator constitutes its reachable
workspace. For a manipulator with n degrees of freedom (where ii < 6), this
reachable workspace can be thought of as a portion of an n-degree-of-freedom
subspace. In the same manner in which the workspace of a six-degree-of-freedom
manipulator is a subset of space, the workspace of a simpler manipulator is a subset
of its subspace. For example, the subspace of the two-link robot of Fig. 4.1 is a plane,
but the workspace is a subset of this plane, namely a circle of radius li + 12 for the
case that = 12.
One way to specify the subspace of an n-degree-of-freedom manipulator is to
give an expression for its wrist or tool frame as a function of n variables that locate it.
If we consider these n variables to be free, then, as they take on all possible values,
the subspace is generated.
EXAMPLE 4.1
Give a description of the subspace of
Chapter 3, Fig. 3.6.
The subsp ace of
for the three-link manipulator from
T is given by
0.0 0.0 1.0 0.0
where x and y give the position of the wrist and describes the orientation of the
terminal link. As x, y, and are allowed to take on arbitrary values, the subspace
is generated. Any wrist frame that does not have the structure of (4.2) lies outside
the subspace (and therefore lies outside the workspace) of this manipulator. Link
lengths and joint limits restrict the workspace of the manipulator to be a subset of
this subspace.
FIGURE 4.6: A polar two-link manipulator.
EXAMPLE 4.2
for the polar manipulator with two degrees
of freedom shown in Fig. 4.6. We have
(4.3)
where x and y can take any values. The orientation is restricted because the °22 axis
axis always points down,
must point in a direction that depends on x and y. The
and the 0X2 axis can be computed as the cross product
y, we have
x 022. In terms of x and
(4.4)
The subspace can therefore be given as
(4.5)
Usually, in defining a goal for a manipulator with n degrees of freedom, we
use n parameters to specify the goal. If, on the other hand, we give a specification of
a full six degrees of freedom, we wifi not in general be able to reach the goal with
an n < 6 manipulator. In this case, we might be interested instead in reaching a goal
that lies in the manipulator's subspace and is as "near" as possible to the original
desired goal.
Hence, when specifying general goals for a manipulator with fewer than six
degrees of freedom, one solution strategy is the following:
1. Given a general goal frame, T, compute a modified goal frame, T, such
as possible.
lies in the manipulator's subspace and is as "near" to
A definition of "near" must be chosen.
2. Compute the inverse kinematics to find joint angles using T as the desired
goal. Note that a solution stifi might not be possible if the goal point is not in
the manipulator's workspace.
It generally makes sense to position the tool-frame origin to the desired location
and then choose an attainable orientation that is near the desired orientation. As
we saw in Examples 4.1 and 4.2, computation of the subspace is dependent on
manipulator geometry. Each manipulator must be individually considered to arrive
at a method of making this computation.
Section 4.4
Algebraic vs. geometric
Section 4.7 gives an example of projecting a general goal into the subspace of a
manipulator with five degrees of freedom in order to compute joint angles that will
result in the manipulator's reaching the attainable frame nearest to the desired one.
As an introduction to solving kinematic equations, we will consider two different
approaches to the solution of a simple planar three-link manipulator.
Algebraic solution
the three-link planar manipulator introduced in Chapter 3. It is shown
with its link parameters in Fig. 4.7.
Following the method of Chapter 3, we can use the link parameters easily to
find the kinematic equations of this arm:
C123
—S123
S123
T — 0T
—3
0.0 11c1 + 12c12
0.0 11s1 + 12s12
FIGURE 4.7:
Three-link planar manipulator and its link parameters.
(4.6)
110
To focus our discussion on inverse kinematics, we wifi assume that the necessary
transformations have been performed so that the goal point is a specification of the
Because we are working with
wrist frame relative to the base frame, that is,
a planar manipulator, specification of these goal points can be accomplished most
easily by specifying three numbers: x, y, and where is the orientation of link 3
in the plane (relative to the +X axis). Hence, rather than giving a general T as a
goal specification, we wifi assume a transformation with the structure
5çb
All attainable goals must lie in the subspace implied by the structure of equation (4.7). By equating (4.6) and (4.7), we arrive at a set of four nonlinear equations
and 93:
that must be solved for
= c123,
(4.8)
Sc/, = s123,
(4.9)
x = 11c1
+ l7c12,
(4.10)
+ l2s12.
(4.11)
We now begin our algebraic solution of equations (4.8) through (4.11). If we
square both (4.10) and (4.11) and add them, we obtain
x2 + y2 = + + 2l1l2c2,
(4.12)
where we have made use of
(4.13)
= C157 + Sic2.
Solving (4.12) for c2, we obtain
x2 + y2
_12_ 12
(4.14)
21112
In order for a solution to exist, the right-hand side of (4.14) must have a value
between —1 and 1. In the solution algorithm, this constraint would be checked at
this time to find out whether a solution exists. Physically, if this constraint is not
satisfied, then the goal point is too far away for the manipulator to reach.
Assuming the goal is in the workspace, we write an expression for as
(4.15)
Finally, we compute
using the two-argument arctangent routine1:
= Atan2(s2,
1See Section 2.8.
c2).
(4.16)
Section 4.4
The choice of signs in (4.15) corresponds to the multiple solution in which we can
choose the "elbow-up" or the "elbow-down" solution. In determining we have
used one of the recurring methods for solving the type of kinematic relationships
that often arise, namely, to determine both the sine and cosine of the desired joint
angle and then apply the two-argument arctangent. This ensures that we have found
all solutions and that the solved angle is in the proper quadrant.
Having found
we can solve (4.10) and (4.11) for 01. We write (4.10) and
(4.11) in the form
x = k1c1 — k2s1,
(4.17)
(4.18)
k1s1 + k2c1,
= + 12c2,
= 12s2.
(4.19)
In order to solve an equation of this form, we perform a change of variables.
Actually, we are changing the way in which we write the constants k1 and k2.
(4.20)
y = Atan2(k2, k1),
k2=rsiny.
(4.21)
Equations (4.17) and (4.18) can now be written as
cosycos91 —sinysin01,
(4.22)
=cosysin91+sinycos01,
(4.23)
cos(y + Oi) =
(4.24)
(4.25)
sin(y +
Using
the two-argument arctangent, we get
= Atan2
= Atan2(y, x),
(4.26)
and so
01 = Atan2(y, x) — Atan2(k2, k1).
(4.27)
112
Note
that, when a choice of sign is made in the solution of
above, it
The substitutions used, (4.20)
wifi cause a sign change in k2, thus affecting
and (4.21), constitute a method of solution of a form appearing frequently in
kinematics—namely, that of (4.10) or (4.11). Note also that, if x = y = 0, then
(4.27) becomes undefined—in this case, is arbitrary.
Finally, from (4.8) and (4.9), we can solve for the sum of
through 93:
+ 93 = Atan2(s4, c4) =
(4.28)
From this, we can solve for 03, because we know the first two angles. It is typical
with manipulators that have two or more links moving in a plane that, in the course
of solution, expressions for sums of joint angles arise.
In summary, an algebraic approach to solving kinematic equations is basically
one of manipulating the given equations into a form for which a solution is known.
It turns out that, for many common geometries, several forms of transcendental
equations commonly arise. We have encountered a couple of them in this preceding
section. In Appendix C, more are listed.
Geometric solution
In a geometric approach to finding a manipulator's solution, we try to decompose
the spatial geometry of the arm into several plane-geometry problems. For many
manipulators (particularly when the
= 0 or ±90) this can be done quite easily.
Joint angles can then be solved for by using the tools of plane geometry [7]. For the
arm with three degrees of freedom shown in Fig. 4.7, because the arm is planar, we
can apply plane geometry directly to find a solution.
Figure 4.8 shows the triangle formed by 11, 12, and the line joining the origin of
frame {0} with the origin of frame {3}. The dashed lines represent the other possible
configuration of the triangle, which would lead to the same position of the frame
(3}. Considering the solid triangle, we can apply the "law of cosines" to solve for 92:
x2 +
— 21112
cos(180 +
FIGURE 4.8:
Plane geometry associated with a three-link planar robot.
(4.29)
Algebraic solution by reduction to polynomial
Section 4.5
Now; cos(180 +
— cos(92),
so we have
x2 + y2 _12_ 12
2111
(4.30)
In order for this triangle to exist, the distance to the goal point ,/x2 + y2 must be
less than or equal to the sum of the link lengths, 11 + 12. This condition would be
checked at this point in a computational algorithm to verify existence of solutions.
This condition is not satisfied when the goal point is out of reach of the manipulator.
Assuming a solution exists, this equation is solved for that value of
that lies
between 0 and —180 degrees, because only for these values does the triangle in
Fig. 4.8 exist. The other possible solution (the one indicated by the dashed-line
triangle) is found by symmetry to be =
To solve for
we find expressions for angles and as indicated in Fig. 4.8.
First, $ may be in any quadrant, depending on the signs of x and y. So we must use
a two-argument arctangent:
(4.31)
$ = Atan2(y, x).
We again apply the law of cosines to find
x2 + y2 + 12_
(4.32)
211\/x2 + y2
Here, the arccosine must be solved so that 0 < <180°, in order that the geometry
which leads to (4.32) will be preserved. These considerations are typical when using
a geometric approach—we must apply the formulas we derive only over a range of
variables such that the geometry is preserved. Then we have
= $±
(4.33)
where the plus sign is used if <0 and the minus sign if 02 > 0.
We know that angles in a plane add, so the sum of the three joint angles must
be the orientation of the last link:
(4.34)
01 + 02 + 03 =
This equation is solved for 03 to complete our solution.
Transcendental equations are often difficult to solve because, even when there is only
one variable (say, 9), it generally appears as sin 0 and cos 9. Making the following
substitutions, however, yields an expression in terms of a single variable, u:
u = tan
cos 0 =
sin0=
1 + u2
1+u2
(4.35)
This is a very important geometric substitution used often in solving kinematic
equations. These substitutions convert transcendental equations into polynomial
equations in u. Appendix A lists these and other trigonometric identities.
EXAMPLE 4.3
Convert the transcendental equation
acos8+bsin9 =c
(4.36)
into a polynomial in the tangent of the half angle, and solve for 0.
Substituting from (4.35) and multiplying through by 1 + u2, we have
a(1 — u2) +
2bu =
(437)
c(1 + u2).
Collecting powers of it yields
(a + c)u2
— 2bu
+ (c
= 0,
(4.38)
which is solved by the quadratic formula:
b±,1b2+a2_c2
(4.39)
=2tan1
a±c
(4.40)
the solution for u from (4.39) be complex, there is no real solution to
the original transcendental equation. Note that, if a + c = 0, the argument of the
arctangent becomes infinity and hence 0 = 180°. In a computer implementation,
this potential division by zero should be checked for ahead of time. This situation
results when the quadratic term of (4.38) vanishes, so that the quadratic degenerates
into a linear equation.
Polynomials up to degree four possess closed-form solutions [8, 9], so manipulators sufficiently simple that they can be solved by algebraic equations of this
degree (or lower) are called closed-form-solvable manipulators.
PIEPER'S SOLUTION WHEN THREE AXES INTERSECT
As mentioned earlier, although a completely general robot with six degrees of
freedom does not have a closed-form solution, certain important special cases
can be solved. Pieper [3, 4] studied manipulators with six degrees of freedom in
which three consecutive axes intersect at a point.2 In this section, we outline the
method he developed for the case of all six joints revolute, with the last three axes
intersecting. His method applies to other configurations, which include prismatic
2lncluded in this family of manipulators are those with three consecutive parallel axes, because they
meet at the point at infinity.
Pieper's solution when three axes intersect
Section 4.6
joints, and the interested reader should see [4]. Pieper's work applies to the majority
of commercially available industrial robots.
When the last three axes intersect, the origins of link frames (4), {5}, and {6}
are all located at this point of intersection. This point is given in base coordinates as
(4.41)
or, using the fourth colunm of (3.6) for i = 4, as
(4.42)
or as
fl (93)
(4.43)
—d4sa3
(4.44)
Using (3.6) for
in (4.44) yields the following expressions for f1:
= a3c3 + d4sa3s3 + a2,
f2 = a3ca2s3
d4sa3ca2c3
d3sa2,
(4.45)
+ d4ca2ca3 +
d4sa2ca3
in (4.43), we obtain
c1g1 — s1g2
s1g1+c1g2
40RG
g1 = c9f1
g3 =
s2f2
s2coi1f1
+ a1,
+ c2ca1f2 —
+ c2sa1f2 +
+ d2ca1.
d2sa1,
We now write an expression for the squared magnitude of
denote as r = x2 + y2 + z2, and which is seen from (4.46) to be
(4.47)
which we wifi
(4.48)
Chapter 4
using (4.47) for the
we have
+ 2d2f3 + 2a1(c2f1 — s2f2).
(4.49)
We now write this equation, along with the Z-component equation from (4.46), as a
system of two equations in the form
r = (kjc2 + k2s2)2a1 + k3,
(k1s2
k2c2)sa1 + k4,
(4.50)
k1 =
—f2,
(4.51)
Equation (4.50) is useful because dependence on has been eliminated and because
dependence on takes a simple form.
Now let us consider the solution of (4.50) for 03. We distinguish three cases:
If = 0, then we have r = k3, where r is known. The right-hand side (k3) is a
function of 03 only. After the substitution (4.35), a quadratic equation in tan
may be solved for 03.
2. If sa1 = 0, then we have z = k4, where z is known. Again, after substituting
via (4.35), a quadratic equation arises that can be solved for 03.
3. Otherwise, eliminate s2 and c2 from (4.50) to obtain
(4.52)
sci1
This equation, after the (4.35) substitution for 03, results in an equation of
degree 4, which can be solved for
Having solved for
we can solve (4.50) for 02 and (4.46) for
To complete our solution, we need to solve for 04, 05, and
These axes
intersect, so these joint angles affect the orientation of only the last link. We can
compute them from nothing more than the rotation portion of the specified goal,
Having obtained
02, and 03, we can compute
by which notation we
mean the orientation of link frame {4} relative to the base frame when 04 = 0. The
desired orientation of {6} differs from this orientation only by the action of the last
three joints. Because the problem was specified as given
we can compute
31t is helpful to note that
60R.
(4.53)
+ 2d4d3ccs3 + 2a2a3c3 + 2a2d4sa3s3.
Examples of inverse manipulator kinematics
Section 4.7
For many manipulators, these last three angles can be solved for by using
exactly the Z—Y—Z Euler angle solution given in Chapter 2, applied to
194=0
For any manipulator (with intersecting axes 4, 5, and 6), the last three joint angles
can be solved for as a set of appropriately defined Euler angles. There are always
two solutions for these last three joints, so the total number of solutions for the
manipulator will be twice the number found for the first three joints.
EXAMPLES OF INVERSE MANIPULATOR KINEMATICS
In this section, we work out the inverse kinematics of two industrial robots. One
manipulator solution is done purely algebraically; the second solution is partially
algebraic and partially geometric. The following solutions do not constitute a
cookbook method of solving manipulator kinematics, but they do show many of
the common manipulations likely to appear in most kinematic solutions. Note that
Pieper's method of solution (covered in the preceding section) can be used for these
manipulators, but here we choose to approach the solution a different way, to give
insight into various available methods.
The Unimation PUMA 560
As an example of the algebraic solution technique applied to a manipulator with six
degrees of freedom, we will solve the kinematic equations of the PUMA 560, which
were developed in Chapter 3. This solution is in the style of [5].
We wish to solve
r11 r17 r13
(4.54)
is given as numeric values.
A restatement of (4.54) that puts the dependence on
of the equation is
on the left-hand side
Inverting
we write (4.55) as
s1 0 0
—S1
C1 0 0
0 10
(4.55)
r21 r22
r31 r32 r33
(4 56
is given by equation (3.13) developed in Chapter 3. This simple technique
of multiplying each side of a transform equation by an inverse is often used to
advantage in separating out variables in the search for a solvable equation.
Equating the (2, 4) elements from both sides of (4.56), we have
(4.57)
118
To solve an equation of this form, we make the trigonometric substitutions
=psinq5,
(4.58)
(4.59)
Substituting (4.58) into (4.57), we obtain
ClScb — S1C4 — —.
From the difference-of-angles formula,
(4.61)
= ±\/1
(4.62)
(4.63)
Finally, the solution for
may be written as
Atan2 (d3, ±,,/p2 +
(4.64)
Note that we have found two possible solutions for
corresponding to the plusor-minus sign in (4.64). Now that is known, the left-hand side of (4.56) is known.
If we equate both the (1,4) elements and the (3,4) elements from the two sides of
(4.56), we obtain
= ci3c23 — d4s23 + a2c2,
= a3s23
(4.65)
+ d4c,3 + a2s2.
If we square equations (4.65) and (4.57) and add the resulting equations, we obtain
a3c3 — d4s3
(4.66)
(4.67)
Note that dependence on
has been removed from (4.66). Equation (4.66) is of
the same form as (4.57) and so can be solved by the same kind of trigonometric
substitution to yield a solution for 93:
93 = Atan2(a3, d4) — Atan2(K,
K2).
(4.68)
The plus-or-minus sign in (4.68) leads to two different solutions for 03. If we consider
(4.54) again, we can now rewrite it so that all the left-hand side is a function of only
knowns and 92:
(4.69)
C1C23
—a7c3
S1C23
—d3
a2s3
C1S23
S1S23
—s1
(4.70)
is given by equation (3.11) developed in Chapter 3. Equating both
the (1,4) elements and the (2,4) elements from the two sides of (4.70), we get
— C23p
+ a2s3 =
a2c3
(4.71)
These equations can be solved simultaneously for s23 and c23, resulting in
(—a3 —
(a2s3
+ s1p3,) (a2s3
+ a2c3)
The denominators are equal and positive, so we solve for the sum of
= Atan2[(—a3
a2c3)p
(4.72)
a2s3),
and 93
(4.73)
Equation (4.73) computes four values of 023, according to the four possible combinations of solutions for and 93, then, four possible solutions for are computed as
(4.74)
— 03,
where the appropriate solution for 93 is used when forming the difference.
Now the entire left side of (4.70) is known. Equating both the (1,3) elements
and the (3,3) elements from the two sides of (4.70), we get
r13 C1 C23 + r23s1c23 — r33s23
—r13s1 + r23c1
As long as
= —c4s5,
= s4s5.
(4.75)
0, we can solve for 94 as
= Atan2(—r13s1 + r23c1, —r13c1c23 —
r23s1c23
+ r33s73).
(4.76)
= 0, the manipulator is in a singular configuration in which joint axes 4 and
and cause the same motion of the last link of the robot. In this case, all that
matters (and all that can be solved for) is the sum or difference of 84 and This
situation is detected by checking whether both arguments of the Atan2 in (4.76) are
near zero. If sO, 84 is chosen arbitrarily,4 and when is computed later, it will be
computed accordingly.
If we consider (4.54) again, we can now rewrite it so that all the left-hand side
is a function of only knowns and 94, by rewriting it as
When 85
6 line up
(4.77)
is given by
c1c23c4+s1s4 S1C23C4C1S4
—c1c23s4 + s1c4 —s1c23s4 — c1c4
S23C4 —a2c3c4+d3s4—a3c4
s23s4
a2c3s4 + d3c4 + a3s4
—c1s23
—s1s23
—C23
(4 78)
— d4
is given by equation (3.10) developed in Chapter 3. Equating both the (1,3)
elements and the (3,3) elements from the two sides of (4.77), we get
r13(c1c23c4 + s1s4) + r23(s1c73c4 — c1s4) — r33(s93c4) = —s5,
r13(c1s23) + r23(—s1s23) + r33(—c23) = c5.
(4.79)
Hence, we can solve for 05 as
95 = Atan2(s5, c5),
(4.80)
where s5 and c5 are given by (4.79).
Applying the same method one more time, we compute
and write
(4.54) in the form
(4.81)
Equating both the (3,1) elements and the (1,1) elements from the two sides of (4.77)
as we have done before, we get
= Atan2(s6, c6),
(4.82)
s6 = —r11(c1c23s4 — s1c4)
c6 =
r21(s1c23s4 + c1c4) + r31(s23s4),
+ s1s4)c5 — c1s73s5] + r21[(s1c73c4 — c1s4)c5
s1s23s5]
—r31(s23c4c5 + c23s5).
of the plus-or-minus signs appearing in (4.64) and (4.68), these equations
compute four solutions. Additionally, there are four more solutions obtained by
41t is usually chosen to be equal to the present value of joint 4.
Section 4.7
Examples of inverse manipulator kinematics
"ifipping" the wrist of the manipulator. For each of the four solutions computed
above, we obtain the ifipped solution by
94 = 94
+ 180°,
(4.83)
After all eight solutions have been computed, some (or even all) of them might have
to be discarded because of joint-limit violations. Of any remaining valid solutions,
usually the one closest to the present manipulator configuration is chosen.
The Yasukawa Motomart L-3
As the second example, we will solve the kinematic equations of the Yasukawa
Motoman L-3, which were developed in Chapter 3. This solution wifi be partially
algebraic and partially geometric. The Motoman L-3 has three features that make
the inverse kinematic problem quite different from that of the PUMA. First, the
manipulator has only five joints, so it is not able to position and orient its endeffector in order to attain general goal frames. Second, the four-bar type of linkages
and chain-drive scheme cause one actuator to move two or more joints. Third, the
actuator position limits are not constants, but depend on the positions of the other
actuators, so finding out whether a computed set of actuator values is in range is not
trivial.
If we consider the nature of the subspace of the Motoman manipulator (and
the same applies to many manipulators with five degrees of freedom), we quickly
realize that this subspace can be described by giving one constraint on the attainable
orientation: The pointing direction of the tool, that is, the ZT axis, must lie in the
"plane of the arm." This plane is the vertical plane that contains the axis of joint
1 and the point where axes 4 and 5 intersect. The orientation nearest to a general
orientation is the one obtained by rotating the tool's pointing direction so that it lies
in the plane, using a minimum amount of rotation. Without developing an explicit
expression for this subspace, we will construct a method for projecting a general
goal frame into it. Note that this entire discussion is for the case that the wrist frame
and tool frame differ only by a translation along
In Fig. 4.9, we indicate the plane of the arm by its normal, M, and the desired
pointing direction of the tool by ZT. This pointing direction must be rotated by
angle 0 about some vector K in order to cause the new pointing direction, Z,, to lie
in the plane. It is clear that the ft that minimizes 9 lies in the plane and is orthogonal
to both ZT and
For any given goal frame, M is defined as
(4.84)
are the X and Y coordinates of the desired tool position. Then K
(4.85)
122
FIGURE 4.9:
The new
Rotating a goal frame into the Motoman's subspace.
(4.86)
The amount of rotation, 9, is given by
sin8 = (2T x
(4.87)
Using Rodriques's formula (see Exercise 2.20), we have
(4.88)
Finally, we compute the remaining unknown column of the new rotation matrix of
the tool as
(4.89)
Equations (4.84) through (4.89) describe a method of projecting a given general goal
orientation into the subspace of the Motoman robot.
Assuming that the given wrist frame,
lies in the manipulator's subspace,
we solve the kinematic equations as follows. In deriving the kinematic equations for
the Motoman L-3, we formed the product of link transformations:
Ifwelet
(4.90)
0T =
and premultiply both sides by
(4.91)
(4.92)
where the left-hand side is
c1r11 + s1r21
c1r12
+ s1r22
c1r13
+ s1r23
—r33
—s1r11 + c1r21 —s1r12 + c1r27 —s1r13 + c1r23
(4 93
and the right-hand side is
S234
C234 *
s5 c5
(494)
in the latter, several of the elements have not been shown. Equating the (3,4)
elements, we get
(4.95)
(4.96)
which gives us5
Equating the (3,1) and (3,2) elements, we get
55 =
from which we calculate
+ c1r21,
—s1r11
(4.97)
+ c1r22,
05 = Atan2(r21c1
r11s1, r22c1 — r12s1).
(4.98)
Equating the (2,3) and (1,3) elements, we get
C234 =
= c1r13
+ s1r23,
(4.99)
which leads to
°234 = Atan2(r13c1 + r23s1, r33).
(4.100)
To solve for the individual angles
03, and 94, we will take a geometric approach.
Figure 4.10 shows the plane of the arm with point A at joint axis 2, point B at joint
axis 3, and point C at joint axis 4.
From the law of cosines applied to triangle ABC, we have
93 =
(4.101)
21213
Next, we have6
93 = Atan2
(i/i — cos2O3, cos03).
5For this manipulator, a second solution would violate joint limits and so is not calculated.
6For this manipulator, a second solution would violate joint limits and so is not calculated.
(4.102)
FIGURE 4.10: The plane
From Fig. 4.10, we see that
— fi, or
+ p2)
= —Atan2
of the Motoman manipulator.
Atan2(13 Sffl93, 12 + 13 COS 93).
(4.103)
Finally, we have
04 =
(4.104)
Having solved for joint angles, we must perform the further computation to obtain
the actuator values. Referring to Section 3.7, we solve equation (3.16) for the A1:
cos (92
cos (92 +03
A5 =
+ 2700) +
+ 900) +
tan1
— 93 — 94),
— 95).
(4.105)
The actuators have limited ranges of motion, so we must check that our computed
solution is in range. This "in range" check is complicated by the fact that the
mechanical arrangement makes actuators interact and affect each other's allowed
range of motion. For the Motoman robot, actuators 2 and 3 interact in such a way
that the following relationship must always be obeyed:
A2 — 10,
000 > A3 >
+ 3000.
(4.106)
Section 4.8
The standard frames
That is, the limits of actuator 3 are a function of the position of actuator 2. Similarly,
32,000 — A4
<A5 <55,000.
(4.107)
Now, one revolution of joint 5 corresponds to 25,600 actuator counts, so, when
A4 > 2600, there are two possible solutions for A5. This is the only situation in which
the Yasukawa Motoman L-3 has more than one solution.
THE STANDARD FRAMES
The ability to solve for joint angles is really the central element in many robot
control systems. Again, consider the paradigm indicated in Fig. 4.11, which shows
the standard frames.
The way these frames are used in a general robot system is as follows:
1. The user specifies to the system where the station frame is to be located. This
might be at the corner of a work surface, as in Fig. 4.12, or even affixed to a
moving conveyor belt. The station frame, (SI, is defined relative to the base
frame, {B}.
2. The user specifies the description of the tool being used by the robot by giving
the {T}-frame specification. Each tool the robot picks up could have a different
{T} frame associated with it. Note that the same tool grasped in different ways
requires different {T}-frame definitions. {T} is specified relative to {W}—that
3. The user specifies the goal point for a robot motion by giving the description
of the goal frame, {G}, relative to the station frame. Often, the definitions of
{T} and {S} remain fixed for several motions of the robot. In this case, once
they are defined, the user simply gives a series of {G} specifications.
FIGURE 4.11: Location of the "standard" frames.
126
FIG U RE 4.12:
Example workstation.
In many systems, the tool frame definition (VT) is constant (for example, it is
defined with its origin at the center of the fingertips). Also, the station frame
might be fixed or might easily be taught by the user with the robot itself. In
such systems, the user need not be aware of the five standard frames—he or
she simpiy thinks in terms of moving the tool to locations (goals) with respect
to the work area specified by station frame.
4. The robot system calculates a series of joint angles to move the joints through
in order that the tool frame wifi move from its initial location in a smooth
manner until {T} = {G} at the end of motion.
SOLVE-ING A MANIPULATOR
The SOLVE function implements Cartesian transformations and calls the inverse
kinematics function. Thus, the inverse kinematics are generalized so that arbitrary tool-frame and station-frame definitions may be used with our basic inverse
kinematics, which solves for the wrist frame relative to the base frame.
Given the goal-frame specification,
SOLVE uses the tool and station
definitions to calculate the location of {W} relative to {B},
Then, the inverse kinematics take
(4.108)
as an input and calculate
Section 4.11
4.10
REPEATABILITY AND ACCURACY
Many industrial robots today move to goal points that have been taught. A taught
point is one that the manipulator is moved to physically, and then the joint position
sensors are read and the joint angles stored. When the robot is commanded to
return to that point in space, each joint is moved to the stored value. In simple
"teach and playback" manipulators such as these, the inverse kinematic problem
never arises, because goal points are never specified in Cartesian coordinates. When
a manufacturer specifies how precisely a manipulator can return to a taught point,
he is specifying the repeatability of the manipulator.
Any time a goal position and orientation are specified in Cartesian terms,
the inverse kinematics of the device must be computed in order to solve for the
required joint angles. Systems that allow goals to be described in Cartesian terms
are capable of moving the manipulator to points that were never taught—points in
its workspace to which it has perhaps never gone before. We will call such points
computed points. Such a capability is necessary for many manipulation tasks. For
example, if a computer vision system is used to locate a part that the robot must
grasp, the robot must be able to move to the Cartesian coordinates supplied by the
vision sensor. The precision with which a computed point can be attained is called
the accuracy of the manipulator.
The accuracy of a manipulator is bounded by the repeatability. Clearly,
accuracy is affected by the precision of parameters appearing in the kinematic
equations of the robot. Errors in knowledge of the Denavit—Hartenberg parameters
will cause the inverse kinematic equations to calculate joint angle values that are
in error. Hence, although the repeatability of most industrial manipulators is quite
good, the accuracy is usually much worse and varies quite a bit from manipulator
to manipulator. Calibration techniques can be devised that allow the accuracy of
a manipulator to be improved through estimation of that particular manipulator's
kinematic parameters [10].
4.11
In many path-control schemes, which we will consider in Chapter 7, it is necessary
to calculate the inverse kinematics of a manipulator at fairly high rates, for example, 30 Hz or faster. Therefore, computational efficiency is an issue. These speed
requirements rule out the use of numerical-solution techniques that are iterative in
nature; for this reason, we have not considered them.
Most of the general comments of Section 3.10, made for forward kinematics,
also hold for the problem of inverse kinematics. For the inverse-kinematic case, a
table-lookup Atan2 routine is often used to attain higher speeds.
Structure of the computation of multiple solutions is also important. It is
generally fairly efficient to generate all of them in parallel, rather than pursuing one
after another serially. Of course, in some applications, when all solutions are not
required, substantial time is saved by computing only one.
When a geometric approach is used to develop an inverse-kinematic solution,
it is sometimes possible to calculate multiple solutions by simple operations on the
various angles solved for in obtaining the first solution. That is, the first solution
128
moderately expensive computationally, but the other solutions are found very
quickly by summing and differencing angles, subtracting jr, and so on.
[1] B. Roth, J. Rastegar, and V. Scheinman, "On the Design of Computer Controlled
Manipulators," On the Theory and Practice of Robots and Manipulators, Vol. 1, First
CISM-IFToMM Symposium, September 1973, pp. 93—113.
[2] B. Roth, "Performance Evaluation of Manipulators from a Kinematic Viewpoint," Performance Evaluation of Manipulators, National Bureau of Standards, special publication,
1975.
[3] D. Pieper and B. Roth, "The Kinematics of Manipulators Under Computer Control,"
Proceedings of the Second International Congress on Theory of Machines and Mechanisms,
Vol. 2, Zakopane, Poland, 1969, pp. 159—169.
[4] D. Pieper, "The Kinematics of Manipulators Under Computer Control," Unpublished
Ph.D. Thesis, Stanford University, 1968.
[5] R.P. Paul, B. Shimano, and G. Mayer, "Kinematic Control Equations for Simple Manipulators," IEEE Transactions on Systems, Man, and Cybernetics, Vol. SMC-11, No. 6,
[6] L. Tsai and A. Morgan, "Solving the Kinematics of the Most General Six- and Fivedegree-of-freedom Manipulators by Continuation Methods," Paper 84-DET-20, ASME
Mechanisms Conference, Boston, October 7—10, 1984.
[7] C.S.G. Lee and M. Ziegler, "Geometric Approach in Solving Inverse Kinematics of
PUMA Robots," IEEE Transactions on Aerospace and Electronic Systems, Vol. AES-20,
No. 6, November 1984.
[8] W. Beyer, CRC Standard Mathematical Tables, 25th edition, CRC Press, Inc., Boca
Raton, FL, 1980.
[9] R. Burington, Handbook of Mathematical Tables and Formulas, 5th edition, McGrawHill, New York, 1973.
[10] J. Hollerbach, "A Survey of Kinematic Calibration," in The Robotics Review, 0. Khatib,
J. Craig, and T. Lozano-Perez, Editors, MIT Press, Cambridge, MA, 1989.
[II] Y. Nakamura and H. Hanafusa, "Inverse Kinematic Solutions with Singularity Robustness for Robot Manipulator Control," ASME Journal of Dynamic Systems, Measurement,
and Control, Vol. 108, 1986.
[12] D. Baker and C. Wampler, "On the Inverse Kinematics of Redundant Manipulators,"
International Journal of Robotics Research, Vol. 7, No. 2, 1988.
[13] L.W. Tsai, Robot Analysis: The Mechanics of Serial and Parallel Manipulators, Wiley,
4.1 [15] Sketch the fingertip workspace of the three-link manipulator of Chapter 3,
Exercise 3.3 for the case = 15.0, 12 = 10.0, and 13 = 3.0.
4.2 [26] Derive the inverse kinematics of the three-link manipulator of Chapter 3,
Exercise 3.3.
4.3 [12] Sketch the fingertip workspace of the 3-DOF manipulator of Chapter 3,
Example 3.4.
4.4 [24] Derive the inverse kinematics of the 3-DOF manipulator of Chapter 3,
4.5 [38] Write a Pascal (or C) subroutine that computes all possible solutions for the
PUMA 560 manipulator that lie within the following joint limits:
—170.0
<170.0,
—225.0
<45.0,
—250.0 <63 <75.0,
—135.0 <64 <135.0,
—100.0 <95 <100.0,
—180.0 <°6 <180.0.
Use the equations derived in Section 4.7 with these numerical values (in inches):
£13
17.0,
= 0.8,
d3 = 4.9,
d4 = 17.0.
4.6 [15] Describe a simple algorithm for choosing the nearest solution from a set of
possible solutions.
4.7 [10] Make a list of factors that might affect the repeatability of a manipulator.
Make a second list of additional factors that affect the accuracy of a manipulator.
4.8 [12] Given a desired position and orientation of the hand of a three-link planar
rotary-jointed manipulator, there are two possible solutions. If we add one more
rotational joint (in such a way that the arm is still planar), how many solutions
are there?
4.9 [26] Figure 4.13 shows a two-link planar arm with rotary joints. For this arm, the
second link is half as long as the first—that is, ii = 212. The joint range limits in
FIGURE 4.13:
Two-link planar manipulator.
130
degrees are
<180,
—90
<180.
Sketch the approximate reachable workspace (an area) of the tip of link 2.
4.10 [23] Give an expression for the subspace of the manipulator of Chapter
4.11 [24] A 2-DOF positioning table is used to orient parts for arc-welding. The
forward kinematics that locate the bed of the table (link 2) with respect to the
base (link 0) are
OT_I
c1c2
—c1s2 s1 12s1 +
s1s2
c1 12c1 + h1
Given any unit direction fixed in the frame of the bed (link 2),
give the
inverse-kinematic solution for
02 such that this vector is aligned with 02 (i.e.,
upward). Are there multiple solutions? Is there a singular condition for which a
unique solution cannot be obtained?
4.12 [22] In Fig. 4.14, two 3R mechanisms are pictured. In both cases, the three axes
intersect at a point (and, over all configurations, this point remains fixed in space).
The mechanism in Fig. 4.14(a) has link twists (as) of magnitude 90 degrees. The
mechanism in Fig. 4.14(b) has one twist of in magnitude and the other of 180—
in magnitude.
The mechanism in Fig. 4.14(a) can be seen to be in correspondence with Z—Y—Z
Euler angles, and therefore we know that it suffices to orient link 3 (with arrow
in figure) arbitrarily with respect to the
link 0. Because 0 is not equal to 90
degrees, it turns out that the other mechanism cannot orient link 3 arbitrarily.
FIGURE 4.14: Two 3R mechanisms (Exercise 4.12).
zo,1
xo,1
FIGURE 4.15: A 4R
manipulator shown in the position e = [0,900, —90°, 01T (Exer-
cise 4.16).
Describe the set of orientations that are unattainable with the second mechanism.
Note that we assume that all joints can turn 360 degrees (i.e. no limits) and we
assume that the links may pass through each other if need be (i.e., workspace not
limited by self-coffisions).
4.13 [13] Name two reasons for which closed-form analytic kinematic solutions are
preferred over iterative solutions.
4.14 [14] There exist 6-DOF robots for which the kinematics are NOT closed-form
solvable. Does there exist any 3-DOF robot for which the (position) kinematics
are NOT closed-form solvable?
4.15 [38] Write a subroutine that solves quartic equations in closed form. (See [8, 9].)
4.16 [25] A 4R manipulator is shown schematically in Fig. 4.15. The nonzero link
parameters are a1 = 1, a2 = 45°, d3 =
and a3 =
and the mechanism is
pictured in the configuration corresponding to e = [0,90°, —90°, 0]T. Each joint
has ±180° as limits. Find all values of 83 such that
[1.1, 1.5,
4.17 [25] A 4R manipulator is shown schematically in Fig. 4.16. The nonzero link
—90°, d2 = 1, a2 = 45°, d3 = 1, and a3 = 1, and the
mechanism is pictured in the configuration corresponding to 0 = [0, 0, 90°, 0]T.
Each joint has ±180° as limits. Find all values of 83 such that
parameters are a1 =
[0.0, 1.0, 1414]T
4.18 [15] Consider the RRP manipulator shown in Fig. 3.37. How many solutions do
the (position) kinematic equations possess?
4.19 [15] Consider the RRR manipulator shown in Fig. 3.38. How many solutions do
4.20 [15] Consider the R PP manipulator shown in Fig. 3.39. How many solutions do
yo,1
FIGURE 4.16: A 4R manipulator shown in the position 0 = [0,0, 900, 0]T (Exercise 4.17).
[15] Consider the PRR manipulator shown in Fig. 3.40. How many solutions do
4.22 [15] Consider the PPP manipulator shown in Fig. 3.41. How many solutions do
4.23 [38] The following kinematic equations arise in a certain problem:
4.21
sine —asin9+b,
Given a, b, c, d, and i/i, show that, in the general case, there are four solutions for
6. Give a special condition under which there are just two solutions for 9.
4.24 [20] Given the description of link frame {i} in terms of link frame {i — 1), find the
four Denavit—Hartenberg parameters as functions of the elements of Y'T.
PROGRAMMING EXERCISE (PART 4)
Write a subroutine to calculate the inverse kinematics for the three-link manipulator of Section 4.4. The routine should pass arguments in the form
INVKIN(VAR wreib: frame; VAR current, near, far:
VAR sol: boolean);
vec3;
"wreib," an input, is the wrist frame specified relative to the base frame;
"current," an input, is the current position of the robot (given as a vector of joint
angles); "near" is the nearest solution; "far" is the second solution; and "sol" is
a flag that indicates whether solutions were found. (sol = FALSE if no solutions
were found). The link lengths (meters) are
11 =
0.5.
MATLAB Exercise 4
The joint ranges of motion are
—170°
170°.
Test your routine by calling it back-to-back with KIN to demonstrate that they are
indeed inverses of one another.
2. A tool is attached to link 3 of the manipulator. This tool is described by
tool frame relative to the wrist frame. Also, a user has described his work area, the
station frame relative to the base of the robot, as T. Write the subroutine
SOLVE(VAR -brels: frame; VAR current, near, far:
{T} frame specified relative to the {S} frame. Other parameters
INVKIN subroutine. The defmitions of {T} and {S} should be
defined variables or constants. SOLVE should use calls to TMULT, TINVERT,
where "trels" is the
exactly as in the
globally
and INVKIN.
3. Write a
main program that accepts a goal frame specified in terms of x,
This goal specification is (T} relative to {S}, which is the way the user wants to
specify goals.
The robot is using the same tool in the same working area as in Programming
Exercise (Part 2), so {T} and {S} are defined as
= [x y 9] = [0.1 0.2 30.0],
= [x y 8] = [—0.1 0.3 0.0].
Calculate the joint angles for each of the following three goal frames:
= [0.0 0.0 —
[x1 Yi
90.0],
Er7 Y2 02] = [0.6 —0.3 45.0],
[x3 Y3 03] = [—0.4 0.3 120.0],
04] = [0.8 1.4 30.0].
Assume that the robot wifi start with all angles equal to 0.0 and move to these
three goals in sequence. The program should find the nearest solution with respect
to the previous goal point. You should call SOLVE and WHERE back-to-back to make
sure they are truly inverse functions.
MATLAB EXERCISE 4
This exercise focuses on the inverse-pose kinematics solution for the planar 3-DOF,
3R robot. (See Figures 3.6 and 3.7; the DH parameters are given in Figure
fixed-length parameters are given: L1 = 4, L2 = 3, and L3 = 2(m).
3.8.) The
following
a) Analytically derive, by
T, calculate
hand, the inverse-pose solution for this robot: Given
all possible multiple solutions
presented in the text—choose one of these.) Hint:
calculate
83 }.
(Three methods are
simplify the equations, first
and L3.
b) Develop a MATLAB program to solve this planar 3R robot inverse-pose kinematics problem completely (i.e., to give all multiple
using
the following input cases:
solutions). Test your program,
134
1009
0100
0010
—0.866 0 7.5373
0 3.9266
0 1 0 —3
—100
I1I)HT_
rO.866
0 —3.1245
9.1674
—0.5 0.866 0
For all cases, employ a circular check to validate your results: Plug each resulting
set of joint angles (for each of the multiple solutions) back into the forwardpose kinematics MATLAB program to demonstrate that you get the originally
commanded
c) Check all results by means of the Corke MATLAB Robotics Toolbox. Try function
ikineQ.
Jacobians: velocities
and static forces
NOTATION FOR TIME-VARYING POSITION AND ORIENTATION
LINEAR AND ROTATIONAL VELOCITY OF RIGID BODIES
MORE ON ANGULAR VELOCITY
MOTION OF THE LINKS OF A ROBOT
VELOCITY "PROPAGATION" FROM LINK TO LINK
JACOBIANS
SINGULARITIES
STATIC FORCES IN MANIPULATORS
5.10 JACOBIANS IN THE FORCE DOMAIN
5.11 CARTESIAN TRANSFORMATION OF VELOCITIES AND STATIC FORCES
In this chapter, we expand our consideration of robot manipulators beyond staticpositioning problems. We examine the notions of linear and angular velocity of a
rigid body and use these concepts to analyze the motion of a manipulator. We also
will consider forces acting on a rigid body, and then use these ideas to study the
application of static forces with manipulators.
It turns out that the study of both velocities and static forces leads to a matrix
entity called the Jacobian1 of the manipulator, which will be introduced in this
chapter.
The field of kinematics of mechanisms is not treated in great depth here.
For the most part, the presentation is restricted to only those ideas which are
fundamental to the particular problem of robotics. The interested reader is urged to
study further from any of several texts on mechanics [1—3].
Before investigating the description of the motion of a rigid body, we briefly discuss
some basics: the differentiation of vectors, the representation of angular velocity,
and notation.
1Mathematicians call it the "Jacobian matrix," but roboticists usually shorten it to simply "Jacobian."
136
Chapter 5
Differentiation of position vectors
As a basis for our consideration of velocities (and, in Chapter 6, accelerations), we
need the following notation for the derivative of a vector:
At-÷O
velocity of a position vector can be thought of as the linear velocity of the
point in space represented by the position vector. From (5.1), we see that we are
calculating the derivative of Q relative to frame {B}. For example, if Q is not
changing in time relative to {B}, then the velocity calculated is zero—even if there
is some other frame in which Q is varying. Thus, it is important to indicate the frame
in which the vector is differentiated.
As with any vector, a velocity vector can be described in terms of any frame,
and this frame of reference is noted with a leading superscript. Hence, the velocity
vector calculated by (5.1), when expressed in terms of frame {A}, would be written
A(BV)_AdBQ
(5.2)
we see that, in the general case, a velocity vector is associated with a point in
space, but the numerical values describing the velocity of that point depend on two
frames: one with respect to which the differentiation was done, and one in which the
resulting velocity vector is expressed.
In (5.1), the calculated velocity is written in terms of the frame of differentiation, so the result could be indicated with a leading B superscript, but, for simplicity,
when both superscripts are the same, we needn't indicate the outer one; that is, we
write
B(BV)BV
(5.3)
Finally, we can always remove the outer, leading superscript by explicitly includ-
ing the rotation matrix that accomplishes the change in reference frame (see
Section 2.10); that is, we write
A(BV)ARBV
(5.4)
We will usually write expressions in the form of the right-hand side of (5.4) so that
the symbols representing velocities wifi always mean the velocity in the frame of
differentiation and wifi not have outer, leading superscripts.
Rather than considering a general point's velocity relative to an arbitrary
frame, we wifi very often consider the velocity of the origin of a frame relative
to some understood universe reference frame. For this special case, we define a
shorthand notation,
where the point in question is the origin of frame {C} and the reference frame is
(U). For example, we can use the notation
to refer to the velocity of the origin
of frame {C}; then AUC is the velocity of the origin of frame {C} expressed in terms
of frame {AJ (though differentiation was done relative to fU}).
Section 5.2
Notation for time-varying position and orientation
FIGURE 5.1:
Example of some frames in linear motion.
EXAMPLE 5.1
Figure 5.1 shows a fixed universe frame, {U}, a frame attached to a train traveling at
100 mph, {T}, and a frame attached to a car traveling at 30 mph, {C}. Both vehicles
are heading in the X direction of {U}. The rotation matrices,
and constant.
What is
are known
vYllaLls C,Uu'
C(UVTORG) = Cv
vvuatls CiT11
=g R(lOOk) = gR—'
C,T1,
— UD—1U
"CORGc1t
The angular velocity vector
We now introduce an angular velocity vector, using the symbol Whereas linear
velocity describes an attribute of a point, angular velocity describes an attribute of
a body. We always attach a frame to the bodies we consider, so we can also think of
angular velocity as describing rotational motion of a frame.
In Fig. 5.2, AcB describes the rotation of frame (B} relative to {A}. Physically,
at any instant, the direction of A
indicates the instantaneous axis of rotation of
{B} relative to {A}, and the magnitude of Ac2B indicates the speed of rotation. Again,
like any vector, an angular velocity vector may be expressed in any coordinate
system, and so another leading superscript may be added; for example, C(Ac2B) is
the angular velocity of frame {B} relative to {A} expressed in terms of frame {C}.
138
5.2: Frame {B} is rotating with angular velocity AQB relative to frame [A).
Again, we introduce a simplified notation for an important special case. This
is simply the case in which there is an understood reference frame, so that it need
not be mentioned in the notation:
wc=US2c.
(5.6)
is the angular velocity of frame (C) relative to some understood reference
is the angular velocity of frame (C) expressed in terms
frame, (U). For example,
of (A) (though the angular velocity is with respect to (U)).
In this section, we investigate the description of motion of a rigid body, at least
as far as velocity is concerned. These ideas extend the notions of translations and
orientations described in Chapter 2 to the time-varying case. In Chapter 6, we will
further extend our study to considerations of acceleration.
As in Chapter 2, we attach a coordinate system to any body that we wish to
describe. Then, motion of rigid bodies can be equivalently studied as the motion of
frames relative to one another.
Linear velocity
Consider a frame (B) attached to a rigid body. We wish to describe the motion of
relative to frame (A), as in Fig. 5.3. We may consider {A} to be fixed.
Frame (B } is located relative to (A), as described by a position vector,
For the moment, we wifi assume that the orientation,
and a rotation matrix,
is not changing with time—that is, the motion of point Q relative to (A} is due to
ApBORG or B Q changing in time.
Solving for the linear velocity of point Q in terms of (A) is quite simple. Just
express both components of the velocity in terms of (A), and sum them:
Equation (5.7) is for only that case in which relative orientation of (B) and (A}
remains constant.
Section 5.3
Linear and rotational velocity of rigid bodies
FIGURE 5.3:
Frame {B} is translating with velocity A VBORG relative to frame {A}.
Rotational velocity
Now let us consider two frames with coincident origins and with zero linear relative
velocity; their origins will remain coincident for all time. One or both could be
attached to rigid bodies, but, for clarity, the rigid bodies are not shown in Fig. 5.4.
The orientation of frame {B} with respect to frame {A} is changing in time.
As indicated in Fig. 5.4, rotational velocity of {B} relative to {A} is described by a
vector called AQB. We also have indicated a vector B that locates a point fixed in
{B}. Now we consider the all-important question: How does a vector change with
time as viewed from {A} when it is fixed in {B} and the systems are rotating?
Let us consider that the vector Q is constant as viewed from frame {B}; that is,
VQ =0.
(5.8)
Even though it is constant relative to {B}, it is clear that point Q wifi have a velocity
as seen from {A} that is due to the rotational velocity A
To solve for the velocity
of point Q, we will use an intuitive approach. Figure 5.5 shows two instants of time
as vector Q rotates around Ac2 This is what an observer in {A} would observe.
FIGURE 5.4: Vector B
angular velocity A c2B.
fixed in frame {B}, is rotating with respect to frame {A} with
140
(t +
FIGURE 5.5:
The velocity of a point due to an angular velocity.
By examining Fig. 5.5, we can figure out both the direction and the magnitude
of the change in the vector as viewed from {A}. First, it is clear that the differential
Second, we see from
change in AQ must be perpendicular to both Ac2B and
Fig. 5.5 that the magnitude of the differential change is
IAQI =
(5.9)
These conditions on magnitude and direction immediately suggest the vector crossproduct. Indeed, our conclusions about direction and magnitude are satisfied by the
computational fonn
XAQ.
(5.10)
In the general case, the vector Q could also be changing with respect to frame {B},
so, adding this component, we have
Av = A(BV) +
x AQ
(5.11)
Using a rotation matrix to remove the dual-superscript, and noting that the description of A at any instant is
Q, we end with
(5.12)
Simultaneous linear and rotational velocity
We can very simply expand (5.12) to the case where origins are not coincident by
adding on the linear velocity of the origin to (5.12) to derive the general formula for
velocity of a vector fixed in frame {B} as seen from frame {A}:
A1, _A1,
Section 5.4
More on angular velocity
Equation (5.13) is the final result for the derivative of a vector in a moving frame as
seen from a stationary frame.
5.4 MORE ON ANGULAR VELOCITY
In this section, we take a deeper look at angular velocity and, in particular, at
the derivation of (5.10). Whereas the previous section took a geometric approach
toward showing the validity of (5.10), here we take a mathematical approach. This
section may be skipped by the first-time reader.
A property of the derivative of an orthonormal matrix
We can derive an interesting relationship between the derivative of an orthonormal
matrix and a certain skew-symmetric matrix as follows. For any ii x ii orthonormal
matrix, R, we have
(5.14)
is the n x n identity matrix. Our interest, by the way, is in the case where
and R is a proper orthonormal matrix, or rotation matrix. Differentiating
(5.14) yields
(5.15)
is the n x n zero matrix. Eq. (5.15) may also be written
RRT + (RRT)T = 0,r
(5.16)
(5.17)
Defining
we have, from (5.16), that
(5.18)
So, we see that S is a skew-symmetric matrix. Hence, a property relating the
derivative of orthonormal matrices with skew-symmetric matrices exists and can be
stated as
(5.19)
Velocity of a point due to rotating reference frame
Consider a fixed vector B P unchanging with respect to frame (B). Its description in
another frame {A} is given as
If frame {B} is rotating (i.e., the derivative
even though B P is constant; that is,
(5.20)
is nonzero), then A P will be changing
ApARBp
(5.21)
or, using our notation for velocity,
(5.22)
142
Now, rewrite (5.22) by substituting for B p, to obtain
A17 _ARAR_lAp
Making use of our result (5.19) for orthonormal matrices, we have
AVPASAP
(5.24)
where we have adorned S with sub- and superscripts to indicate that it is the skewBecause of its
symmetric matrix associated with the particular rotation matrix
appearance in (5.24), and for other reasons to be seen shortly, the skew-symmetric
matrix we have introduced is called the angular-velocity matrix.
Skew-symmetric matrices and the vector cross-product
If we assign the elements in a skew-symmetric matrix S as
(5.25)
and define the 3 x 1 column vector
(5.26)
then it is easily verified that
(5.27)
where P is any vector, and x is the vector cross-product.
which corresponds to the 3 x 3 angular-velocity matrix, is
The 3 x 1 vector
called the angular-velocity vector and was already introduced in Section 5.2.
Hence, our relation (5.24) can be written
(5.28)
indicating that it is the angular-velocity
vector specifying the motion of frame {B} with respect to frame {A}.
where we have shown the notation for
Gaining physical insight concerning the angular-velocity vector
Having concluded that there exists some vector such that (5.28) is true, we now
wish to gain some insight as to its physical meaning. Derive by direct differentiation
of a rotation matrix; that is,
Now, write R(t +
R(t)
R(t +
(5.29)
as the composition of two matrices, namely,
R(t + At) = RK(A9)R(t),
(5.30)
More on angular velocity
Section 5.4
where, over the interval
(5.30), write (5.29) as
a small rotation of M has occurred about axis
(5.31)
(5.32)
Now, from small angle substitutions in (2.80), we have
(5.33)
R(t).
(5.34)
So, (5.32) may be written
Finally, dividing the matrix through by At and then taking the limit, we have
(5.35)
Hence, we see that
(5.36)
1=9K.
(5.37)
The physical meaning of the angular-velocity vector is that, at any instant, the
change in orientation of a rotating frame can be viewed as a rotation about some
axis K. This instantaneous axis of rotation, taken as a unit vector and then scaled by
the speed of rotation about that axis (0), yields the angular-velocity vector.
Other representations of angular velocity
Other representations of angular velocity are possible; for example, imagine that
the angular velocity of a rotating body is available as rates of the set of Z—Y—Z
Euler angles:
ez,YIzI = I
(5.38)
144
Given this style of description, or any other using one of the 24 angle sets, we would
like to derive the equivalent angular-velocity vector.
We have seen that
(5.39)
From this matrix equation, one can extract three independent equations, namely,
+ '32'22 +
(5.40)
+ 112132 + 113133,
c2y =
'21'11
From (5.40) and a symbolic description of R in terms of an angle set, one can derive
the expressions that relate the angle-set velocities to the equivalent angular-velocity
vector. The resulting expressions can be cast in matrix form—for example, for
Z—Y—Z Euler angles,
(5.41)
That is, E (.) is a Jacobian relating an angle-set velocity vector to the angular-velocity
vector and is a function of the instantaneous values of the angle set. The form of
E() depends on the particular angle set it is developed for; hence, a subscript is
added to indicate which.
EXAMPLE 5.2
Construct the E matrix that relates Z—Y—Z Euler angles to the angular-velocity
in (5.41).
vector; that is, find
Using (2.72) and (5.40) and doing the required symbolic differentiations yields
[0 —sa
sas/3
(5.42)
In considering the motions of robot links, we wifi always use link frame {0} as our
reference frame. Hence, is the linear velocity of the origin of link frame {i and
is the angular velocity of link frame {i }.
At any instant, each link of a robot in motion has some linear and angular
velocity. Figure 5.6 indicates these vectors for link i. In this case, it is indicated that
they are written in frame {i }.
We now consider the problem of calculating the linear and angular velocities of the
links of a robot. A manipulator is a chain of bodies, each one capable of motion
Section 5.6
Velocity "propagation" from link to link
Aids
FIGURE 5.6: The velocity of link i is given by vectors
in any frame, even frame {i }.
and w1, which may be written
relative to its neighbors. Because of this structure, we can compute the velocity of
each link in order, starting from the base. The velocity of link i + 1 will be that of
link i, plus whatever new velocity components were added by joint i + 1.2
As indicated in Fig. 5.6, let us now think of each link of the mechanism as a
rigid body with linear and angular velocity vectors describing its motion. Further,
we wifi express these velocities with respect to the link frame itself rather than with
respect to the base coordinate system. Figure 5.7 shows links i and i + 1, along with
their velocity vectors defined in the link frames.
Rotational velocities can be added when both cv vectors are written with
respect to the same frame. Therefore, the angular velocity of link I
+ 1 is the same
I',.
FIGURE 5.7: Velocity vectors of neighboring links.
2Remember that linear velocity is associated with a point, but angular velocity is associated with a
body. Hence, the term "velocity of a link" here means the linear velocity of the origin of the link frame
and the rotational velocity of the link.
146
as that of link i plus a new component caused by rotational velocity at joint i + 1.
This can be written in terms of frame {i} as
= 'Wi
(5.43)
Note that
= 1+1
(544)
We have made use of the rotation matrix relating frames {i} and {i + 1} in order to
represent the added rotational component due to motion at the joint in frame {i }.
The rotation matrix rotates the axis of rotation of joint i + 1 into its description in
frame {i so that the two components of angular velocity can be added.
we can find the description of
By premultiplying both sides of (5.43) by
1 with respect to frame {i + 11:
the angular velocity of link i +
_i+lDi
Wi+1 —
Wi —1-•
i+1•
The linear velocity of the origin of frame {i + 1} is the same as that of the origin
of frame {i} plus a new component caused by rotational velocity of link i. This is
exactly the situation described by (5.13), with one term vanishing because
Therefore, we have
constant in frame {i}.
= lvi + 'w1 x
(5.46)
we compute
Premultiplying both sides by
(5.47)
Equations (5.45) and (5.47) are perhaps the most important results of this chapter.
The corresponding relationships for the case that joint i + 1 is prismatic are
= I+1R
'co1,
+ 'w1 x
i+1Z+i.
(5.48)
Applying these equations successively from link to link, we can compute NWN and
NUN the rotational and linear velocities of the last link. Note that the resulting
velocities are expressed in terms of frame {N}. This turns out to be useful, as we will
see later. If the velocities are desired in terms of the base coordinate system, they
can be rotated into base coordinates by multiplication with
EXAMPLE 5.3
A two-link manipulator with rotational joints is shown in Fig. 5.8. Calculatethe
velocity of the tip of the arm as a function of joint rates. Give the answer in two
forms—in terms of frame {3} and also in terms of frame {O}.
Frame {3} has been attached at the end of the manipulator, as shown in Fig. 5.9,
and we wish to find the velocity of the origin of this frame expressed in frame {3}.
As a second part of the problem, we will express these velocities in frame {O} as
FIGURE 5.8:
A two-link manipulator.
FIGURE 5.9:
Frame assignments for the two-link manipulator.
well. We wifi start by attaching frames to the links as we have done before (shown
in Fig. 5.9).
We will use (5.45) and (5.47) to compute the velocity of the origin of each
frame, starting from the base frame {0}, which has zero velocity. Because (5.45) and
(5.47) will make use of the link transformations, we compute them:
Cl —Si 0 0
c1 00
0 01
148
Note that these correspond to the manipulator of Example 3.3 with joint 3 perma-
nently ftxed at zero degrees. The final transformation between frames {2} and {3}
need not be cast as a standard link transformation (though it might be helpful to do
so). Then, using (5.45) and (5.47) sequentially from link to link, we calculate
(5.50)
(5.51)
(5.52)
—S2 C2 0
0•
Lb 01]L0]
l1s7O1
11c291
(5.53)
(5.54)
11c901
+ 19(9k + 97)
(5.55)
Equation (5.55) is the answer. Also, the rotational velocity of frame {3} is found in
(5.54).
To ffild these velocities with respect to the nonmoving base frame, we rotate
which is
them with the rotation matrix
[c12 —S12 01
(5.56)
30R =
This rotation yields
[—lisiOi —
11c101
12s19(91
+02)1
+ 12c12(91 +
(5.57)
It is important to point out the two distinct uses for (5.45) and (5.47). First,
they can be used as a means of deriving analytical expressions, as in Example 5.3
above. Here, we manipulate the symbolic equations until we arrive at a form such
as (5.55), which wifi be evaluated with a computer in some application. Second,
they can be used directly to compute (5.45) and (5.47) as they are written. They
can easily be written as a subroutine, which is then applied iteratively to compute
link velocities. As such, they could be used for any manipulator, without the need
of deriving the equations for a particular manipulator. However, the computation
Section 5.7
Jacobians
then yields a numeric result with the structure of the equations hidden. We are often
interested in the structure of an analytic result such as (5.55). Also, if we bother
to do the work (that is, (5.50) through (5.57)), we generally will find that there are
fewer computations left for the computer to perform in the final application.
The Jacobian is a multidimensional form of the derivative. Suppose, for example,
that we have six functions, each of which is a function of six independent variables:
= f1(xj, x2, x3, x4, x5, x6),
= f2(x1,x2,x3,x4,x5,x6),
(5.58)
Y6 = f6(x1, x2, x3, x4, x5, x6).
We could also use vector notation to write these equations:
Y = F(X).
(5.59)
Now, if we wish to calculate the differentials of y1 as a function of differentials of x1,
we simply use the chain rule to calculate, and we get
—8x1 + —8x2 + .. + —8x6,
= —SX1 +
+ . .. + —8x6,
(5.60)
8Y6 =
+ —8x2 + . .. + —8x6,
which again might be written more simply in vector notation:
(5.61)
The 6 x 6 matrix of partial derivatives in (5.61) is what we call the Jacobian, J. Note
that, if the functions f1 (X) through f6 (X) are nonlinear, then the partial derivatives
are a function of the
so, we can use the notation
8Y = J(X)SX.
(5.62)
By dividing both sides by the differential time element, we can think of the Jacobian
as mapping velocities in X to those in Y:
(5.63)
At any particular instant, X has a certain value, and J(X) is a linear transformation. At each new time instant, x has changed, and therefore, so has the linear
transformation. Jacobians are time-varying linear transformations.
150
In the field of robotics, we generally use Jacobians that relate joint velocities
to Cartesian velocities of the tip of the arm—for example,
(5.64)
where e is the vector ofjoint angles of the manipulator and v is a vector of Cartesian
velocities. In (5.64), we have added a leading superscript to our Jacobian notation to
indicate in which frame the resulting Cartesian velocity is expressed. Sometimes this
superscript is omitted when the frame is obvious or when it is unimportant to the
development. Note that, for any given configuration of the manipulator, joint rates
are related to velocity of the tip in a linear fashion, yet this is only an instantaneous
relationship—in the next instant, the Jacobian has changed slightly. For the general
case of a six-jointed robot, the Jacobian is 6 x 6, e is 6 x 1, and is 6 x 1. This 6 x 1
Cartesian velocity vector is the 3 x 1 linear velocity vector and the 3 x 1 rotational
velocity vector stacked together:
(5.65)
Jacobians of any dimension (including nonsquare) can be defined. The number
of rows equals the number of degrees of freedom in the Cartesian space being
considered. The number of columns in a Jacobian is equal to the number of joints
of the manipulator. In dealing with a planar arm, for example, there is no reason
for the Jacobian to have more than three rows, although, for redundant planar
manipulators, there could be arbitrarily many columns (one for each joint).
In the case of a two-link arm, we can write a 2 x 2 Jacobian that relates
joint rates to end-effector velocity. From the result of Example 5.3, we can easily
determine the Jacobian of our two-link arm. The Jacobian written in frame {3} is
seen (from (5.55)) to be
3J(e) =
11s2
(5.66)
and the Jacobian written in frame (0) is (from (5.57))
0J(O) = [
—l1s1 — 12s12
/1c1 + 12c12
12s12 1
12c12
(5.67)
Note that, in both cases, we have chosen to write a square matrix that relates joint
rates to end-effector velocity. We could also consider a 3 x 2 Jacobian that would
include the angular velocity of the end-effector.
Considering (5.58) through (5.62), which define the Jacobian, we see that the
Jacobian might also be found by directly differentiating the kinematic equations
of the mechanism. This is straightforward for linear velocity, but there is no 3 x 1
orientation vector whose derivative is w. Hence, we have introduced a method to
derive the Jacobian by using successive application of (5.45) and (5.47). There are
several other methods that can be used (see, for example, [4]), one of which wifi be
introduced shortly in Section 5.8. One reason for deriving Jacobians via the method
presented is that it helps prepare us for material in Chapter 6, in which we wifi find
that similar techniques apply to calculating the dynamic equations of motion of a
Section 5.8
Singularities
Changing a Jacobian's frame of reference
Given a Jacobian written in frame {B}, that is,
= BJ(e)è
(5.68)
we might be interested in giving an expression for the Jacobian in another frame,
{A}. First, note that a 6 x 1 Cartesian velocity vector given in {B} is described relative
to {A) by the transformation
(5.69)
Hence, we can write
(5.70)
Now it is clear that changing the frame of reference of a Jacobian is accomplished by means of the following relationship:
AJ(0) =
rAR 0 1
(5.71)
Given that we have a linear transformation relating joint velocity to Cartesian
velocity, a reasonable question to ask is: Is this matrix invertible? That is, is it
nonsingular? If the matrix is nonsingular, then we can invert it to calculate joint
rates from given Cartesian velocities:
(5.72)
This is an important relationship. For example, say that we wish the hand of the
robot to move with a certain velocity vector in Cartesian space. Using (5.72), we
could calculate the necessary joint rates at each instant along the path. The real
question of invertibility is: Is the Jacobian invertible for all values of 0? If not,
where is it not invertible?
Most manipulators have values of 0 where the Jacobian becomes singular.
Such locations are called singularities of the mechanism or singularities for short. All
manipulators have singularities at the boundary of their workspace, and most have
loci of singularities inside their workspace. An in-depth study of the classification of
singularities is beyond the scope of this book—for more information, see [5]. For
our purposes, and without giving rigorous definitions, we wifi class singularities into
two categories:
1. Workspace-boundary singularities occur when the manipulator is fully
stretched out or folded back on itself in such a way that the end-effector
is at or very near the boundary of the workspace.
152
2. Workspace-interior singularities occur away from the workspace boundary;
they generally are caused by a lining up of two or more joint axes.
When a manipulator is in a singular configuration, it has lost one or more
degrees of freedom (as viewed from Cartesian space). This means that there is some
direction (or subspace) in Cartesian space along which it is impossible to move the
hand of the robot, no matter what joint rates are selected. It is obvious that this
happens at the workspace boundary of robots.
EXAMPLE 5.4
Where are the singularities of the simple two-link arm of Example 5.3? What is the
physical explanation of the singularities? Are they workspace-boundary singularities
or workspace-interior singularities?
To find the singular points of a mechanism, we must examine the determinant
of its Jacobian. Where the determinant is equal to zero, the Jacobian has lost full
rank and is singular:
DET [J(O)] _ [
llc2 + 12
=1112s2 = 0.
(5.73)
Clearly, a singularity of the mechanism exists when 02 is 0 or 180 degrees. Physically,
when 02 = 0, the arm is stretched straight out. In this configuration, motion of the
end-effector is possible along only one Cartesian direction (the one perpendicular
to the arm). Therefore, the mechanism has lost one degree of freedom. Likewise,
when 02 = 180, the arm is folded completely back on itself, and motion of the hand
again is possible only in one Cartesian direction instead of two. We will class these
singularities as workspace-boundary singularities, because they exist at the edge of
the manipulator's workspace. Note that the Jacobian written with respect to frame
(0), or any other frame, would have yielded the same result.
The danger in applying (5.72) in a robot control system is that, at a singular
point, the inverse Jacobian blows up! This results in joint rates approaching infinity
as the singularity is approached.
EXAMPLE 5.5
Consider the two-link robot from Example 5.3 as it is moving its end-effector along
the X axis at 1.0 m/s, as in Fig. 5.10. Show that joint rates are reasonable when far
from a singularity, but that, as a singularity is approached at 02 = 0, joint rates tend
to infinity.
We start by calculating the inverse of the Jacobian written in (0):
O J-1(O) = 1112s2
_11c1 1
12c12 -11s1
(5.74)
12s12
Section 5.9
Static forces in manipulators
FiGURE 5.10:
A two-link manipulator moving its tip at a constant linear velocity.
Then, using Eq. (5.74) for a velocity of 1 mIs in the X direction, we can calculate
joint rates as a function of manipulator configuration:
(5.75)
'-'2 —
Clearly, as the arm stretches out toward
t1S7
= 0, both joint rates go to infinity.
EXAMPLE 5.6
For the PUMA 560 manipulator, give two examples of singularities that can occur.
There is singularity when 93 is near —90.0 degrees. Calculation of the exact
value of 93 is left as an exercise. (See Exercise 5.14.) In this situation, links 2 and
3 are "stretched out," just like the singular location of the two-link manipulator in
Example 5.3. This is classed as a workspace-boundary singularity.
Whenever 95 = 0.0 degrees, the manipulator is in a singular configuration. In
this configuration, joint axes 4 and 6 line up—both of their actions would result
in the same end-effector motion, so it is as if a degree of freedom has been lost.
Because this can occur interior to the workspace envelope, we wifi class it as a
workspace-interior singularity.
The chainlike nature of a manipulator leads us quite naturally to consider how forces
and moments "propagate" from one link to the next. Typically, the robot is pushing
on something in the environment with the chain's free end (the end-effector) or is
perhaps supporting a load at the hand. We wish to solve for the joint torques that
must be acting to keep the system in static equilibrium.
In considering static forces in a manipulator, we first lock all the joints so that
the manipulator becomes a structure. We then consider each link in this structure
and write a force-moment balance relationship in terms of the link frames. Finally,
154
we compute what static torque must be acting about the joint axis in order for the
manipulator to be in static equilibrium. In this way, we solve for the set of joint
torques needed to support a static load acting at the end-effector.
In this section, we will not be considering the force on the links due to gravity
(that will be left until chapter 6). The static forces and torques we are considering
at the joints are those caused by a static force or torque (or both) acting on the last
link-for example, as when the manipulator has its end-effector in contact with the
environment.
We define special symbols for the force and torque exerted by a neighbor link:
fi = force exerted on link i by link i - 1,
ni = torque exerted on link i by link i - 1.
We will use our usual convention for assigning frames to links. Figure 5.11
shows the static forces and moments (excluding the gravity force) acting on link i.
Summing the forces and setting them equal to zero, we have
i fi
- i fi+1 = 0.
(5.76)
Summing torques about the origin of frame {i }, we have
-'ni+l -'Pi+l X 'fi+l = 0.
(5.77)
If we start with a description of the force and moment applied by the hand, we
can calculate the force and moment applied by each link, working from the last link
down to the base (link 0). To do this, we formulate the force-moment expressions
(5.76) and (5.77) such that they specify iterations from higher numbered links to
lower numbered links. The result can be written as
I fi = `fi+i,
(5.78)
`ni = `ni+l + ` Pi+i X `fi+i
(5.79)
In order to write these equations in terms of only forces and moments defined
within their own link frames, we transform with the rotation matrix describing frame
FIGURE 5.11: Static force-moment balance for a single link.
FIGURE 5.12: A two-link manipulator applying a force at its tip.
{i + 1} relative to frame {i}. This leads to our most important result for static force
"propagation" from link to link:
'fi =
(5.80)
(5.81)
Finally, this important question arises: What torques are needed at the joints in order
to balance the reaction forces and moments acting on the links? All components
of the force and moment vectors are resisted by the structure of the mechanism
itself, except for the torque about the joint axis. Therefore, to find the joint torque
required to maintain the static equilibrium, the dot product of the joint-axis vector
with the moment vector acting on the link is computed:
(5.82)
In the case that joint i is prismatic, we compute the joint actuator force as
r_ifTi2
(5.83)
Note that we are using the symbol t even for a linear joint force.
As a matter of convention, we generally define the positive direction of joint
torque as the direction which would tend to move the joint in the direction of
increasing joint angle.
Equations (5.80) through (5.83) give us a means to compute the joint torques
needed to apply any force or moment with the end-effector of a manipulator in the
static case.
EXAMPLE 5.7
The two-link manipulator of Example 5.3 is applying a force vector 3F with its
end-effector. (Consider this force to be acting at the origin of {3}.) Find the required
joint torques as a function of configuration and of the applied force. (See Fig. 5.12.)
156
We apply Eqs. (5.80) through (5.82), starting from the last link and going
toward the base of the robot:
2f_[f]
(5.84)
(5.85)
c2 —s2 0
(5.86)
+i1k1 x 1f1 =
(5.87)
+ (12 +
(5.88)
(5.89)
This relationship can be written as a matrix operator:
12+11C2]
(5.90)
It is not a coincidence that this matrix is the transpose of the Jacobian that we found
in (5.66)!
5.10
JACOBIANS IN THE FORCE DOMAIN
We have found joint torques that wifi exactly balance forces at the hand in the static
situation. When forces act on a mechanism, work (in the technical sense) is done
if the mechanism moves through a displacement. Work is defined as a force acting
through a distance and is a scalar with units of energy. The principle of virtual work
allows us to make certain statements about the static case by allowing the amount of
this displacement to go to an infinitesimal. Work has the units of energy, so it must
be the same measured in any set of generalized coordinates. Specifically, we can
equate the work done in Cartesian terms with the work done in joint-space terms.
In the multidimensional case, work is the dot product of a vector force or torque
and a vector displacement. Thus, we have
(5.91)
where .F is a 6 x 1 Cartesian force-moment vector acting at the end-effector,
a 6 x 1 infinitesimal Cartesian displacement of the end-effector, r is a 6 x 1 vector
Section 5.11
Cartesian transformation of velocities and static forces
of torques at the joints, and 80 is a 6 x 1 vector of infinitesimal joint displacements.
Expression (5.91) can also be written as
(5.92)
The definition of the Jacobian is
= J80,
(5.93)
so we may write
= rTS0
(5.94)
which must hold for all 80; hence, we have
(5.95)
Transposing both sides yields this result:
(5.96)
Equation (5.96) verifies in general what we saw in the particular case of the two-link
manipulator in Example 5.6: The Jacobian transpose maps Cartesian forces acting
at the hand into equivalent joint torques. When the Jacobian is written with respect
to frame {O}, then force vectors written in {O} can be transformed, as is made clear
by the following notation:
(5.97)
When the Jacobian loses full rank, there are certain directions in which the endeffector caimot exert static forces even if desired. That is, in (5.97), if the Jacobian
is singular, .7 could be increased or decreased in certain directions (those defining
the null-space of the Jacobian [6]) without effect on the value calculated for r. This
also means that, near singular configurations, mechanical advantage tends toward
infinity, such that, with small joint torques, large forces could be generated at the
end-effector.3 Thus, singularities manifest themselves in the force domain as well as
in the position domain.
Note that (5.97) is a very interesting relationship, in that it allows us to convert
a Cartesian quantity into a joint-space quantity without calculating any inverse
kinematic functions. We wifi make use of this when we consider the problem of
control in later chapters.
5.11
CARTESIAN TRANSFORMATION OF VELOCITIES AND STATIC FORCES
We might wish to think in terms of 6 x 1 representations of general velocity of a
(5.98)
Likewise, we could consider 6 x 1 representations of general force vectors,
such as
(5.99)
3Consider a two-link planar manipulator nearly outstretched with the end-effector in contact with a
reaction surface. In this configuration, arbitrarlly large forces could be exerted by "small" joint torques.
158
where F is a 3 x 1 force vector and N is a 3 x 1 moment vector. It is then natural
to think of 6 x 6 transformations that map these quantities from one frame to
another. This is exactly what we have already done in considering the propagation
of velocities and forces from link to link. Here, we write (5.45) and (5.47) in matrixoperator form to transform general velocity vectors in frame {A} to their description
in frame {B}.
appearing in
The two frames involved here are rigidly connected, so
(5.45), is set to zero in deriving the relationship
BRAPBORGX
JLAWAJ
(5.100)
where the cross product is understood to be the matrix operator
(5.101)
Now, (5.100) relates velocities in one frame to those in another, so the 6 x 6 operator
In this case, it is
wifi be called a velocity transformation; we will use the symbol
a velocity transformation that maps velocities in {A} into velocities in {B}, so we use
the following notation to express (5.100) compactly:
(5.102)
We can invert (5.100) in order to compute the description of velocity in terms of
{A}, given the quantities in {B}:
[AW] =
AR1rB
(5.103)
AV_ATBV
(5.104)
Note that these mappings of velocities from frame to frame depend on T (or its
inverse) and so must be interpreted as instantaneous results, unless the relationship
between the two frames is static. Similarly, from (5.80) and (5.81), we write the
6 x 6 matrix that transforms general force vectors written in terms of {B} into their
description in frame {A}, namely,
EAF 1
[AN]
APBO: G x
0 1EBF1
IL BNB]'
(5.105)
which may be written compactly as
where Tf is used to denote a force-moment transformation.
(5.106)
Bibliography
Wrist
Sensor frame
FIGURE 5.13:
Frames of interest with a force sensor.
Velocity and force transformations are similar to Jacobians in that they relate
velocities and forces in different coordinate systems. As with Jacobians, we have
Ap _A T
as can be verified by examining (5.105) and (5.103).
EXAMPLE 5.8
Figure 5.13 shows an end-effector holding a tool. Located at the point where the
end-effector attaches to the manipulator is a force-sensing wrist. This is a device
that can measure the forces and torques applied to it.
Consider the output of this sensor to be a 6 x 1 vector, S1 composed of three
forces and three torques expressed in the sensor frame, {S}. Our real interest is in
knowing the forces and torques applied at the tip of the tool,
Find the 6 6
transformation that transforms the force-moment vector from {S} to the tool frame,
{T}. The transform relating {T} to {S},
is known. (Note that {S} here is the
sensor frame, not the station frame.)
This is simply an application of (5.106). First, from T, we calculate the inverse,
which is composed of
and TPSORG. Then we apply (5.106) to obtain
[1] K. Hunt, Kinematic Geometry of Mechanisms, Oxford University Press, New York,
1978.
[2] K.R. Symon, Mechanics, 3rd edition, Addison-Wesley, Reading, MA, 1971.
Chapter 5
[3] I. Shames, Engineering Mechanics, 2nd edition, Prentice-Hall, Englewood Cliffs, NJ,
[4] D. Orin and W. Schrader, "Efficient Jacobian Determination for Robot
Manipulators," in Robotics Research: The First International Symposium, M. Brady
and R.P. Paul, Editors, MIT Press, Cambridge, MA, 1984.
[5] B. Gorla and M. Renaud, Robots Manipulateurs, Cepadues-Editions, Toulouse, 1984.
[6] B. Noble, Applied Linear Algebra, Prentice-Hall, Englewood Cliffs, NJ, 1969.
[7] J.K. Salisbury and J. Craig, "Articulated Hands: Kinematic and Force Control Issues,"
International Journal of Robotics Research, Vol. 1, No. 1, Spring 1982.
[8] C. Wampler, "Wrist Singularities: Theory and Practice," in The Robotics Review 2,
0. Khatib, J. Craig, and T. Lozano-Perez, Editors, IvilT Press, Cambridge, MA, 1992.
D.E. Whitney, "Resolved Motion Rate Control of Manipulators and Human Prosthe-
ses," IEEE Transactions on Man-Machine Systems, 1969.
but using the Jacobian written in frame {0}. Are the
results the same as those of Example 5.3?
5.2 [25] Find the Jacobian of the manipulator with three degrees of freedom from
Exercise 3 of Chapter 3. Write it in terms of a frame {4} located at the tip of the
hand and having the same orientation as frame {3}.
5.3 [35] Find the Jacobian of the manipulator with three degrees of freedom from
hand and having the same orientation as frame {3}. Derive the Jacobian in three
different ways: velocity propagation from base to tip, static force propagation
from tip to base, and by direct differentiation of the kinematic equations.
5.4 [8] Prove that singularities in the force domain exist at the same configurations as
singularities in the position domain.
5.5 [39] Calculate the Jacobian of the PUMA 560 in frame {6}.
5.1 [101 Repeat Example 5.3,
5.6 [47] Is it true that any mechanism with three revolute joints and nonzero link
lengths must have a locus of singular points interior to its workspace?
5.7 [7] Sketch a figure of a mechanism with three degrees of freedom whose linear
velocity Jacobian is the 3 x 3 identity matrix over all configurations of the
manipulator. Describe the kinematics in a sentence or two.
5.8 [18] General mechanisms sometimes have certain configurations, called "isotropic
points," where the columns of the Jacobian become orthogonal and of equal
magnitude [7]. For the two-link manipulator of Example 5.3, find out if any
isotropic points exist. Hint: Is there a requirement on 11 and 12?
5.9 [50] Find the conditions necessary for isotropic points to exist in a general
manipulator with six degrees of freedom. (See Exercise 5.8.)
For the two-link manipulator of Example 5.2, give the transformation that
would map joint torques into a 2 x 1 force vector, 3F, at the hand.
5.11 [14] Given
0.866 0.000 0.0
BT = 0.000 0.000 1.000 5.0
5.10 [7]
if the velocity vector at the origin of {A} is
A—
—3.0
1.414
find the 6 x 1 velocity vector with reference point the origin of {B}.
5.12 [15] For the three-link manipulator of Exercise 3.3, give a set of joint angles for
which the manipulator is at a workspace-boundary singularity and another set of
angles for which the manipulator is at a workspace-interior singularity.
5.13 [9] A certain two-link manipulator has the following Jacobian:
—11s1 — 12s12
[ l1c1 + 12c12 12c12
Ignoring gravity, what are the joint torques required in order that the manipulator
will apply a static force vector 0F = lOX0?
5.14 [18] If the link parameter 03 of the PUMA 560 were zero, a workspace-boundary
singularity would occur when 03 = —90.0°. Give an expression for the value of 03
°J(O) = [
where the singularity occurs, and show that, if 03 were zero, the result would be
03 = —90.0°. Hint: In this configuration, a straight line passes through joint axes
2 and 3 and the point where axes 4, 5, and 6 intersect.
5.15 [24] Give the 3 x 3 Jacobian that calculates linear velocity of the tool tip from
the three joint rates for the manipulator of Example 3.4 in Chapter 3. Give the
Jacobian in frame {0}.
5.16 [20]
A 3R manipulator has kinematics that correspond exactly to the set of
Z—Y--Z Euler angles (i.e., the forward kinematics are given by (2.72) with a = 01,
and y =
03).
Give the Jacobian relating joint velocities to the angular
velocity of the final link.
5.17 [31] Imagine that, for a general 6-DOF robot, we have available
for all i—that is, we know the values for the unit Z vectors of each link frame in
terms of the base frame and we know the locations of the origins of all link frames
in terms of the base frame. Let us also say that we are interested in the velocity of
the tool point (fixed relative to link n) and that we know
also. Now, for a
revolute joint, the velocity of the tool tip due to the velocity of joint i is given by
°Piorg)
(5.110)
and the angular velocity of link ii due to the velocity of this joint is given by
(5.111)
= 0Z.
The total linear and angular velocity of the tool is given by the sum of the
and 0w respectively. Give equations analogous to (5.110) and (5.111) for the case
of joint i prismatic, and write the 6 x 6 Jacobian matrix of an arbitrary 6-DOF
manipulator in terms of the Z,
5.18 [18] The kinematics of a 3R robot are given by
c1c23 —c1s23
0T —
11c1 + l2c1c2
—s1s23 —C1 11s1 + 12s1c2
12s2
162
Chapter
Find °J(e), which, when multiplied by the joint velocity vector, gives the linear
velocity of the origin of frame {3} relative to frame {0}.
5.19 [15] The position of the origin of link 2 for an RP manipulator is given by
a1c1 — d9s1
a1s1+d2c1
Give the 2 x 2 Jacobian that relates the two joint rates to the linear velocity of
the origin of frame {2]. Give a value of 0 where the device is at a singularity.
5.20 [20] Explain what might be meant by the statement: "An n-DOF manipulator at a
singularity can be treated as a redundant manipulator in a space of dimensionality
— 1.''
PROGRAMMING EXERCISE (PART 5)
Two frames, {A} and {B}, are not moving relative to one another—that is,
constant. In the planar case, we define the velocity of frame {A} as
T is
and AvA, computes BVB. Hint: This is the planar
Write a routine that, given
analog of (5.100). Use a procedure heading something like (or equivalent C):
Veltrans (VAR brela: frame; VAR vrela, vrelb: vec3);
"vrela" is the velocity relative to frame {A}, or AVA, and "vrelb" is the
of the routine (the velocity relative to frame (B)), or B
2. Determine the 3 x 3 Jacobian of the three-link planar manipulator (from Example 3.3). In order to derive the Jacobian, you should use velocity-propagation
analysis (as in Example 5.2) or static-force analysis (as in Example 5.6). Hand in
your work showing how you derived the Jacobian.
Write a routine to compute the Jacobian in frame {3}—that is, 3J(0)—as a
function of the joint angles. Note that frame (3) is the standard link frame with
origin on the axis of joint 3. Use a procedure heading something like (or equivalent
The manipulator
Jacobian (VAR theta: vec3; Var
data are 12 =
Jac:
mat33);
0.5 meters.
A tool frame and a station frame are defined as follows by the user for a certain
task (units are meters and degrees):
0] =
[0.1 0.2 30.0],
= [xyO]=[0.00.00.0].
At a certain instant, the tool tip is at the position
[0.6 —0.3 45.0].
MATLAB Exercise 5
At the same instant, the joint rates (in deg/sec) are measured to be
83] = [20.0
10.0 12.0].
Calculate the linear and angular velocity of the tool tip relative to its own frame,
that is, TVT. If there is more than one possible answer, calculate all possible
answers.
MATLAB EXERCISE 5
This exercise focuses on the Jacobian matrix and determinant, simulated resolved-rate
control, and inverse statics for the planar 3-DOF, 3R robot. (See Figures 3.6 and 3.7; the
DH parameters are given in Figure 3.8.)
The resolved-rate control method [9] is based on the manipulator velocity equation
kX = kje where kj is the Jacobian matrix, e is the vector of relative joint rates, kX is
the vector of commanded Cartesian velocities (both translational and rotational), and k
is the frame of expression for the Jacobian matrix and Cartesian velocities. This figure
shows a block diagram for simulating the resolved-rate control algorithm:
Resolved-Rate-Algorithm Block Diagram
As is seen in the figure, the resolved-rate algorithm calculates the required
commanded joint rates
to provide the commanded Cartesian velocities Xc; this
diagram must be calculated at every simulated time step. The Jacobian matrix changes
with configuration
For simulation purposes, assume that the commandedjoint angles
are always identical to the actual joint angles achieved, 0A (a result rarely true in the
real world). For the planar 3-DOF, 3R robot assigned, the velocity equations kX = kJ®
for k = 0 are
—L1s1
L2s12
L3s193 —L2s12 — L3s123 —L3s123
L1c1 + L2c17 + L3c123
L2c12 + L3c123
L3c123
where s123 = sin(91 + 02 + 03), c123 = cos(01 + 09 + 03), and so on. Note that 0X gives
the Cartesian velocities of the origin of the hand frame (at the center of the grippers in
Figure 3.6) with respect to the origin of the base frame {0}, expressed in {0} coordinates.
Now, most industrial robots caimot command
directly, so we must first integrate
these commanded relative joint rates to commanded joint angles
which can be
commanded to the robot at every time step. In practice, the simplest possible integration
scheme works well, assuming a small control time step
In your
0new = 0oId +
MATLAB resolved-rate simulation, assume that the commanded
can be achieved
perfectly by the virtual robot. (Chapters 6 and 9 present dynamics and control material
for which we do not have to make this simplifying assumption.) Be sure to update the
164
Jacobian matrix with the new configuration °new before completing the resolved-rate
calculations for the next time step.
Develop a MATLAB program to calculate the Jacobian matrix and to simulate
resolved-rate control for the planar 3R robot. Given the robot lengths L1 = 4,
= 3,
93}T = {10° 200 300}T and the
and L3 = 2 (in); the initial joint angles 0 =
constant commanded Cartesian rates
= {i
= {0.2 —0.3 _0•21T (mis,
mis, rad/s), simulate for exactly 5 sec, using time steps of exactly dt = 0.1 sec. In
the same program loop, calculate the inverse-statics problem—that is, calculate the
joint torques T = {r1 r2 r3}T (Nm), given the constant commanded Cartesian wrench
{f f ,1z}T = {1 2 31T (N, N, Nm). Also, in the same loop, animate the robot
to the screen during each time step, so that you can watch the simulated motion to verify
that it is correct.
a) For the specific numbers assigned, present five plots (each set on a separate graph,
please):
1. the three active joint rates =
O2 03}T vs. time;
2. the three active joint angles 0 = {0i 02 031T vs. time;
3. the three Cartesian components of
(rad is fine for
that it will fit) vs. time;
4. the Jacobian matrix determinant IJI
time—comment on nearness to
singularities during the simulated resolved-rate motion;
r3}T vs. time.
5. the three active joint torques T =
Carefully label (by hand is fine!) each component on each plot; also, label the axes
with names and units.
b) Check your Jacobian matrix results for the initial and final joint-angle sets by
means of the Corke MATLAB Robotics Toolbox. Try function jacobOQ. Caution:
The toolbox Jacobian functions are for motion of {3} with respect to {0}, not for {H}
with respect to {0} as in the problem assignment. The preceding function gives the
Jacobian result in {0} coordinates; jacobn() would give results in {3} coordinates.
6.2 ACCELERATION OF A RIGID BODY
6.3 MASS DISTRIBUTION
6.4 NEWTON'S EQUATION, EULER'S EQUATION
6.5 ITERATIVE NEWTON—EULER DYNAMIC FORMULATION
6.6 ITERATIVE VS. CLOSED FORM
6.7 AN EXAMPLE OF CLOSED-FORM DYNAMIC EQUATIONS
6.8 THE STRUCTURE OF A MANIPULATOR'S DYNAMIC EQUATIONS
6.9 LAGRANGIAN FORMULATION OF MANIPULATOR DYNAMICS
6.10 FORMULATING MANIPULATOR DYNAMICS IN CARTESIAN SPACE
6.11 INCLUSION OF NONRIGID BODY EFFECTS
6.12 DYNAMIC SIMULATION
6.13 COMPUTATIONAL CONSIDERATIONS
Our study of manipulators so far has focused on kinematic considerations only.
We have studied static positions, static forces, and velocities; but we have never
considered the forces required to cause motion. In this chapter, we consider the
equations of motion for a manipulator—the way in which motion of the manipulator
arises from torques applied by the actuators or from external forces applied to the
Dynamics of mechanisms is a field in which many books have been written.
Indeed, one can spend years studying the field. Obviously, we cannot cover the
material in the completeness it deserves. However, certain formulations of the
dynamics problem seem particularly well suited to application to manipulators. In
particular, methods which make use of the serial-chain nature of manipulators are
natural candidates for our study.
There are two problems related to the dynamics of a manipulator that we wish
to solve. In the first problem, we are given a trajectory point, e,
and ë, and we
wish to find the required vector of joint torques, r. This formulation of dynamics
is useful for the problem of controlling the manipulator (Chapter 10). The second
problem is to calculate how the mechanism wifi move under application of a set of
joint torques. That is, given a torque vector, r, calculate the resulting motion of the
manipulator, g, é, and 0. This is useful for simulating the manipulator.
166
Chapter 6
ACCELERATION OF A RIGID BODY
We now extend our analysis of rigid-body motion to the case of accelerations. At
any instant, the linear and angular velocity vectors have derivatives that are called
the linear and angular accelerations, respectively. That is,
BV =_BV = lim
At-+o
(6.1)
(6.2)
As with velocities, when the reference frame of the differentiation is understood to
be some universal reference frame, {U}, we wifi use the notation
VA — VAORG
WAQA.
(6.4)
Linear acceleration
We start by restating (5.12), an important result from Chapter 5, which describes
the velocity of a vector B
as seen from frame {A} when the origins are coincident:
+ AQB x
The left-hand side of this equation describes how A
origins are coincident, we could rewrite (6.5) as
(6.5)
is changing in time. So, because
(6.6)
This form of the equation wifi be useful when deriving the corresponding acceleration
By differentiating (6.5), we can derive expressions for the acceleration of B
as viewed from {A} when the origins of {A} and {B} coincide:
(6.7)
Now we apply (6.6) twice-—once to the first term, and once to the last term. The
right-hand side of equation (6.7) becomes
(68)
Combining two terms, we get
(6.9)
Section 6.3
Mass distribution
Finally, to generalize to the case in which the origins are not coincident, we add one
term which gives the linear acceleration of the origin of {B}, resulting in the final
general formula:
(6.10)
x (AQ x
A particular case that is worth pointing out is when B
is constant, or
= 0.
(6.11)
In this case, (6.10) simplifies to
+Q X (AQB
.B Q)+Ac2B
(6.12)
We wifi use this result in calculating the linear acceleration of the links of a
manipulator with rotational joints. When a prismatic joint is present, the more
general form of (6.10) wifi be used.
Angular acceleration
Consider the case in which {B} is rotating relative to {A} with AQB and {C} is rotating
relative to {B} with B
To calculate
we sum the vectors in frame {AI:
AQ _AQ
ARBQ C
By differentiating, we obtain
Now, applying (6.6) to the last term of (6.14), we get
(6.15)
We wifi use this result to calculate the angular acceleration of the links of a
MASS DISTRIBUTION
In systems with a single degree of freedom, we often talk about the mass of a rigid
body. In the case of rotational motion about a single axis, the notion of the moment
of inertia is a familiar one. For a rigid body that is free to move in three dimensions,
there are infinitely many possible rotation axes. In the case of rotation about an
arbitrary axis, we need a complete way of characterizing the mass distribution of a
rigid body. Here, we introduce the inertia tensor, which, for our purposes, can be
thought of as a generalization of the scalar moment of inertia of an object.
We shall now define a set of quantities that give information about the
distribution of mass of a rigid body relative to a reference frame. Figure 6.1 shows
a rigid body with an attached frame. Inertia tensors can be defined relative to any
frame, but we wifi always consider the case of an inertia tensor defined for a frame
168
The inertia tensor of an object describes the object's mass distribution.
Here, the vector A P locates the differential volume element, dv.
FIGURE 6.1:
attached to the rigid body. Where it is important, we will indicate, with a leading
superscript, the frame of reference of a given inertia tensor. The inertia tensor
relative to frame {A} is expressed in the matrix form as the 3 x 3 matrix
—'xz 1
(6.16)
where the scalar elements are given by
+z2)pdv,
+ z2)pdv,
+ y2)pdv,
(6.17)
in which the rigid body is composed of differential volume elements, dv, containing
material of density p. Each volume element is located with a vector, A p = {xyzlT
as shown in Fig. 6.1.
The elements
Ifl,, and
are called the mass moments of inertia. Note
that, in each case, we are integrating the mass elements, pdv, times the squares of
the perpendicular distances from the corresponding axis. The elements with mixed
indices are called the mass products of inertia. This set of six independent quantities
will, for a given body, depend on the position and orientation of the frame in which
they are defined. If we are free to choose the orientation of the reference frame, it is
possible to cause the products of inertia to be zero. The axes of the reference frame
when so aligned are called the principal axes and the corresponding mass moments
are the principal moments of inertia.
EXAMPLE 6.1
Find the inertia tensor for the rectangular body of uniform density p with respect to
the coordinate system shown in Fig. 6.2.
First, we compute
Using volume element dv = dx dy dz, we get
fw(2
f f(Y2
+ z2)p dx dy dz
+ z2)wpdy dz
(6.18)
+ z21)
+ h2),
where in is the total mass of the body. Permuting the terms, we can get
by inspection:
+h2)
(6.19)
+ co2).
(6.20)
FIGURE 6.2:
A body of uniform density.
170
We next compute
(6.21)
w212
—4---pdz
-4-wl.
Permuting the terms, we get
(6.22)
(6.23)
Hence, the inertia tensor for this object is
¶(w2 +
(6.24)
As noted, the inertia tensor is a function of the location and orientation of
the reference frame. A well-known result, the parallel-axis theorem, is one way
of computing how the inertia tensor changes under translations of the reference
coordinate system. The parallel-axis theorem relates the inertia tensor in a frame
with origin at the center of mass to the inertia tensor with respect to another
reference frame. Where {C} is located at the center of mass of the body, and {A} is
an arbitrarily translated frame, the theorem can be stated [1] as
A1 _C1
p625
locates the center of mass relative to {A}. The remaining
moments and products of inertia are computed from permutations of x,y, and z in
(6.25). The theorem may be stated in vector—matrix form as
= C1 + in[P
(6.26)
where 13 is the 3 x 3 identity matrix.
EXAMPLE 6.2
Find the inertia tensor for the same solid body described for Example 6.1 when it is
described in a coordinate system with origin at the body's center of mass.
Newton's equation, Euler's equation
Section 6.4
We can apply the parallel-axis theorem, (6.25), where
Next, we fmd
(6.27)
The other elements are found by symmetry. The resulting inertia tensor written in
the frame at the center of mass is
+ h2)
(6.28)
The result is diagonal, so frame {C} must represent the principal axes of this body.
Some additional facts about inertia tensors are as follows:
1. If two axes of the reference frame form a plane of symmetry for the mass
distribution of the body, the products of inertia having as an index the
coordinate that is normal to the plane of symmetry wifi be zero.
2. Moments of inertia must always be positive. Products of inertia may have
either sign.
3. The sum of the three moments of inertia is invariant under orientation changes
in the reference frame.
4. The eigenvalues of an inertia tensor are the principal moments for the body.
The associated eigenvectors are the principal axes.
Most manipulators have links whose geometry and composition are somewhat
complex, so that the application of (6.17) is difficult in practice. A pragmatic option
is actually to measure rather than to calculate the moment of inertia of each link by
using a measuring device (e.g., an inertia pendulum).
NEWTON'S EQUATION, EULER'S EQUATION
wifi consider each link of a manipulator as a rigid body. If we know the
location of the center of mass and the inertia tensor of the link, then its mass
distribution is completely characterized. In order to move the links, we must
accelerate and decelerate them. The forces required for such motion are a function
of the acceleration desired and of the mass distribution of the links. Newton's
equation, along with its rotational analog, Euler's equation, describes how forces,
inertias, and accelerations relate.
172
FIGURE 6.3: A force F acting at the center of mass of a body causes the body to
accelerate at Uc.
Newton's equation
Figure 6.3 shows a rigid body whose center of mass is accelerating with acceleration
In such a situation, the force, F, acting at the center of mass and causing this
acceleration is given by Newton's equation
(6.29)
where m is the total mass of the body.
Euler's equation
Figure 6.4 shows a rigid body rotating with angular velocity cv and with angular
acceleration th. In such a situation, the moment N, which must be acting on the body
to cause this motion, is given by Euler's equation
CIó)
x CIa)
(6.30)
where Cj is the inertia tensor of the body written in a frame, {C}, whoseorigin is
located at the center of mass.
FIGURE 6.4: A moment N is acting on a body, and the body is rotating with velocity
cv and accelerating at th.
Section 6.5
Iterative Newton—Euler dynamic formulation
ITERATIVE NEWTON-EULER DYNAMIC FORMULATION
now consider the problem of computing the torques that correspond to a
given trajectory of a manipulator. We assume we know the position, velocity, and
acceleration of the joints, (0, 0, 0). With this knowledge, and with knowledge of
the kinematics and the mass-distribution information of the robot, we can calculate
the joint torques required to cause this motion. The algorithm presented is based
upon the method published by Luh, Walker, and Paul in [2].
Outward iterations to compute velocities and accelerations
In order to compute inertial forces acting on the links, it is necessary to compute
the rotational velocity and linear and rotational acceleration of the center of mass
of each link of the manipulator at any given instant. These computations wifi be
done in an iterative way, starting with link 1 and moving successively, link by link,
outward to link n.
The "propagation" of rotational velocity from link to link was discussed in
Chapter 5 and is given (for joint i + 1 rotational) by
i+12
wi+1_1i+lR
From (6.15), we obtain the equation for transforming angular acceleration from one
link to the next:
= i+lR
i+lth
'th1 +
(6.32)
When joint i + 1 is prismatic, this simplifies to
= 1+lR 1w1.
(6.33)
The linear acceleration of each link-frame origin is obtained by the application of
(6.12):
x ('co1 x
(6.34)
For prismatic joint i + 1, (6.34) becomes (from (6.10))
xdi+1 1+12 i+1
x (1w1 x
1+12
We also will need the linear acceleration of the center of mass of each link, which
also can be found by applying (6.12):
= 'th1 x
x (1w1 +
(6.36)
Here, we imagine a frame, {C1 }, attached to each link, having its origin located at
the center of mass of the link and having the same orientation as the link frame,
{i}. Equation (6.36) doesn't involve joint motion at all and so is valid for joint i + 1,
regardless of whether it is revolute or prismatic.
Note that the application of the equations to link 1 is especially simple, because
ow0 = °th0
174
The force and torque acting on a link
Having computed the linear and angular accelerations of the mass center of each
link, we can apply the Newton—Euler equations (Section 6.4) to compute the inertial
force and torque acting at the center of mass of each link. Thus we have
= ClIth.
(6.37)
} has its origin at the center of mass of the link and has the same orientation
as the link frame, {i}.
Inward iterations to compute forces and torques
Having computed the forces and torques acting on each link, we now need to
calculate the joint torques that will result in these net forces and torques being
applied to each link.
We can do this by writing a force-balance and moment-balance equation based
on a free-body diagram of a typical link. (See Fig. 6.5.) Each link has forces and
torques exerted on it by its neighbors and in addition experiences an inertial force
and torque. In Chapter 5, we defined special symbols for the force and torque
exerted by a neighbor link, which we repeat here:
= force exerted on link i by link i 1,
= torque exerted on link i by link i — 1.
By summing the forces acting on link i, we arrive at the force-balance
relationship:
Ji+1•
By summing torques about the center of mass and setting them equal to zero,
we arrive at the torque-balance equation:
'N1 =
+ ('Pc.) X
('p1+'
(6.39)
li + 11
FIG U
RE 6.5: The force balance, including inertial forces, for a single manipulator link.
Iterative Newton—Euler dynamic formulation
Section 6.5
Using the result from the force-balance relation (6.38) and adding a few
rotation matrices, we can write (6.39) as
(6.40)
Finally, we can rearrange the force and torque equations so that they appear as
iterative relationships from higher numbered neighbor to lower numbered neighbor:
I,C_1
Ji+1
ii — i+1
(6.42)
These equations are evaluated link by link, starting from link ii and working
inward toward the base of the robot. These inward force iterations are analogous
to the static force iterations introduced in Chapter 5, except that inertial forces and
torques are now considered at each link.
As in the static case, the required joint torques are found by taking the Z
component of the torque applied by one link on its neighbor:
(6.43)
For joint i prismatic, we use
(6.44)
where we have used the symbol r for a linear actuator force.
Note that, for a robot moving in free space, N+lfN+l and N+lliN+l are set
equal to zero, and so the first application of the equations for link n is very simple.
If the robot is in contact with the environment, the forces and torques due to
this contact can be included in the force balance by having nonzero N+1 fN+1 and
The iterative Newton—Euler dynamics algorithm
The complete algorithm for computing joint torques from the motion of the joints
is composed of two parts. First, link velocities and accelerations are iteratively
computed from link 1 out to link n and the Newton—Euler equations are applied
to each link. Second, forces and torques of interaction and joint actuator torques
are computed recursively from link n back to link 1. The equations are summarized
next for the case of all joints rotational:
Chapter 6
Outward iterations: i
: 0 —÷ 5
m &i+1
1+1'
!+1R(ith
_i+1•
x ('cot x 'p1+1) +
(6.47)
i+lp) +
(6.48)
c1÷1
(i+1Wj+l x
(6.49)
Inward iterations: i
(6.46)
i+lp
(6.50)
: 6 —÷ 1
= 'N1
+ 'Fe,
1+1k
(6.51)
x 'F1
'2,.
(6.52)
(6.53)
Inclusion of gravity forces in the dynamics algorithm
The effect of gravity loading on the links can be included quite simpiy by setting
where G has the magnitude of the gravity vector but points in the opposite
direction. This is equivalent to saying that the base of the robot is accelerating
upward with 1 g acceleration. This fictitious upward acceleration causes exactly the
same effect on the links as gravity would. So, with no extra computational expense,
the gravity effect is calculated.
ITERATIVE VS. CLOSED FORM
Equations (6.46) through (6.53) give a computational scheme whereby, given the
joint positions, velocities, and accelerations, we can compute the required joint
torques. As with our development of equations to compute the Jacobian in
Chapter 5, these relations can be used in two ways: as a numerical computational
algorithm, or as an algorithm used analytically to develop symbolic equations.
Use of the equations as a numerical computational algorithm is attractive
because the equations apply to any robot. Once the inertia tensors, link masses, Pc,
vectors, and
matrices are specified for a particular manipulator, the equations
can be applied directly to compute the joint torques corresponding to any motion.
However, we often are interested in obtaining better insight into the structure
of the equations. For example, what is the form of the gravity terms? How does
the magnitude of the gravity effects compare with the magnitude of the inertial
effects? To investigate these and other questions, it is often useful to write closedform dynamic equations. These equations can be derived by applying the recursive
Section 6.7
An example of closed-form dynamic equations
and e. This is analogous to what we
did in Chapter 5 to derive the symbolic form of the Jacobian.
Newton—Euler equations symbolically to e,
AN EXAMPLE OF CLOSED-FORM DYNAMIC EQUATIONS
Here we compute the closed-form dynamic equations for the two-link planar
manipulator shown in Fig. 6.6. For simplicity, we assume that the mass distribution
is extremely simple: All mass exists as a point mass at the distal end of each link.
These masses are in1 and in2.
First, we determine the values of the various quantities that wifi appear in the
recursive Newton—Euler equations. The vectors that locate the center of mass for
each link are
1Pc1
PC2 = 12X2.
Because of the point-mass assumption, the inertia tensor written at the center of
mass for each link is the zero matrix:
C111
C212
There are no forces acting on the end-effector, so we have
The base of the robot is not rotating; hence, we have
th0 =0.
FIGURE 6.6:
Two-link planar manipulator with point masses at distal ends of links.
178
To include gravity forces, we wifi use
The rotation between successive link frames is given by
[ 0.0
i+lR
We now apply equations (6.46) through (6.53).
The outward iterations for link 1 are as follows:
[é1
01 roi
L0 01][0j
r —,n111Ô12 +
+ in1gc1
The outward iterations for link 2 are as follows:
01 +
(6.54)
An example of closed-form dynamic equations
Section 6.7
+ gs1 1
01 E
001]L
+gc1
+ gs12
119152 —
12(91+92)
1191s2 —
+ gc12
1101c2
(6.55)
+ in2gs12 — m212(01
ni21191s2 —
,n71191c2
+ fl12gc12 + 111212(01 +
2N_I 0
The inward iterations for link 2 are as follows:
f2_F2,
(6.56)
[rn91112c291
+ in212gc12 + ,n212(01 +
The inward iterations for link 1 are as follows:
if1 =
,n211s291 —
—s2 0 1
[ c2
rn211c201
+ m2gc12 + in212(91 +
+ rn2gs12 — in219(91
,n11191
1/1=1
[in21112c2ö1 +
+ 'n2l2gc12 + ,n212(01 +
+ in1l1gc1
in 21 11 2s2(91 + 02)2 + in211gs2s12
+rn21112c2(01 +
+ in211gc2c17
(6.57)
180
Extracting the 2 components of the 1n1, we find the joint torques:
+ ,n21112c2 (291
+ d2)
+ (in1 +
—2,n21112s20102 + in212gc12 + (in1 + in2)11gc1,
(6.58)
+ rn212gc17 + in212(91 +
Equations (6.58) give expressions for the torque at the actuators as a function
ofjoint position, velocity, and acceleration. Note that these rather complex functions
arose from one of the simplest manipulators imaginable. Obviously, the closed-form
equations for a manipulator with six degrees of freedom wifi be quite complex.
THE STRUCTURE OF A MANIPULATOR'S DYNAMIC EQUATIONS
It is often convenient to express the dynamic equations of a manipulator in a single
equation that hides some of the details, but shows some of the structure of the
equations.
The state-space equation
When the Newton—Euler equations are evaluated symbolically for any manipulator,
they yield a dynamic equation that can be written in the form
= M(O)O + v(e, e) + G(e),
(6.59)
where M(O) is then x n mass matrix of the manipulator, V(O, 0) is ann x 1 vector
of centrifugal and Coriolis terms, and
is an ii x 1 vector of gravity terms. We
use the term state-space equation because the term
0), appearing in (6.59),
has both position and velocity dependence [3].
Each element of M(0) and G(0) is a complex function that depends on 0, the
position of all the joints of the manipulator. Each element of V(e, 0) is a complex
function of both 0 and 0.
We may separate the various types of terms appearing in the dynamic equations
and form the mass matrix of the manipulator, the centrifugal and Coriolis vector,
and the gravity vector.
EXAMPLE 6.3
M(0), V(0, è),
and G(0) for the manipulator of Section 6.7.
Equation (6.59) defines the manipulator mass matrix, M(0); it is composed of
all those terms which multiply and is a function of 0. Therefore, we have
Give
+ m2) 12,n2 + 1112in2c2 1
+ 21112,n2c2 +
M(0) =
+ 1112,n2c7
(6.60)
Any manipulator mass matrix is symmetric and positive definite, and is, therefore,
always invertible.
The velocity term, V (0, 0), contains all those terms that have any dependence
on joint velocity. Thus, we obtain
V(0, 0) =
[mn2hul2s2
in21112s291
(6.61)
Section 6.8
The structure of a manipulator's dynamic equations
A term like
is caused by a centrifugal force, and is recognized as such
because it depends on the square of a joint velocity. A term such as
is caused by a Coriolis force and wifi always contain the product of two different
joint velocities.
The gravity term, G(e), contains all those terms in which the gravitational
constant, g, appears. Therefore, we have
[in217gc12 + (in1 + in2)11gc1 1
(6.62)
in212gc12
Note that the gravity term depends only on e and not on its derivatives.
The configuration-space equation
By writing the velocity-dependent term, V(O,
in a different form, we can write
the dynamic equations as
= M(e)e + B(O)[éé] + c(e)[e2] + G(O),
(6.63)
where B(O) is a matrix of dimensions n x n(n — 1)/2 of Coriolis coefficients, [OO]
is an n(n — 1)/2 x 1 vector of joint velocity products given by
C(O) is ann x ii matrix of centrifugal coefficients, and
an n x 1 vector given
[92 92
92 ]T
(6.65)
We wifi call (6.63) the configuration-space equation, because the matrices are
functions only of manipulator position [3].
In this form of the dynamic equations, the complexity of the computation is
seen to be in the form of computing various parameters which are a function of only
the manipulator position, 0. This is important in applications (such as computer
control of a manipulator) in which the dynamic equations must be updated as
the manipulator moves. (Equation (6.63) gives a form in which parameters are a
function of joint position only and can be updated at a rate related to how fast the
manipulator is changing configuration.) We will consider this form again with regard
to the problem of manipulator control in Chapter 10.
EXAMPLE 6.4
Give B(0) and C(0) (from (6.63)) for the manipulator of Section 6.7.
For this simple two-link manipulator, we have
{ee] =
(6.66)
182
So we see that
B(O)
= [_2m2J112s2]
(6.67)
C(®) =
[ in21112s2
,n21112s2
(6.68)
LAGRANGIAN FORMULATION OF MANIPULATOR DYNAMICS
The Newton—Euler approach is based on the elementary dynamic formulas (6.29)
and (6.30) and on an analysis of forces and moments of constraint acting between
the links. As an alternative to the Newton—Euler method, in this section we
briefly introduce the Lagrangian dynamic formulation. Whereas the Newton—Euler
formulation might be said to be a "force balance" approach to dynamics, the
Lagrangian formulation is an "energy-based" approach to dynamics. Of course, for
the same manipulator, both will give the same equations of motion. Our statement
of Lagrangian dynamics will be brief and somewhat specialized to the case of a
serial-chain mechanical manipulator with rigid links. For a more complete and
general reference, see [4].
We start by developing an expression for the kinetic energy of a manipulator.
The kinetic energy of the ith link, can be expressed as
11 (iiiTC.Ti
where the first term is kinetic energy due to linear velocity of the link's center
of mass and the second term is kinetic energy due to angular velocity of the link.
The total kinetic energy of the manipulator is the sum of the kinetic energy in the
individual links—that is,
(6.70)
in (6.69) are functions of 0 and 0, so we see that the kinetic energy
of a manipulator can be described by a scalar formula as a function of joint position
and velocity, k(0, 0). In fact, the kinetic energy of a manipulator is given by
k(0, 0) =
(6.71)
where M(0) is the n x ii manipulator mass matrix already introduced in Section 6.8.
An expression of the form of (6.71) is known as a quathatic form [5], since when
expanded out, the resulting scalar equation is composed solely of terms whose
dependence on the is quadratic. Further, because the total kinetic energy must
always be positive, the manipulator mass matrix must be a so-called positive definite
matrix. Positive definite matrices are those having the property that their quadratic
form is always a positive scalar. Equation (6.71) can be seen to be analogous to the
familiar expression for the kinetic energy of a point mass:
(6.72)
Section 6.9
Lagrangian formulation of manipulator dynamics
The fact that a manipulator mass matrix must be positive definite is analogous to
the fact that a scalar mass is always a positive number.
can be expressed as
The potential energy of the ith link,
0gTO
where 0g is the 3 x 1 gravity vector,
is the vector locating the center of mass of
the ith link, and Uref is a constant chosen so that the mmii: urn value of is zero.1
The total potential energy stored in the manipulator is the sum of the potential
energy in the individual links—that is,
(6.74)
Because the
in (6.73) are functions of e, we see that the potential energy
of a manipulator can be described by a scalar formula as a function of joint position,
u(O).
The Lagrangian dynamic formulation provides a means of deriving the equations of motion from a scalar function called the Lagrangian, which is defined as the
difference between the kinetic and potential energy of a mechanical system. In our
notation, the Lagrangian of a manipulator is
(6.75)
The equations of motion for the manipulator are then given by
dtae
(6.76)
where r is the n x 1 vector of actuator torques. In the case of a manipulator, this
equation becomes
k (.)
and U (.) have been dropped for brevity.
EXAMPLE 6.5
The links of an RP manipulator, shown in Fig. 6.7, have inertia tensors
C111[Ixx1
'zzi
'yy2
(6.78)
'zz2]
'Actually, only the partial derivative of the potential energy with respect to 0 wifi appear in the
dynamics, so this constant is arbitrary. This corresponds to defining the potential energy relative to an
arbitrary zero reference height.
184
FIGURE 6.7:
The RP manipulator of Example 6.5.
total mass ni1 and in2. As shown in Fig. 6.7, the center of mass of link 1 is
located at a distance from the joint-i axis, and the center of mass of link 2 is at the
variable distance d2 from the joint-i axis. Use Lagrangian dynamics to determine
the equation of motion for this manipulator.
Using (6.69), we write the kinetic energy of link 1 as
(6.79)
and the kinetic energy of link 2 as
k2 =
(6.80)
Hence, the total kinetic energy is given by
k(O, e) =
(6.81)
Using (6.73), we write the potential energy of link 1 as
= in1l1g sin(91) + in1l1g
(6.82)
and the potential energy of link 2 as
U2 =
sin(91) +
(6.83)
where d2,i,ax is the maximum extension of joint 2. Hence, the total potential energy
u(EJ) =
g(in111
+ ,n2d2) sin(91) ± rn111g +
(6.84)
Section 6i0
Formulating manipulator dynamics in Cartesian space
Next, we take partial derivatives as needed for (6.77):
in2d2
(6.86)
(6.85)
[g(m111 + in2d2) cos(91) 1.
gin2 sin(91)
(6.87)
Finally, substituting into (6.77), we have
+(in111 +rn2d2)gcos(81),
= 1fl2d2
(6.88)
+ 11128 sin(91).
From (6.89), we can see that
M(O) =
[(miii +
r 2,n2d2e1a7
G(O)
V(O, 0) =
—m21291
(6.89)
[ (,n1i1 + m2d2)g cos(91)
6.10
FORMULATING MANIPULATOR DYNAMICS IN CARTESIAN SPACE
Our dynamic equations have been developed in terms of the position and time
derivatives of the manipulator joint angles, or in joint space, with the general form
= M(O)ë + v(e, 0) + G(O).
(6.90)
We developed this equation in joint space because we could use the serial-link
nature of the mechanism to advantage in deriving the equations. In this section,
we discuss the formulation of the dynamic equations that relate acceleration of the
end-effector expressed in Cartesian space to Cartesian forces and moments acting
at the end-effector.
The Cartesian state-space equation
As explained in Chapters 10 and 11, it might be desirable to express the dynamics
of a manipulator with respect to Cartesian variables in the general form [6]
0) +
(6.91)
186
the end-effector of the robot, and
x is an appropriate Cartesian vector representing position and orientation of the
is the Cartesian
end-effector [7]. Analogous to the joint-space quantities,
0) is a vector of velocity terms in Cartesian space, and (0) is
mass matrix,
where .F is a force—torque vector acting on
a vector of gravity terms in Cartesian space. Note that the fictitious forces acting on
the end-effector, .T, could in fact be applied by the actuators at the joints by using
the relationship
(6.92)
where the Jacobian, J(0), is written in the same frame as .T and
usually the tool
frame, {T}.
We can derive the relationship between the terms of (6.90) and those of (6.91)
in the following way. First, we premultiply (6.90) by the inverse of the Jacobian
transpose to obtain
+ J_TV(0 , 0) + J_TG(0),
(6.93)
+ J_TV(0 0) + J_TG(0).
(6.94)
Next, we develop a relationship between joint space and Cartesian acceleration,
starting with the definition of the Jacobian,
(6.95)
(6.96)
and differentiating to obtain
Solving (6.96) for joint-space acceleration leads to
(6.97)
Substituting (6.97) into (6.94), we have
= J_TM(0)J_l.5?
+ J_TV(0, 0) + J_TG(0),
(6.98)
from which we derive the expressions for the terms in the Cartesian dynamics as
M(0) = J_T(0)M(g)J4(0),
0) =
jT (0)(V(0, 0) —
(6.99)
= JT(0)G(0).
Note that the Jacobian appearing in equations (6.100) is written in the same
and x in (6.91); the choice of this frame is arbitrary.2 Note that, when the
manipulator approaches a singularity, certain quantities in the Cartesian dynamics
frames as
become infinite.
2Certain choices could facilitate computation.
Section 6.10
EXAMPLE 6.6
Derive the Cartesian-space form of the dynamics for the two-link planar arm of
Section 6.7. Write the dynamics in terms of a frame attached to the end of the second
link.
For this manipulator, we have abeady obtained the dynamics (in Section 6.7)
and the Jacobian (equation (5.66)), which we restate here:
J(O) = r
(6.100)
[11c2+12 12]
First, compute the inverse Jacobian:
1112s2
Next,
—11c2
(6.101)
1157 ]
obtain the time derivative of the Jacobian:
1(e) = [
(6.102)
[—115292 0]
Using (6.100) and the results of Section 6.7, we get
1122
—(in211c2 + 112212)01
V(® 6)
,n211s291
(21n2l2+n2211c9
+ 11,n2s29192
(6.103)
in2 gc12
When 57 = 0, the manipulator is in a singular position, and some of the
dynamic tenns go to infinity. For example, when = 0 (arm stretched straight out),
the effective Cartesian mass of the end-effector becomes infinite in the X2 direction
of the link-2 tip frame, as expected. In general, at a singular configuration there is a
certain direction, the singular direction in which motion is impossible, but general
motion in the subspace "orthogonal" to this direction is possible [8].
The Cartesian configuration space torque equation
Combining (6.91) and (6.92), we can write equivalent joint torques with the dynamics
expressed in Cartesian space:
= JT(e)(M
6) +
(6.104)
We will find it useful to write this equation in the form
JT (O)M
G(e),
(6.105)
is an ii (a
((9) is a matrix of dimension n x n (n — 1)/2 of Coriolis coefficients, [éè]
1) /2 x 1 vector of joint velocity products given by
(6.106)
0193
((9) is an a x a matrix of centrifugal coefficients, and [(92] is an a x 1 vector given
(6.107)
Note that, in (6.105), G(O) is the same as in the joint-space equation, but in general,
C(O).
B(O) and
EXAMPLE 6.7
(0) (from (6.105)) for the manipulator of Section 6.7.
(0) (0, 0), we find that
If we form the product
(0) and
(0) =
72C2
— — m2L112s2
(6.108)
1 S7
= [ m2 1
6.11
(6.109)
INCLUSION OF NONRIGID BODY EFFECTS
It is important to realize that the dynamic equations we have derived do not
encompass all the effects acting on a manipulator. They include only those forces
which arise from rigid body mechanics. The most important source of forces that are
not included is friction. All mechanisms are, of course, affected by frictional forces.
In present-day manipulators, in which significant gearing is typical, the forces due to
friction can actually be quite large—perhaps equaling 25% of the torque required
to move the manipulator in typical situations.
In order to make dynamic equations reflect the reality of the physical device,
it is important to model (at least approximately) these forces of friction. A very
simple model for friction is viscous friction, in which the torque due to friction is
proportional to the velocity of joint motion. Thus, we have
tfriction =
(6.110)
where v is a viscous-friction constant. Another possible simple model for friction,
Coulomb friction, is sometimes used. Coulomb friction is constant except for a sign
dependence on the joint velocity and is given by
tfrictiofl = c sgn(9),
(6.111)
wherec is a Coulomb-friction constant. The value of c is often taken at one value
when 9 = 0, the static coefficient, but at a lower value, the dynamic coefficient, when
0. Whether a joint of a particular manipulator exhibits viscous or Coulomb
Section 6.12
Dynamic simulation
friction is a complicated issue of lubrication and other effects. A reasonable model
is to include both, because both effects are likely:
(6.112)
It turns out that, in many manipulator joints, friction also displays a dependence
on the joint position. A maj or cause of this effect might be gears that are not perfectly
round—their eccentricity would cause friction to change according to joint position.
So a fairly complex friction model would have the form
tfrictiofl = f(9, 0).
(6.113)
These friction models are then added to the other dynamic terms derived from the
rigid-body model, yielding the more complete model
= M(O)ë + V(O, e) +
+ F(O,
(6.114)
There are also other effects, which are neglected in this model. For example,
the assumption of rigid body links means that we have failed to include bending
effects (which give rise to resonances) in our equations of motion. However, these
effects are extremely difficult to model and are beyond the scope of this book.
(See [9, 10].)
6.12
DYNAMIC SIMULATION
To simulate the motion of a manipulator, we must make use of a model of the
dynamics such as the one we have just developed. Given the dynamics written
in closed form as in (6.59), simulation requires solving the dynamic equation for
acceleration:
0= M1(e)[r — V(e,
0) — G(O)
F(O, b)].
(6.115)
We can then apply any of several known numerical integration techniques to
integrate the acceleration to compute future positions and velocities.
Given initial conditions on the motion of the manipulator, usually in the form
0(0) =
0(0) = 0,
(6.116)
we integrate (6.115) forward in time numerically by steps of size
There are many
methods of performing numerical integration [11]. Here, we introduce the simplest
integration scheme, called Euler integration: Starting with t = 0, iteratively compute
0(t +
= 0(t) +
(6.117)
where, for each iteration, (6.115) is computed to calculate
In this way, the
position, velocity, and acceleration of the manipulator caused by a certain input
torque function can be computed numerically.
Euler integration is conceptually simple, but other, more sophisticated integration techniques are recommended for accurate and efficient simulation [11]. How
190
is an issue that is often discussed. It should be sufficiently
small that breaking continuous time into these small increments is a reasonable
to select the size of
approximation. It should be sufficiently large that an excessive amount of computer
time is not required to compute a simulation.
6.13
Because the dynamic equations of motion for typical manipulators are so complex, it
is important to consider computational issues. In this section, we restrict our attention
to joint-space dynamics. Some issues of computational efficiency of Cartesian
dynamics are discussed in [7, 8].
A historical note concerning efficiency
Counting the number of multiplications and additions for the equations (6.46)— (6.53)
when taking into consideration the simple first outward computation and simple last
inward computation, we get
126n — 99 multiplications,
106n — 92 additions,
where n is the number of links (here, at least two). Although stifi somewhat complex,
the formulation is tremendously efficient in comparison with some previously
suggested formulations of manipulator dynamics. The first formulation of the
dynamics for a manipulator [12, 13] was done via a fairly straightforward Lagrangian
approach whose required computations came out to be approximately [14]
32n4 + 86n3 + 171n2 + 53n — 128 multiplications,
25n4 + 66n3 + 129n2 + 42n
For a typical case, n = 6, the iterative Newton—Euler scheme is about 100
times more efficient! The two approaches must of course yield equivalent equations,
and numeric calculations would yield exactly the same results, but the structure
of the equations is quite different. This is not to say that a Lagrangian approach
cannot be made to produce efficient equations. Rather, this comparison indicates
that, in formulating a computational scheme for this problem, care must be taken
as regards efficiency. The relative efficiency of the method we have presented stems
from posing the computations as iterations from link to link and in the particulars
of how the various quantities are represented [15].
Renaud [16] and Liegois et al. [17] made early contributions concerning
the formulation of the mass-distribution descriptions of the links. While studying
the modeling of human limbs, Stepanenko and Vukobratovic [18] began investigating a "Newton—Euler" approach to dynamics instead of the somewhat more
traditional Lagrangian approach. This work was revised for efficiency by Orin et
al. [19] in an application to the legs of walking robots. Orin's group improved
the efficiency somewhat by writing the forces and moments in the local linkreference frames instead of in the inertial frame. They also noticed the sequential
nature of calculations from one link to the next and speculated that an efficient
recursive formulation might exist. Armstrong [20] and Luh, Walker, and Paul
Section 6.13
[2] paid close attention to details of efficiency and published an algorithm that
is 0(n) in complexity. This was accomplished by setting up the calculations in
an iterative (or recursive) nature and by expressing the velocities and accelerations of the links in the local link frames. Hollerbach [14] and Silver [15] further
explored various computational algorithms. Hollerbach and Sahar [21] showed that,
for certain specialized geometries, the complexity of the algorithm would reduce
further.
Efficiency of dosed form vs. that of iterative form
The iterative scheme introduced in this chapter is quite efficient as a general means
of computing the dynamics of any manipulator, but closed-form equations derived
for a particular manipulator wifi usually be even more efficient. Consider the twolink planar manipulator of Section 6.7. Plugging n = 2 into the formulas given in
Section 6.13, we find that our iterative scheme would require 153 multiplications
and 120 additions to compute the dynamics of a general two-link. However, our
particular two-link arm happens to be quite simple: It is planar, and the masses
are treated as point masses. So, if we consider the closed-form equations that we
worked out in Section 6.7, we see that computation of the dynamics in this form
requires about 30 multiplications and 13 additions. This is an extreme case, because
the particular manipulator is very simple, but it ifiustrates the point that symbolic
closed-form equations are likely to be the most efficient formulation of dynamics.
Several authors have published articles showing that, for any given manipulator,
customized closed-form dynamics are more efficient than even the best of the
general schemes [22—27].
Hence, if manipulators are designed to be simple in the kinematic and dynamic
sense, they wifi have dynamic equations that are simple. We might define a kinematically simple manipulator to be a manipulator that has many (or all) of its link twists
equal to 0°, 90°, or —90° and many of its link lengths and offsets equal to zero. We
might define a dynamically simple manipulator as one for which each link-inertia
tensor is diagonal in frame (C1 }.
The drawback of formulating closed-form equations is simply that it currently
requires a fair amount of human effort. However, symbolic manipulation programs
that can derive the closed-form equations of motion of a device and automatically factor out common terms and perform trigonometric substitutions have been
developed [25, 28—30].
Efficient dynamics for simulation
When dynamics are to be computed for the purpose of performing a numerical
simulation of a manipulator, we are interested in solving for the joint accelerations, given the manipulator's current position and velocity and the input torques.
An efficient computational scheme must therefore address both the computation of the dynamic equations studied in this chapter and efficient schemes for
solving equations (for joint accelerations) and performing numerical integration.
Several efficient methods for dynamic simulation of manipulators are reported
in[31].
192
Memorization schemes
In any computational scheme, a trade-off can be made between computations and
memory usage. In the problem of computing the dynamic equation of a manipulator
(6.59), we have implicitly assumed that, when a value of r is needed, it is computed
as quickly as possible from 0, 0, and 0 at run time. If we wish, we can trade off this
computational burden at the cost of a tremendously large memory by precomputing
(6.59) for all possible 0, O, and 0 values (suitably quantized). Then, when dynamic
information is needed, the answer is found by table lookup.
The size of the memory required is large. Assume that each joint angle range
is quantized to ten discrete values; likewise, assume that velocities and accelerations
are quantized to ten ranges each. For a six-jointed manipulator, the number of cells
in the (0, 0, 0) quantized space is (10 x 10 x 10)6. In each of these cells, there are
six torque values. Assuming each torque value requires one computer word, this
memory size is 6 x 1018 words! Also, note that the table needs to be recomputed for
a change in the mass of the load—or else another dimension needs to be added to
account for all possible loads.
There are many intermediate solutions that trade off memory for computation
in various ways. For example, if the matrices appearing in equation (6.63) were
precomputed, the table would have only one dimension (in 0) rather than three.
After the functions of 0 are looked up, a modest amount of computation (given by
(6.63)) is done. For more details and for other possible parameterizations of this
problem, see [3] and [6].
BIB LIOG RAPHY
[1] I. Shames, Engineering Mechanics, 2nd edition, Prentice-Hall, Englewood Cliffs, NJ,
[2] J.Y.S. Luh, M.W. Walker, and R.P. Paul, "On-Line Computational Scheme for
Mechanical Manipulators," Transactions of the ASME Journal of Dynamic Systems,
Measurement, and Control, 1980.
[3] M. Raibert, "Mechanical Arm Control Using a State Space Memory," SIVIE paper
MS77-750, 1977.
[4] K.R. Symon, Mechanics, 3rd edition, Addison-Wesley, Reading, MA, 1971.
[5] B. Noble, Applied Linear Algebra, Prentice-Hall, Englewood Cliffs, NJ, 1969.
[6] 0. Khatib, "Commande Dynamique dans L'Espace Operatioimel des Robots Manipulateurs en Presence d'Obstacles," These de Docteur-Ingenieur. Ecole Nationale
Superieure de 1'Aeronautique et de L'Espace (ENSAE), Toulouse.
[7] 0. Khatib, "Dynamic Control of Manipulators in Operational Space," Sixth IFTOMM
Congress on Theory of Machines and Mechanisms, New Delhi, December 15—20, 1983.
[8] 0. Khatib, "The Operational Space Formulation in Robot Manipulator Control,"
15th ISIR, Tokyo, September 11—13, 1985.
[9] E. Schmitz, "Experiments on the End-Point Position Control of a Very Flexible
One-Link Manipulator," Unpublished Ph.D. Thesis, Department of Aeronautics and
Astronautics, Stanford University, SUDAAR No. 547, June 1985.
[10] W. Book, "Recursive Lagrangian Dynamics of Flexible Manipulator Arms," International Journal of Robotics Research, Vol. 3, No. 3, 1984.
[11] S. Conte and C. DeBoor, Elementary Numerical Analysis: An Algorithmic Approach,
2nd edition, McGraw-Hill, New York, 1972.
[1.2]
J. Uicker, "On the Dynamic Analysis of Spatial Linkages Using 4 x 4 Matrices,"
Unpublished Ph.D dissertation, Northwestern University, Evanston, IL, 1965.
[13] J. Uicker, "Dynamic Behaviour of Spatial Linkages," ASME Mechanisms, Vol. 5,
No. 68, pp. 1—15.
[14] J.M. Hollerbach, "A Recursive Lagrangian Formulation of Manipulator Dynamics
and a Comparative Study of Dynamics Formulation Complexity," in Robot Motion,
M. Brady et al., Editors, MIIT Press, Cambridge, MA, 1983.
[15] W. Silver, "On the Equivalence of Lagrangian and Newton—Euler Dynamics for
Manipulators," International Journal of Robotics Research, Vol. 1, No. 2, pp. 60—70.
[16] M. Renaud, "Contribution a l'Etude de la Modélisation et de Ia Commande des
Systémes Mécaniques Articulés," These de Docteur-Ingenieur, Université Paul
Sabatier, Toulouse, December 1975.
[17] A. Liegois, W. Khalil, J.M. Dumas, and M. Renaud, "Mathematical Models of Interconnected Mechanical Systems," Symposium on the Theory and Practice of Robots
and Manipulators, Poland, 1976.
[18] Y. Stepanenko and M. Vukobratovic, "Dynamics of Articulated Open-Chain Active
Mechanisms," Math-Biosciences Vol. 28, 1976, pp. 137—170.
[19] D.E. Orin et al, "Kinematic and Kinetic Analysis of Open-Chain Linkages Utilizing
Newton—Euler Methods," Math-Biosciences Vol. 43, 1979, pp. 107—130.
[20] W.W. Armstrong, "Recursive Solution to the Equations of Motion of an N-Link
Manipulator," Proceedings of the 5th World Congress on the Theory of Machines and
Mechanisms, Montreal, July 1979.
[21] J.M. Hollerbach and G. Sahar, "Wrist-Partitioned Inverse Accelerations and Manipulator Dynamics," MIT Al Memo No. 717, April 1983.
[22] T.K. Kanade, P.K. Khosla, and N. Tanaka, "Real-Time Control of the CMU Direct
Drive Arm II Using Customized Inverse Dynamics," Proceedings of the 23rd IEEE
Conference on Decision and Control, Las Vegas, NV, December 1984.
[23] A. Izaguirre and R.P. Paul, "Computation of the Inertial and Gravitational Coefficients of the Dynamic Equations for a Robot Manipulator with a Load," Proceedings
of the 1985 International Conference on Robotics and Automation, pp. 1024—1032, St.
Louis, March 1985.
[24] B. Armstrong, 0. K.hatib, and J. Burdick, "The Explicit Dynamic Model and Inertial
Parameters of the PUMA 560 Arm," Proceedings of the 1986 IEEE International
Conference on Robotics and Automation, San Francisco, April 1986, pp. 510—518.
[25] J.W. Burdick, "An Algorithm for Generation of Efficient Manipulator Dynamic
Equations," Proceedings of the 1986 IEEE International Conference on Robotics and
Automation, San Francisco, April 7—11, 1986, pp. 212—218.
[26] T.R. Kane and D.A. Levinson, "The Use of Kane's Dynamical Equations in
Robotics," The International Journal of Robotics Research, Vol. 2, No. 3, Fall 1983,
pp. 3—20.
[27] M. Renaud, "An Efficient Iterative Analytical Procedure for Obtaining a Robot
Manipulator Dynamic Model," First International Symposium of Robotics Research,
NH, August 1983.
194
[281 W. Schiehlen, "Computer Generation of Equations of Motion," in Computer Aided
Analysis and Optimization of Mechanical System Dynamics, E.J. Haug, Editor,
Springer-Verlag, Berlin & New York, 1984.
[29] G. Cesareo, F. Nicolo, and S. Nicosia, "DYMIR: A Code for Generating Dynamic
Model of Robots," in Advanced Software in Robotics, Elsevier Science Publishers,
North-Holland, 1984.
[30] J. Murray, and C. Neuman, "ARM: An Algebraic Robot Dynamic Modelling Program," IEEE International Conference on Robotics, Atlanta, March 1984.
[31] M. Wailcer and D. Orin, "Efficient Dynamic Computer Simulation of Robotic Mech-
anisms," ASME Journal of Dynamic Systems, Measurement, and Control, Vol. 104,
1982.
6.1 [12] Find the inertia tensor of a right cylinder of homogeneous density with
respect to a frame with origin at the center of mass of the body.
6.2 [3211 Construct the dynamic equations for the two-link manipulator in Section 6.7
when each link is modeled as a rectangular solid of homogeneous density. Each
and and total mass m1.
link has dimensions
6.3 [43] Construct the dynamic equations for the three-link manipulator of Chapter 3,
Exercise 3.3. Consider each link to be a rectangular solid of homogeneous density
and h1 and total mass m1.
with dimensions
6.4 [13] Write the set of equations that correspond to (6.46)—(6.53) for the case where
the mechanism could have sliding joints.
6.5 [30] Construct the dynamic equations for the two-link nonpianar manipulator
shown in Fig. 6.8. Assume that all the mass of the links can be considered as a
point mass located at the distal (outermost) end of the link. The mass values are
in1 and in2, and the link lengths are 11 and 12. This manipulator is like the first two
links of the arm in Exercise 3.3. Assume further that viscous friction is acting at
each joint, with coefficients v1 and v2.
6.6 [32] Derive the Cartesian space form of the dynamics for the two-link planar
manipulator of Section 6.7 in terms of the base frame. Hint: See Example 6.5, but
use the Jacobian written in the base frame.
'Ti,
FIGURE 6.8: Two-link nonpianar manipulator with point masses at distal ends of links.
[18] How many memory locations would be required to store the dynamic
equations of a general three-link manipulator in a table? Quantize each joint's
position, velocity, and acceleration into 16 ranges. Make any assumptions needed.
6.8 [32] Derive the dynamic equations for the two-link manipulator shown in Fig. 4.6.
Link 1 has an inertia tensor given by
Assume that link 2 has all its mass, in2, located at a point at the end-effector.
Assume that gravity is directed downward (opposite Z1).
6.9 [37] Derive the dynamic equations for the three-link manipulator with one
prismatic joint shown in Fig. 3.9. Link 1 has an inertia tensor given by
'yyi
Link 2 has point mass ui2 located at the origin of its link frame. Link 3 has an
inertia tensor given by
'yy3 0
0 'izz3
Assume that gravity is directed opposite
and that viscous friction of magnitude
v1 is active at each joint.
6.10 [35] Derive the dynamic equations in Cartesian space for the manipulator of
Exercise 6.8. Write the equations in frame {2}.
6.11 [20] A certain one-link manipulator has
Assume that this is just the inertia of the link itself. If the motor armature has a
moment of inertia
and the gear ratio is 100, what is the total inertia as seen
from the motor shaft [1]?
6.12 [20] The single-degree-of-freedom "manipulator" in Fig. 6.9 has total mass in = 1,
with the center of mass at
and has inertia tensor
C11El 0 0
L0 0 2
From rest at t = 0, the joint angle °1 moves in accordance with the time function
01(t) = bt + Ct2
in radians. Give the angular acceleration of the link and the linear acceleration of
the center of mass in terms of frame {1} as a function of t.
196
FIGURE 6.9: One-link "manipulator" of Exercise 6.12.
Construct the Cartesian dynamic equations for the two-link nonpianar
manipulator shown in Fig. 6.8. Assume that all the mass of the links can be
6.13 [40]
considered as a point mass located at the distal (outermost) end of the link. The
mass values are in1 and in2, and the link lengths are 11 and 12. This manipulator is
like the first two links of the arm in Exercise 3.3. Also assume that viscous friction
is acting at each joint with coefficients and v2. Write the Cartesian dynamics
in frame {3], which is located at the tip of the manipulator and has the same
orientation as link frame {2}.
6.14 [18] The following equations were derived for a 2-DOF RP manipulator:
+ d2)81 +
+g cos(81)[nii(di
+ 2in2d2d291
+ d7Oi) +
,n2(d2 + (12)]
+ ,n2d2 — ,n1d1d2 — ,n2d282
+ ,n2(d2 + 1)g sin(9i).
Some of the terms are obviously incorrect. Indicate the incorrect terms.
6.15 [28] Derive the dynamic equations for the RP manipulator of Example 6.5, using
the Newton—Euler procedure instead of the Lagrangian technique.
6.16 [25] Derive the equations of motion for the PR manipulator shown in Fig. 6.10.
Neglect friction, but include gravity. (Here, X0 is upward.) The inertia tensors
of the links are diagonal, with moments 'xxi' 'yyl' 'zzi and 'xx2' 'yy2'
centers of mass for the links are given by
2p[0
6.17 [40] The velocity-related terms appearing in the manipulator dynamic equation
can be written as a matrix-vector product—that is,
V(O, e) =
e, e)e,
Programming exercise (Part 6)
FIGURE 6.10:
PR manipulator of Exercise 6.16.
where the in subscript stands for "matrix form." Show that an interesting relationship exists between the time derivative of the manipulator mass matrix and
namely,
M(e) =
0) —
where S is some skew-symmetric matrix.
6.18 [15] Give two properties that any reasonable friction model (i.e., the term F (0, 0)
in (6.114)) would possess.
6.19 [28] Do Exercise 6.5, using Lagrange's equations.
6.20 [28] Derive the dynamic equations of the 2-DOF manipulator of Section 6.7, using
a Lagrangian formulation.
PROGRAMMING EXERCISE (PART 6)
1. Derive the dynamic equations of motion for the three-link manipulator (from
Example 3.3). That is, expand Section 6.7 for the three-link case. The following
numerical values describe the manipulator:
= 17 = 0.Sm,
in1 = 4.6Kg,
in2 = 2.3Kg,
in3 = 1.0Kg,
g = 9.8m1s2.
For the first two links, we assume that the mass is all concentrated at the distal end
of the link. For link 3, we assume that the center of mass is located at the origin of
frame {3}—that is, at the proximal end of the link. The inertia tensor for link 3 is
0.1J
Kg-rn2.
198
The vectors that locate each center of mass relative to the respective link frame
2. Write a simulator for the three-link manipulator. A simple Euler-integration
routine is sufficient for performing the numerical integration (as in Section 6.12).
To keep your code modular, it might be helpful to define the routine
Procedure UPDATE(VAR tau: vec3; VAR period:
theta, thetadot: vec3);
"tau" is the torque command to the manipulator (always zero for this
assignment), "period" is the length of time you wish to advance time (in seconds),
and "theta" and "thetadot" are the state of the manipulator. Theta and thetadot
are updated by "period" seconds each time you call UPDATE. Note that "period"
used in the numerical
would typically be longer than the integration step size,
integration. For example, although the step size for numerical integration might
be 0.001 second, you might wish to print out the manipulator position and velocity
only each 0.1 seconds.
To test your simulation, set the joint-torque commands to zero (for all time) and
perform these tests:
(a) Set the initial position of the manipulator to
[910293]
=[—9000].
Simulate for a few seconds. Is the motion of the manipulator what you would
expect?
(b) Set the initial position of the manipulator to
= [303010].
(c) Introduce some viscous friction at each joint of the simulated manipula= vO,
tor—that is, add a term to the dynamics of each joint in the form
where v = 5.0 newton-meter-seconds for each joint. Repeat test (b) above.
Is the motion what you would expect?
MATLAB EXERCISE 6A
This exercise focuses on the inverse-dynamics analysis (in a resolved-rate control
framework—see MATLAB Exercise 5) for the planar 2-DOF 2R robot. This robot is
the first two R-joints and first two moving links of the planar 3-DOF 3R robot. (See
Figures 3.6 and 3.7; the DH parameters are given in the first two rows of Figure 3.8.)
For the planar 2R robot, calculate the required joint torques (i.e., solve the
inverse-dynamics problem) to provide the commanded motion at every time step in a
resolved-rate control scheme. You can use either numerical Newton—Euler recursion or
the analytical equations from the results of Exercise 6.2, or both.
MATLAB Exercise 6C
L1 = 1.0 m, L9 = 0.5 m; Both links are solid steel with mass density
kg/rn3; both have the width and thickness dimensions w =
5 cm. The
revolute joints are assumed to be perfect, connecting the links at their very edges (not
Given:
7806
physically possible).
The initial angles are 0 =
The (constant) commanded Cartesian velocity is
Simulate motion for 1 sec, with a control time step of 0.01
Present five plots (each set on a separate graph, please):
1. the two joint angles (degrees) 0 =
2. the two joint rates (rad/s)
3. the two joint accelerations (rad/s2)
4. the three Cartesian components of
(mis).
sec.
02}T
vs. time;
so it will
fit) vs. time;
5. the two inverse dynamics joint torques (Nm) T =
r7}T vs.
time.
Carefully label (by hand is fine!) each component on each plot. Also, label the axis
names and units.
Perform this simulation twice. The first time, ignore gravity (the motion plane is
normal to the effect of gravity); the second time, consider gravity g in the negative Y
direction.
MATLAB EXERCISE 6B
This exercise focuses on the inverse-dynamics solution for the planar 3-D OF, 3R robot (of
Figures 3.6 and 3.7; the DII parameters are given in Figure 3.8) for a motion snapshot in
time only. The following fixed-length parameters are given: L1 = 4,
= 3, and L3 = 2
(in). For dynamics, we must also be given mass and moment-of-inertia information:
in1 = 20, in2 = 15, in3
10 (kg),
= 0.5,
= 0.2, and
= 0.1 (kgin2).
Assume that the CG of each link is in its geometric center. Also, assume that gravity acts
in the — V direction in the plane of motion. For this exercise, ignore actuator dynamics
and the joint gearing.
a) Write a MATLAB program to implement the recursive Newton—Euler inversedynamics solution (i.e., given the commanded motion, calculate the required
driving joint torques) for the following motion snapshot in time:
11001
(rad/s)0
10.51
(rad/s2)
13°°J
Check your results in (a) by means
functions rne() and gravloadQ.
of the Corke MATLAB
Robotics Toolbox. Try
MATLAB EXERCISE 6C
This exercise focuses on the forward-dynamics solution for the planar 3-DOF, 3R robot
(parameters from MATLAB Exercise 6B) for motion over time. In this case, ignore
gravity (i.e., assume that gravity acts in a direction normal to the plane of motion). Use
the Corke IVIATLAB Robotics Toolbox to solve the forward-dynamics problem (i.e.,
200
given the commanded driving joint torques, calculate the resulting robot motion) for the
following constant joint torques and the given initial joint angles and initial joint rates:
Itil
1t3J
1201
(Nm, constant)
e0 =
1_600
1°iol
°20
(rad/s)
Perform this simulation for 4 seconds. Try functionfdynQ.
Present two plots for the resulting robot motion (each set on a separate graph,
1. the three joint angles (degrees) 0 =
2. the three joint rates (rad/s)
= {O1
03}T vs. time;
03}T vs. time.
GENERAL CONSIDERATIONS IN PATH DESCRIPTION AND GENERATION
JOINT-SPACE SCHEMES
CARTESIAN-SPACE SCHEMES
GEOMETRIC PROBLEMS WITH CARTESIAN PATHS
PATH GENERATION AT RUN TIME
DESCRIPTION OF PATHS WITH A ROBOT PROGRAMMING LANGUAGE
PLANNING PATHS WHEN USING THE DYNAMIC MODEL
COLLISION-FREE PATH PLANNING
In this chapter, we concern ourselves with methods of computing a trajectory that
describes the desired motion of a manipulator in multidimensional space. Here,
trajectory refers to a time history of position, velocity, and acceleration for each
degree of freedom.
This problem includes the human-interface problem of how we wish to specify
a trajectory or path through space. In order to make the description of manipulator
motion easy for a human user of a robot system, the user should not be required
to write down complicated functions of space and time to specify the task. Rather,
we must allow the capability of specifying trajectories with simple descriptions of
the desired motion, and let the system figure out the details. For example, the user
might want to be able to specify nothing more than the desired goal position and
orientation of the end-effector and leave it to the system to decide on the exact
shape of the path to get there, the duration, the velocity proffle, and other details.
We also are concerned with how trajectories are represented in the computer
after they have been planned. Finally, there is the problem of actually computing the trajectory from the internal representation—or generating the trajectory.
Generation occurs at run time; in the most general case, position, velocity, and
acceleration are computed. These trajectories are computed on digital computers,
so the trajectory points are computed at a certain rate, called the path-update rate.
In typical manipulator systems, this rate lies between 60 and 2000 Hz.
For the most part, we will consider motions of a manipulator as motions of
the tool frame, {T}, relative to the station frame, {S}. This is the same manner
202
Chapter 7
in which an eventual user of the system would think, and designing a path
description and generation system in these terms will result in a few important
advantages.
When we specify paths as motions of the tool frame relative to the station
frame, we decouple the motion description from any particular robot, end-effector,
or workpieces. This results in a certain modularity and would allow the same path
description to be used with a different manipulator—or with the same manipulator,
but a different tool size. Further, we can specify and plan motions relative to a
moving workstation (perhaps a conveyor belt) by planning motions relative to the
station frame as always and, at run time, causing the definition of {S} to be changing
with time.
As shown in Fig. 7.1, the basic problem is to move the manipulator from an
initial position to some desired final position—that is, we wish to move the tool
Note that,
to a desired final value,
frame from its current value,
in general, this motion involves both a change in orientation and a change in the
position of the tool relative to the station.
Sometimes it is necessary to specify the motion in much more detail than
by simply stating the desired final configuration. One way to include more detail
in a path description is to give a sequence of desired via points (intermediate
points between the initial and final positions). Thus, in completing the motion, the
tool frame must pass through a set of intermediate positions and orientations as
described by the via points. Each of these via points is actually a frame that specifies
both the position and orientation of the tool relative to the station. The name
path points includes all the via points plus the initial and final points. Remember
that, although we generally use the term "points," these are actually frames, which
give both position and orientation. Along with these spatial constraints on the
motion, the user could also wish to specify temporal attributes of the motion. For
example, the time elapsed between via points might be specified in the description
of the path.
Usually, it is desirable for the motion of the manipulator to be smooth. For
our purposes, we wifi define a smooth function as a function that is continuous and
has a continuous first derivative. Sometimes a continuous second derivative is also
FIG U RE 7.1: In executing a trajectory, a manipulator moves from its initial position
to a desired goal position in a smooth manner.
Section 7.3
Joint-space schemes
desirable. Rough, jerky motions tend to cause increased wear on the mechanism and
cause vibrations by exciting resonances in the manipulator. In order to guarantee
smooth paths, we must put some sort of constraints on the spatial and temporal
qualities of the path between the via points.
At this point, there are many choices that may be made and, consequently,
a great variety in the ways that paths might be specified and planned. Any
smooth functions of time that pass through the via points could be used to
specify the exact path shape. In this chapter, we wifi discuss a couple of sunpie choices for these functions. Other approaches can be found in [1, 2] and
[13—16].
In this section, we consider methods of path generation in which the path shapes (in
space and in time) are described in terms of functions of joint angles.
Each path point is usually specified in terms of a desired position and orientation of the tool frame, {T}, relative to the station frame, {S}. Each of these
via points is "converted" into a set of desired joint angles by application of the
inverse kinematics. Then a smooth function is found for each of the n joints that
pass through the via points and end at the goal point. The time required for each
segment is the same for each joint so that all joints wifi reach the via point at the
same time, thus resulting in the desired Cartesian position of {T} at each via point.
Other than specifying the same duration for each joint, the determination of the
desired joint angle function for a particular joint does not depend on the functions
for the other joints.
Hence, joint-space schemes achieve the desired position and orientation at the
via points. In between via points, the shape of the path, although rather simple injoint
space, is complex if described in Cartesian space. Joint-space schemes are usually the
easiest to compute, and, because we make no continuous correspondence between
joint space and Cartesian space, there is essentially no problem with singularities of
the mechanism.
Cubic polynomials
Consider the problem of moving the tool from its initial position to a goal position
in a certain amount of time. Inverse kinematics allow the set of joint angles that
correspond to the goal position and orientation to be calculated. The initial position
of the manipulator is also known in the form of a set ofjoint angles. What is required
is a function for each joint whose value at t0 is the initial position of the joint and
whose value at tf is the desired goal position of that joint. As shown in Fig. 7.2,
there are many smooth functions, 9(t), that might be used to interpolate the joint
value.
In making a single smooth motion, at least four constraints on 9(t) are evident.
Two constraints on the function's value come from the selection of initial and
final values:
9(tf) = 9f.
(7.1)
204
FIGURE 7.2:
Several possible path shapes for a single joint.
An additional two constraints are that the function be continuous in velocity, which
in this case means that the initial and final velocity are zero:
6(0)=0,
O(tf) =0.
(7.2)
These four constraints can be satisfied by a polynomial of at least third degree.
(A cubic polynomial has four coefficients, so it can be made to satisfy the four
constraints given by (7.1) and (7.2).) These constraints uniquely specify a particular
cubic. A cubic has the form
0(t) =
+a1t +a2t2 +a3t3,
(7.3)
so the joint velocity and acceleration along this path are clearly
+ 2a2t + 3a3t2,
(7.4)
+ 6a3t
Combining (7.3) and (7.4) with the four desired constraints yields four equations in
0o =
= a0
Solving these equations for the
+ aitf +
(7.5)
we obtain
a0 = 0o,
a1 = 0,
(7.6)
a3 =
Using (7.6), we can calculate the cubic polynomial that connects any initial jointangle position with any desired final position. This solution is for the case when the
joint starts and finishes at zero velocity.
EXAMPLE 7.1
A single-link robot with a rotary joint is motionless at 8 = 15 degrees. It is desired
to move the joint in a smooth manner to 9 = 75 degrees in 3 seconds. Find the
coefficients of a cubic that accomplishes this motion and brings the manipulator to
rest at the goal. Plot the position, velocity, and acceleration of the joint as a function
of time.
Plugging into (7.6), we find that
a0 = 15.0,
a1 =
a2 = 20.0,
(7.7)
—4.44.
Using (7.3) and (7.4), we obtain
9(t) =
15.0 + 20.0t2 — 4.44t3,
8(t) =
40.Ot
= 40.0
13.33t2,
(7.8)
26.66t.
Figure 7.3 shows the position, velocity, and acceleration functions for this motion
sampled at 40 Hz. Note that the velocity proffle for any cubic function is a parabola
and that the acceleration proffle is linear.
Cubic polynomials for a path with via points
far, we have considered motions described by a desired duration and a final goal
point. In general, we wish to allow paths to be specified that include intermediate
via points. If the manipulator is to come to rest at each via point, then we can use
the cubic solution of Section 7.3.
Usually, we wish to be able to pass through a via point without stopping, and
so we need to generalize the way in which we fit cubics to the path constraints.
As in the case of a single goal point, each via point is usually specified in
terms of a desired position and orientation of the tool frame relative to the station
frame. Each of these via points is "converted" into a set of desired joint angles by
application of the inverse kinematics. We then consider the problem of computing
cubics that connect the via-point values for each joint together in a smooth way.
206
Degrees
Seconds
Position
Velocity
—5
—10
—15
—20
—25
—30
—35
—40
Acceleration
FIGURE 7.3: Position, velocity, and acceleration proffles for a single cubic segment
that starts and ends at rest.
If desired velocities of the joints at the via points are known, then we can
construct cubic polynomials as before; now, however, the velocity constraints at each
end are not zero, but rather, some known velocity. The constraints of (7.3) become
(7.9)
The four equations describing this general cubic are
= a0,
+ altf +
(7.10)
+2a2tf
a0 =
(7.11)
Using (7.11), we can calculate the cubic polynomial that connects any initial and
final positions with any initial and final velocities.
If we have the desired joint velocities at each via point, then we simply apply
(7.11) to each segment to find the required cubics. There are several ways in which
the desired velocity at the via points might be specified:
1. The user specifies the desired velocity at each via point in terms of a Cartesian
linear and angular velocity of the tool frame at that instant.
2. The system automatically chooses the velocities at the via points by applying
a suitable heuristic in either Cartesian space or joint space.
3. The system automatically chooses the velocities at the via points in such a way
as to cause the acceleration at the via points to be continuous.
In the first option, Cartesian desired velocities at the via points are "mapped"
to desired joint rates by using the inverse Jacobian of the manipulator evaluated
at the via point. If the manipulator is at a singular point at a particular via point,
then the user is not free to assign an arbitrary velocity at this point. It is a useful
capability of a path-generation scheme to be able to meet a desired velocity that the
user specifies, but it would be a burden to require that the user always make these
specifications. Therefore, a convenient system should include either option 2 or 3
(or both).
In option 2, the system automatically chooses reasonable intermediate velocities, using some kind of heuristic. Consider the path specified by the via points
shown for some joint, 0, in Fig. 7.4.
In Fig. 7.4, we have made a reasonable choice ofjoint velocities at the via points,
as indicated with small line segments representing tangents to the curve at each
via point. This choice is the result of applying a conceptually and computationally
simple heuristic. Imagine the via points connected with straight line segments. If the
208
\813
...e
FIGURE 7.4:
Via points with desired velocities at the points indicated by tangents.
slope of these lines changes sign at the via point, choose zero velocity; if the slope
of these lines does not change sign, choose the average of the two slopes as the via
velocity. In this way, from specification of the desired via points alone, the system
can choose the velocity at each point.
In option 3, the system chooses velocities in such a way that acceleration is
continuous at the via point. To do this, a new approach is needed. In this kind
of spline, set of data1 we replace the two velocity constraints at the connection of
two cubics with the two constraints that velocity be continuous and acceleration be
continuous.
EXAMPLE 7.2
Solve for the coefficients of two cubics that are connected in a two-segment spline
with continuous acceleration at the intermediate via point. The initial angle is
and the goal point is
the via point is
The first cubic is
+ a11t + a12t2 + a13t3,
(7.12)
+ a21t + a22t2 + a23t3.
(7.13)
and the second is
Each cubic wifi be evaluated over an interval starting at t =
and ending at t =
i = 1 or i = 2.
The constraints we wish to enforce are
= °io'
= a10 + alltfj + al2tf1 +
a20,
+ a2ltf2 +
o = a11,
In our usage, the term "spline" simply means a function of time.
(7.14)
o = a21
+ 2a22tf7 +
a11 + 2al2tfl +
2(112
+ 6a13t11 = 2a22.
These constraints specify a linear-equation problem having eight equations and
eight unknowns. Solving for the case tf = tf 1 = tf 2' we obtain
a10 =
120w — 30g —
—89w +39g
a20 = 9k,,
(7.15)
30g —
—129w
+ 60g +
For the general case, involving n cubic segments, the equations that arise from
insisting on continuous acceleration at the via points can be cast in matrix form,
which is solved to compute the velocities at the via points. The matrix turns out to
be tridiagonal and easily solved [4].
Higher-order polynomials
Higher-order polynomials are sometimes used for path segments. For exam-
ple, if we wish to be able to specify the position, velocity, and acceleration
at the beginning and end of a path segment, a quintic polynomial is required,
+a1t +a2t2 +a3t3 +a4t4 +a5t5,
where the constraints are given as
= a0 + altf + a2tf +
(7.16)
210
= a1
+ 2a2tf +
(7.17)
= 2a2,
+ 6a3tf +
These constraints specify a linear set of six equations with six unknowns, whose
solution is
(89f + l200)tf —
(7.18)
+ (l4Of + l690)tf +
(14=
(6&f + 6Ô0)tf —
Various algorithms are available for computing smooth functions (polynomial
or otherwise) that pass through a given set of data points [3, 4]. Complete coverage
is beyond the scope of this book.
Linear function with parabolic blends
Another choice of path shape is linear. That is, we simply interpolate linearly to
move from the present joint position to the final position, as in Fig. 7.5. Remember
that, although the motion of each joint in this scheme is linear, the end-effector in
general does not move in a straight line in space.
FIGURE 7.5: Linear interpolation requiring infinite acceleration.
However, straightforward linear interpolation would cause the velocity to be
discontinuous at the beginning and end of the motion. To create a smooth path
with continuous position and velocity, we start with the linear function but add a
parabolic blend region at each path point.
During the blend portion of the trajectory, constant acceleration is used to
change velocity smoothly. Figure 7.6 shows a simple path constructed in this way.
The linear function and the two parabolic functions are "splined" together so that
the entire path is continuous in position and velocity.
In order to construct this single segment, we will assume that the parabolic
blends both have the same duration; therefore, the same constant acceleration
(modulo a sign) is used during both blends. As indicated in Fig. 7.7, there are many
solutions to the problem—but note that the answer is always symmetric about the
halfway point in time, th, and about the halfway point in position,
The velocity
at the end of the blend region must equal the velocity of the linear section, and so
(7.19)
0b is
the value of 9 at the end of the blend region, and
is the acceleration
acting during the blend region. The value of 9b is given by
(7.20)
FIGURE 7.6:
Linear segment with parabolic blends.
FIGURE 7.7: Linear segment with parabolic
blends.
212
Combining (7.19) and (7.20) and t =
2t11,
we get
9ttb + (Of —
(7.21)
where t is the desired duration of the motion. Given any Of, 00, and t, we can
follow any of the paths given by the choices of 0 and tb that satisfy (7.21).
Usually, an acceleration, 0, is chosen, and (7.21) is solved for the corresponding
tb. The acceleration chosen must be sufficiently high, or a solution wifi not exist.
Solving (7.21) for in terms of the acceleration and other known parameters, we
obtain
l/02t2_40(of_oo)
(7.22)
The constraint on the acceleration used in the blend is
(7.23)
When equality occurs in (7.23) the linear portion has shrunk to zero length and
the path is composed of two blends that connect with equivalent slope. As the
acceleration used becomes larger and larger, the length of the blend region becomes
shorter and shorter. In the limit, with infinite acceleration, we are back to the simple
linear-interpolation case.
EXAMPLE 7.3
For the same single-segment path discussed in Example 7.1, show two examples of
a linear path with parabolic blends.
Figure 7.8(a) shows one possibility where 0 was chosen quite high. In this
case we quickly accelerate, then coast at constant velocity, and then decelerate.
Figure 7.8(b) shows a trajectory where acceleration is kept quite low, so that the
linear section almost disappears.
Linear function with parabolic blends for a path with via points
We now consider linear paths with parabolic blends for the case in which there are
an arbitrary number of via points specified. Figure 7.9 shows a set of joint-space via
points for some joint 8. Linear functions connect the via points, and parabolic blend
regions are added around each via point.
We will use the following notation: Consider three neighboring path points,
which we will call points j, k, and 1. The duration of the blend region at path point
k is tk. The duration of the linear portion between points j and k is tjk. The overall
duration of the segment connecting points j and k is tdjk. The velocity during the
linear portion is 0jk' and the acceleration during the blend at point j is
See Fig. 7.9
for an example.
As with the single-segment case, there are many possible solutions, depending
on the value of acceleration used at each blend. Given all the path points 0k' the
desired durations tdjk, and the magnitude of acceleration to use at each path point
Section 7.3
65 —
40 —
Deg/sec
25 —
Deg/sec2
—12
—24
—36
ISeconds
FIG U RE 7.8: Position, velocity, and acceleration profiles for linear interpolation with
parabolic blends. The set of curves on the left is based on a higher acceleration
during the blends than is that on the right.
we can compute the blend times
from the equations
For interior path points, this follows simply
SGN(9k1 —
— 0jk
(7.24)
214
ft—tdl2
FIGURE 7.9: Multisegment linear path with blends.
The first and last segments must be handled slightly differently, because an entire
blend region at one end of the segment must be counted in the total segment's time
duration.
For the first segment, we solve for t1 by equating two expressions for the
velocity during the linear phase of the segment:
=91t1.
t12 —
This can be solved for t1, the blend time at the initial point; then
computed:
(7.25)
and t12 are easily
= SGN(02 —
2(82 — Oi)
(7.26)
tl2 =
Likewise, for the last segment (the one connecting points n —1 and n), we have
(7.27)
which leads to the solution
td(fl_1),l
d(n—1)n
(7.28)
td(n_1),j
td(fl_1);j
Using (7.24) through (7.28), we can solve for the blend times and velocities for
a multisegment path. Usually, the user specifies only the via points and the desired
duration of the segments. In this case, the system uses default values for acceleration
for each joint. Sometimes, to make things even simpler for the user, the system
wifi calculate durations based on default velocities. At all blends, sufficiently large
acceleration must be used so that there is sufficient time to get into the linear portion
of the segment before the next blend region starts.
EXAMPLE 7.4
The trajectory of a particular joint is specified as follows: Path points in degrees:
10, 35, 25, 10. The duration of these three segments should be 2, 1, 3 seconds,
respectively. The magnitude of the default acceleration to use at all blend points is
50 degrees/second2. Calculate all segment velocities, blend times, and linear times.
For the first segment, we apply (7.26) to find
(7.29)
50.0.
Applying (7.26) to calculate the blend time at the initial point, we get
2(35—10)
=2—
= 0.27.
(7.30)
The velocity, p12' is calculated from (7.26) as
= 2 —0.5(0.27)
= 13.50.
(7.31)
The velocity, 073, is calculated from (7.24) as
= —10.0.
(7.32)
Next, we apply (7.24) to find
(7.33)
—50.0.
Then t2 is calculated from (7.24), and we get
—10.0 — 13.50
—50.0
= 0.47.
(7.34)
The linear-portion length of segment 1 is then calculated from (7.26):
2 —0.27
1.50.
(7.35)
Next, from (7.29), we have
(7.36)
216
So, for the last segment, (7.28) is used to compute t4, and we have
t4 = 3 —
The velocity,
2(10—25)
= 0.102.
(7.37)
is calculated from (7.28) as
= —5.10.
(7.38)
Next, (7.24) is used to obtain
= 50.0.
(7.39)
Then t3 is calculated from (7.24):
—5.10 —(—10.0)
= 0.098.
(7.40)
Finally, from (7.24), we compute
= 0.716,
0.012 = 2.849.
(7.41)
(7.42)
The results of these computations constitute a "plan" for the trajectory. At execution
time, these numbers would be used by the path generator to compute values of 9, 9,
and 9 at the path-update rate.
In these linear-parabolic-blend splines, note that the via points are not actually
reached unless the manipulator comes to a stop. Often, when acceleration capability
is sufficiently high, the paths wifi come quite close to the desired via point. If we
wish to actually pass through a point, by coming to a stop, the via point is simply
repeated in the path specification.
If the user wishes to specify that the manipulator pass exactly through a via
point without stopping, this specification can be accommodated by using the same
formulation as before, but with the following addition: The system automatically
replaces the via point through which we wish the manipulator to pass with two
pseudo via points, one on each side of the original (as in Fig. 7.10). Then path
generation takes place as before. The original via point wifi now lie in the linear
region of the path connecting the two pseudo via points. In addition to requesting
that the manipulator pass exactly through a via point, the user can also request that
it pass through with a certain velocity. If the user does not specify this velocity, the
system chooses it by means of a suitable heuristic. The term through point might
be used (rather than via point) to specify a path point through which we force the
manipulator to pass exactly.
As was mentioned in Section 7.3, paths computed in joint space can ensure that via
and goal points are attained, even when these path points were specified by means of
Section 7.4
Cartesian-space schemes
Pseudo via points
Original via
FIGURE 7.10:
Use of pseudo via points to create a "through" point.
Cartesian frames. However, the spatial shape of the path taken by the end-effector
is not a straight line through space; rather, it is some complicated shape that depends
on the particular kinematics of the manipulator being used. In this section, we
consider methods of path generation in which the path shapes are described in terms
of functions that compute Cartesian position and orientation as functions of time. In
this way, we can also specify the spatial shape of the path between path points. The
most common path shape is a straight line, but circular, sinusoidal, or other path
could be used.
Each path point is usually specified in terms of a desired position and
orientation of the tool frame relative to the station frame. In Cartesian-based
path-generation schemes, the functions splined together to form a trajectory are
functions of time that represent Cartesian variables. These paths can be plaimed
directly from the user's definition of path points, which are {T} specifications relative
to {S}, without first performing inverse kinematics. However, Cartesian schemes
are more computationally expensive to execute, because, at run time, inverse kinematics must be solved at the path-update rate—that is, after the path is generated
in Cartesian space, as a last step the inverse kinematic calculation is performed to
calculate desired joint angles.
Several schemes for generating Cartesian paths have been proposed in literature from the research and industrial robotics community [1, 2]. In the following
section, we introduce one scheme as an example. In this scheme, we are able to use
the same linear/parabolic spliner that we developed for the joint-space case.
shapes
Cartesian straight-line motion
Often, we would like to be able to specify easily a spatial path that causes the tip
of the tool to move through space in a straight line. Obviously, if we specify many
218
closely separated via points lying on a straight line, then the tool tip wifi appear to
follow a straight line, regardless of the choice of smooth function that interconnects
the via points. However, it is much more convenient if the tool follows straight-line
paths between even widely separated via points. This mode of path specification
and execution is called Cartesian straight-line motion. Defining motions in terms
of straight lines is a subset of the more general capability of Cartesian motion, in
which arbitrary functions of Cartesian variables as functions of time could be used to
specify a path. In a system that allowed general Cartesian motion, such path shapes
as ellipses or sinusoids could be executed.
In planning and generating Cartesian straight-line paths, a spline of linear
functions with parabolic blends is appropriate. During the linear portion of each
segment, all three components of position change in a linear fashion, and the endeffector wifi move along a linear path in space. However, if we are specifying the
orientation as a rotation matrix at each via point, we cannot linearly interpolate its
elements, because doing so would not necessarily result in a valid rotation matrix
at all times. A rotation matrix must be composed of orthonormal columns, and this
condition would not be guaranteed if it were constructed by linear interpolation
of matrix elements between two valid matrices. Instead, we will use another
representation of orientation.
As stated in Chapter 2, the so-called angle—axis representation can be used
to specify an orientation with three numbers. If we combine this representation
of orientation with the 3 x 1 Cartesian-position representation, we have a 6 x 1
representation of Cartesian position and orientation. Consider a via point specified
relative to the station frame as
That is, the frame (A) specifies a via point with
position of the end-effector given by SPAORG and orientation of the end-effector
given by R. This rotation matrix can be converted to the angle—axis representation
ROT(SKA, 9sA)—or simply SKA. We wifi use the symbol x to represent this 6 x 1
vector of Cartesian position and orientation. Thus, we have
= [5P
(7.43)
where SKA is formed by scaling the unit vector
by the amount of rotation, 0SA•
If every path point is specified in this representation, we then need to describe spline
functions that smoothly vary these six quantities from path point to path point as
functions of time. If linear splines with parabolic blends are used, the path shape
between via points will be linear. When via points are passed, the linear and angular
velocity of the end-effector are changed smoothly.
Note that, unlike some other Cartesian-straight-line-motion schemes that have
been proposed, this method does not guarantee that rotations occur about a single
"equivalent axis" in moving from point to point. Rather, our scheme is a simple
one that provides smooth orientation changes and allows the use of the same
mathematics we have already developed for planning joint-interpolated trajectories.
One slight complication arises from the fact that the angle—axis representation
of orientation is not unique—that is,
(5KA 0SA) = (5KA 9SA + n360°),
(744)
Section 7.5
Geometric problems with Cartesian paths
B(—2)
Sri-
FIGURE 7.11:
Choosing angle—axis representation to minimize rotation.
where n is any positive or negative integer. In going from a via point (A} to a via
point {B}, the total amount of rotation should be minimized. If our representation
of the orientation of {A} is given as S KA, we must choose the particular 5KB such
is minimized. For example, Fig. 7.11 shows four different possible
that I5KB
and their relation to the given SKA. The difference vectors (broken lines)
are compared to learn which SKB which will result in minimum rotation—in this
case, SKB(l).
Once we select the six values of x for each via point, we can use the same
mathematics we have already developed for generating splines that are composed of
linear and parabolic sections. However, we must add one more constraint: The blend
times for each degree of freedom must be the same. This wifi ensure that the resultant
motion of all the degrees of freedom will be a straight line in space. Because all blend
times must be the same, the acceleration used during the blend for each degree of
freedom wifi differ. Hence, we specify a duration of blend, and, using (7.24), we
compute the needed acceleration (instead of the other way around). The blend time
can be chosen so that a certain upper bound on acceleration is not exceeded.
Many other schemes for representing and interpolating the orientation portion
of a Cartesian path can be used. Among these are the use of some of the other
3 x 1 representations of orientation introduced in Section 2.8. For example, some
industrial robots move along Cartesian straight-line paths in which interpolation of
orientation is done by means of a representation similar to Z—Y—Z Euler angles.
a continuous correspondence is made between a path shape described in
Cartesian space and joint positions, Cartesian paths are prone to various problems
relating to workspace and singularities.
220
FIG URE 7.12:
Cartesian-path problem of type 1.
Problems of type 1: intermediate points unreachable
Although the initial location of the manipulator and the final goal point are both
within the manipulator workspace, it is quite possible that not all points lying on
a straight line connecting these two points are in the workspace. As an example,
consider the planar two-link robot shown in Fig. 7.12 and its associated workspace.
In this case, link 2 is shorter than link 1, so the workspace contains a hole in the
middle whose radius is the difference between link lengths. Drawn on the workspace
is a start point A and a goal point B. Moving from A to B would be no problem
in joint space, but if a Cartesian straight-line motion were attempted, intermediate
points along the path would not be reachable. This is an example of a situation in
which a joint-space path could easily be executed, but a Cartesian straight-line path
would fail.2
Problems of type 2: high joint rates near singularity
saw in Chapter 5 that there are locations in the manipulator's workspace
where it is impossible to choose finite joint rates that yield the desired velocity
of the end-effector in Cartesian space. It should not be surprising, therefore, that
there are certain paths (described in Cartesian terms) which are impossible for the
manipulator to perform. If, for example, a manipulator is following a Cartesian
straight-line path and approaches a singular configuration of the mechanism, one
or more joint velocities might increase toward infinity. Because velocities of the
2Some robot systems would notify the user of a problem before moving the manipulator; in others,
motion would start along the path until some joint reaches its limit, at which time manipulator motion
would be halted.
FIGURE 7.13:
Cartesian-path problem of type 2.
mechanism are upper bounded, this situation usually results in the manipulator's
deviating from the desired path.
As an example, Fig. 7.13 shows a planar two-link (with equal link lengths)
moving along a path from point A to point B. The desired trajectory is to move the
end tip of the manipulator at constant linear velocity along the straight-line path.
In the figure, several intermediate positions of the manipulator have been drawn to
help visualize its motion. All points along the path are reachable, but as the robot
goes past the middle portion of the path, the velocity of joint one is very high. The
closer the path comes to the joint-one axis, the faster this rate wifi be. One approach
is to scale down the overall velocity of the path to a speed where all joints stay within
their velocity capabilities. In this way, the desired temporal attributes of the path
might be lost, but at least the spatial aspect of the trajectory definition is adhered to.
Problems of type 3: start and goal reachable in different solutions
A third kind of problem that could arise is shown in Fig. 7.14. Here, a planar two-link
with equal link lengths has joint limits that restrict the number of solutions with
which it can reach a given point in space. In particular, a problem will arise if the
goal point cannot be reached in the same physical solution as the robot is in at the
start point. In Fig. 7.14, the manipulator can reach all points of the path in some
solution, but not in any one solution. In this situation, the manipulator trajectory
planning system can detect this problem without ever attempting to move the robot
along the path and can signal an error to the user.
To handle these problems with paths specified in Cartesian space, most
industrial manipulator-control systems support both joint-space and Cartesian-space
222
FIGURE 7.14: Cartesian-path problem of type 3.
path generation. The user quickly learns that, because of the difficulties with
Cartesian paths, joint-space paths should be used as the default, and Cartesian-space
paths should be used only when actually needed by the application.
At run time, the path-generator routine constructs the trajectory, usually in terms
of 9, 9, and 9, and feeds this information to the manipulator's control system. This
path generator computes the trajectory at the path-update rate.
Generation of joint-space paths
The result of having planned a path by using any of the splining methods mentioned
in Section 7.3 is a set of data for each segment of the trajectory. These data are used
by the path generator at run time to calculate 9, 9, and 9.
In the case of cubic splines, the path generator simply computes (7.3) as t is
advanced. When the end of one segment is reached, a new set of cubic coefficients
is recalled, t is set back to zero, and the generation continues.
In the case of linear splines with parabolic blends, the value of time, t, is
checked on each update to determine whether we are currently in the linear or the
blend portion of the segment. In the linear portion, the trajectory for each joint is
calculated as
(7.45)
Path generation at run time
Section 7.6
where t is the time since the jth via point and
was calculated at path-planning
time from (7.24). In the blend region, the trajectory for each joint is calculated as
9jk + &ktj,Ib,
and tik were calculated at path-planning time by equations (7.24)
through (7.28). This continues, with t being reset to 21tk when a new linear segment
is entered, until we have worked our way through all the data sets representing the
path segments.
where OJk, 9k'
Generation of Cartesian-space paths
For the Cartesian-path scheme presented in Section 7.4, we use the path generator
for the linear spline with parabolic blends path. However, the values computed
represent the Cartesian position and orientation rather than joint-variable values,
so we rewrite (7.45) and (7.46) with the symbol x representing a component of the
Cartesian position and orientation vector. In the linear portion of the segment, each
degree of freedom in x is calculated as
(7.47)
I = 0,
time by using an equation analogous to (7.24). In the blend region, the trajectory
for each degree of freedom is calculated as
1••
where the quantities
Xk, ti, and tik were computed at plan time, just as in the
joint-space case.
Finally, this Cartesian trajectory
must be converted into equivalent joint-space quantities. A complete analytical solution to this problem would use
the inverse kinematics to calculate joint positions, the inverse Jacobian for velocities,
and the inverse Jacobian plus its derivative for accelerations [5]. A simpler way often
used in practice is as follows: At the path-update rate, we convert x into its equivalent frame representation,
We then use the SOLVE routine (see Section 4.8)
to calculate the required vector of joint angles, e. Numerical differentiation is then
Chapter 7
used to compute
Thus, the algorithm is
e(t) =
= e(t) — O(t —
e(t)
Then
(749)
= O(t)—O(t—St)
e are supplied to the manipulator's control system.
In Chapter 12, we will discuss robot prograimning languages further. Here, we wifi
ifiustrate how various types of paths that we have discussed in this chapter might be
specified in a robot language. In these examples, we use the syntax of AL, a robot
programming language developed at Stanford University [6].
The symbols A, B, C, and D stand for variables of type "frame" in the
AL-language examples that follow. These frames specify path points that we wifi
assume to have been taught or textually described to the system. Assume that the
manipulator begins in position A. To move the manipulator in joint-space mode
along linear-parabolic-blend paths, we could say
move ARM to C with duration = 3*seconds;
To move to the same position and orientation in a straight line we could say
move ARM to C linearly with duration = 3*seconds;
where the keyword "linearly" denotes that Cartesian straight-line motion is to be
If duration is not important, the
use a default velocity—that is,
used.
wifi
user can omit this specification, and the system
move ARM to C;
A via point can be added, and we can write
move ARM to C via B;
or a whole set of via points might be specified by
move ARM to C via B,A,D;
Note that in
move ARM to C via B with duration = 6*seconds;
the duration is given for the entire motion. The system decides how to split this
duration between the two segments. It is possible in AL to specify the duration of a
single segment—for example, by
move ARM to C via B where duration = 3*seconds;
The first segment which leads to point B wifi have a duration of 3 seconds.
Usually, when paths are planned, we use a default or a maximum acceleration at each
blend point. Actually, the amount of acceleration that the manipulator is capable
3This differentiation can be done noncausally for preplanned paths, resulting in better-quality e and
0. Also, many control systems do not require a 0 input, and so it would not be computed.
of at any instant is a function of the dynamics of the arm and the actuator limits.
Most actuators are not characterized by a fixed maximum torque or acceleration,
but rather by a torque—speed curve.
When we plan a path assuming there is a maximum acceleration at each joint
or along each degree of freedom, we are making a tremendous simplification. In
order to be careful not to exceed the actual capabilities of the device, this maximum
acceleration must be chosen conservatively. Therefore, we are not making full
use of the speed capabilities of the manipulator in paths planned by the methods
introduced in this chapter.
We might ask the following question: Given a desired spatial path of the
end-effector, find the timing information (which turns a description of a spatial path
into a trajectory) such that the manipulator reaches the goal point in minimum time.
Such problems have been solved by numerical means [7, 8]. The solution takes both
the rigid-body dynamics and actuator speed—torque constraint curves into account.
It would be extremely convenient if we could simply tell the robot system what
the desired goal point of the manipulator motion is and let the system determine
where and how many via points are required so that the goal is reached without
the manipulator's hitting any obstacles. In order to do this, the system must have
models of the manipulator, the work area, and all potential obstacles in the area. A
second manipulator could even be working in the same area; in, that case, each arm
would have to be considered a moving obstacle for the other.
Systems that plan coffision-free paths are not available commercially. Research
in this area has led to two competing principal techniques and to several variations and combinations thereof. One approach solves the problem by forming a
connected-graph representation of the free space and then searching the graph for a
coffision-free path [9—11, 17, 18]. Unfortunately, these techniques have exponential
complexity in the number of joints in the device. The second approach is based on
creating artificial potential fields around obstacles, which cause the manipulator(s)
to avoid the obstacles while they are drawn toward an artificial attractive pole at
the goal point [12]. Unfortunately, these methods generally have a local view of the
environment and are subject to becoming "stuck" at local minima of the artificial
field.
[1] R.P. Paul and H. Zong, "Robot Motion Trajectory Specification and Generation,"
2nd International Symposium on Robotics Research, Kyoto, Japan, August 1984.
[2] R. Taylor, "Planning and Execution of Straight Line Manipulator Trajectories," in
Robot Motion, Brady et al., Editors, MIT Press, Cambridge, MA, 1983.
[3] C. DeBoor, A Practical Guide to Splines, Springer-Verlag, New York, 1978.
[4] D. Rogers and J.A. Adams, Mathematical Elements for Computer Graphics, McGrawHill, New York, 1976.
[6] R. Goldman, Design of an Interactive Manipulator Programming Environment, UMI
Research Press, Ann Arbor, MI, 1985.
226
[7] J. Bobrow, S. Dubowsky, and J. Gibson, "On the Optimal Control of Robotic Manip-
ulators with Actuator Constraints," Proceedings of the American Control Conference,
June 1983.
[8] K. Shin and N. McKay, "Ivlinimum-Time Control of Robotic Manipulators with Geometric Path Constraints," IEEE Transactions on Automatic Control, June 1985.
[9] T. Lozano-Perez, "Spatial Planning: A Configuration Space Approach," AT Memo
605, MIT Artificial Intelligence Laboratory, Cambridge, IVIA, 1980.
[10] T. Lozano-Perez, "A Simple Motion Planning Algorithm for General Robot Manipulators," IEEE Journal of Robotics and Automation, Vol. RA-3, No. 3, June 1987.
[11] R. Brooks, "Solving the Find-Path Problem by Good Representation of Free Space,"
IEEE Transactions on Systems, Man, and Cybernetics, SMC-13:190—197, 1983.
[12] 0. Khatib, "Real-Time Obstacle Avoidance for Manipulators and Mobile Robots,"
The International Journal of Robotics Research, Vol. 5, No. 1, Spring 1986.
[13] R.P. Paul, "Robot Manipulators: Mathematics, Programming, and Control," MIT
Press, Cambridge, MA, 1981.
[14] R. Castain and R.P. Paul, "An Online Dynamic Trajectory Generator," The International Journal of Robotics Research, Vol. 3, 1984.
[15] C.S. Liii and P.R. Chang, "Joint Trajectory of Mechanical Manipulators for Cartesian
Path Approximation," IEEE Transactions on Systems, Man, and cybernetics, Vol.
SMC-13, 1983.
[161 C.S. Lin, P.R. Chang, and J.Y.S. Luh, "Formulation and Optimization of Cubic Polynomial Joint Trajectories for Industrial Robots," IEEE Transactions on Automatic
Control, Vol. AC-28, 1983.
[17] L. Kavraki, P. Svestka, J.C. Latombe, and M. Overmars, "Probabilistic Roadmaps for
Path Planning in High-Dimensional Configuration Spaces," IEEE Transactions on
Robotics and Automation, 12(4): 566—580, 1996.
[18] J. Barraquand, L. Kavraki, J.C. Latombe, T.Y. Li, R. Motwani, and P. Raghavan,
"A Random Sampling Scheme for Path Planning," International Journal of Robotics
Research, 16(6): 759—774, 1997.
[8] How many individual cubics are computed when a six-jointed robot moves
along a cubic spline path through two via points and stops at a goal point? How
many coefficients are stored to describe these cubics?
7.2 [13] A single-link robot with a rotary joint is motionless at9 =
It is desired to
move the joint in a smooth manner to 8 = 80° in 4 seconds. Find the coefficients
of a cubic which accomplishes this motion and brings the arm to rest at the goal.
Plot the position, velocity, and acceleration of the joint as a function of time.
7.3 [14] A single-link robot with a rotary joint is motionless at 9 = —5°. It is desired
to move the joint in a smooth manner to 8 = 80° in 4 seconds and stop smoothly.
Compute the corresponding parameters of a linear trajectory with parabolic
blends. Plot the position, velocity, and acceleration of the joint as a function of
7.4 [30] Write a path-planning software routine that implements (7.24) through (7.28)
in a general way for paths described by an arbitrary number of path points. For
example, this routine could be used to solve Example 7.4.
7.5 [18] Sketch graphs of position, velocity, and acceleration for the two-segment
continuous-acceleration spline given in Example 7.2. Sketch them for a joint for
which = 5.0°,
= 15.0°, = 40.0°, and each segment lasts 1.0 second.
7.6 [18] Sketch graphs of position, velocity, and acceleration for a two-segment spline
where each segment is a cubic, using the coefficients as given in (7.11). Sketch
them for a joint where = 5.0° for the initial point,
= 15.0° is a via point,
and 0g = 40.0° is the goal point. Assume that each segment has a duration of 1.0
second and that the velocity at the via point is to be 17.5 degrees/second.
7.7 [20] Calculate 012,
and t3 for a two-segment linear spline with parabolic
blends. (Use (7.24) through(7.28).) Forthis joint,01 = 5.0°, 02 = 15.0°, 93 = 40.0°.
Assume that td12 = td23 = 1.0 second and that the default acceleration to use
during blends is 80 degrees/second2. Sketch plots of position, velocity, and
acceleration of 9.
7.8 [18] Sketch graphs of position, velocity, and acceleration for the two-segment
= —10.0°, and each segment lasts 2.0 seconds.
7.9 [18] Sketch graphs of position, velocity, and acceleration for a two-segment spline
them for a joint where = 5.00 for the initial point,
= —10.0° is the goal point. Assume that each segment has a duration of
2.0 seconds and that the velocity at the via point is to be 0.0 degrees/second.
7.10 [20] Calculate
blends. (Use (7.24) through (7.28).) For this joint,
= 5.0°, = 15.0°, 03 =
—10.0°. Assume that tdl2 = td23 = 2.0 seconds and that the default acceleration
to use during blends is 60 degrees/second2. Sketch plots of position, velocity, and
acceleration of 0.
7.11 [6] Give the 6 x 1 Cartesian position and orientation representation S XG that is
= [10.0 20.0 3001T•
equivalent to
= ROT(2, 30°) and
7.12 [6] Give the T that is equivalent to the 6 x 1 Cartesian position and orientation
representation SXG = [5.0 —20.0 10.0 45.0 0.0
Write a program that uses the dynamic equations from Section 6.7 (the
two-link planar manipulator) to compute the time history of torques needed to
7.13 [30]
move the arm along the trajectory of Exercise 7.8. What are the maximum torques
required and where do they occur along the trajectory?
7.14 [32] Write a program that uses the dynamic equations from Section 6.7 (the
move the arm along the trajectory of Exercise 7.8. Make separate plots of the
joint torques required due to inertia, velocity terms, and gravity.
7.15 [22] Do Example 7.2 when tf1
tf2.
7.16 [25] We wish to move a single joint from Oo to
starting from rest, ending at rest,
in time tf. The values of 00 and
are given, but we wish to compute tf so that
are given positive
< 9niax and
< 0max for all t, where
constants. Use a single cubic segment, and give an expression for tf and for the
cubic's coefficients.
7.17 [10] A single cubic trajectory is given by
10 + 90t2 — 60t3
and is used over the time interval from t = 0 to t =
final positions, velocities, and accelerations?
What are the starting and
228
7.18 [12] A single cubic trajectory is given by
8(t) = 10 + 90t2 — 60t3
7.19 [13] A single cubic trajectory is given by
+ 5t + 70t2
and is used over the time interval from t = 0 to t
7.20 [15] A single cubic trajectory is given by
45t3
1. What are the starting and
10 + 5t + 70t2 — 45t3
and is used over the time interval from t = 0 to t = 2. What are the starting and
PROGRAMMING EXERCISE (PART 7)
1. Write a joint-space, cubic-splined path-planning system. One routine that your
system should include is
CUBCOEF (VAR thO, thf,
thdotf: real; VAR
vec4);
thO = initial position of 0 at beginning of segment,
thf = final position of 8 at segment end,
thdotO = initial velocity of segment,
thdotf = final velocity of segment.
These four quantities are inputs, and "cc", an array of the four cubic coefficients,
is the output.
Your program should accept up to (at least) five via-point specifications—in the
form of tool frame, {T}, relative to station frame, (SI—in the usual user form:
(x, y,
To keep life simple, all segments will have the same duration. Your system
should solve for the coefficients of the cubics, using some reasonable heuristic for
assigning joint velocities at the via points. Hint: See option 2 in Section 7.3.
2. Write a path-generator system that calculates a trajectory in joint space based
on sets of cubic coefficients for each segment. It must be able to generate the
multisegment path you planned in Problem 1. A duration for the segments will
be specified by the user. It should produce position, velocity, and acceleration
information at the path-update rate, which will also be specified by the user.
3. The manipulator is the same three-link used previously. The definitions of the {T)
and {S} frames are the same as before:
0.2 30.0],
y 8] = [0.0 0.0 0.0].
MATLAB Exercise 7
Using a duration of 3.0 seconds per segment, plan and execute the path that starts
with the manipulator at position
[x1 Yi Oil = [0.758 0.173 0.0],
moves through the via points
[x2 Y2 02] = [0.6 —0.3 45.0]
Y3 031
[—0.4 0.3 120.0],
and ends at the goal point (in this case, same as initial point)
[x4 Y4 04] = [0.758 0.173 0.0].
Use a path-update rate of 40 Hz, but print the position only every 0.2 seconds.
Print the positions out in terms of Cartesian user form. You don't have to print
out velocities or accelerations, though you might be interested in doing so.
MATLAB EXERCISE 7
The goal of this exercise is to implement polynomial joint-space trajectory-generation
equations for a single joint. (Multiple joints would require n applications of the result.)
Write a MATLAB program to implement the joint-space trajectory generation for
the three cases that follow. Report your results for the specific assignments given; for
each case, give the polynomial functions for the joint angle, angular velocity, angular
acceleration, and angular jerk (the time derivative of acceleration). For each case, plot
the results. (Arrange the plots vertically with angle, velocity, acceleration, and then jerk,
all with the same time scale—check out the subplot MATLAB function to accomplish
this.) Don't just plot out results—give some discussion; do your results make sense?
Here are the three cases:
a) Third-order polynomial. Force the angular velocity to be zero at the start and at
the finish. Given = 120° (start),
= 60° (finish), and tf = 1 sec.
b) Fifth-order polynomial. Force the angular velocity and acceleration to be zero at
the start and at the finish. Given = 120°,Of = 60°, and tf = 1 sec. Compare your
results (functions and plots) with this same example, but using a single third-order
polynomial, as in problem (a).
c) Two third-order polynomials with via point. Force the angular velocity to be
zero at the start and at the finish. Don't force the angular velocity to be zero
at the via point—you must match velocity and acceleration at this point for the
two polynomials meeting at that point in time. Demonstrate that this condition
is satisfied. Given
= 120° (via),
= 30° (finish), and
60° (start),
= t2 = 1 sec (relative time steps—i.e., tf = 2 sec).
d) Check the results of (a) and (b) by means of the Corke MATLAB Robotics
Toolbox. Try function jtrajQ.
BASING THE DESIGN ON TASK REQUIREMENTS
KINEMATIC CONFIGURATION
QUANTITATIVE MEASURES OF WORKSPACE ATFRIBUTES
REDUNDANT AND CLOSED-CHAIN STRUCTURES
ACTUATION SCHEMES
STIFFNESS AND DEFLECTIONS
POSITION SENSING
FORCE SENSING
In previous chapters, we have seen that the particular structure of a manipulator
influences kinematic and dynamic analysis. For example, some kinematic configurations wifi be easy to solve; others will have no closed-form kinematic solution.
Likewise, the complexity of the dynamic equations can vary greatly with the kinematic configuration and the mass distribution of the links. In coming chapters, we
will see that manipulator control depends not only on the rigid-body dynamics, but
also upon the friction and flexibility of the drive systems.
The tasks that a manipulator can perform will also vary greatly with the
particular design. Although we have generally dealt with the robot manipulator as
an abstract entity, its performance is ultimately limited by such pragmatic factors as
load capacity, speed, size of workspace, and repeatability. For certain applications,
the overall manipulator size, weight, power consumption, and cost will be significant
factors.
This chapter discusses some of the issues involved in the design of the
manipulator. In general, methods of design and even the evaluation of a finished
design are partially subjective topics. It is difficult to narrow the spectrum of design
choices with many hard and fast rules.
The elements of a robot system fall roughly into four categories:
1. The manipulator, including its internal or proprioceptive sensors;
2. the end-effector, or end-of-arm tooling;
3. external sensors and effectors, such as vision systems and part feeders; and
4. the controller.
Section 8.2
Basing the design on task requirements
The breadth of engineering disciplines encompassed forces us to restrict our
attention only to the design of the manipulator itself.
In developing a manipulator design, we will start by examining the factors
likely to have the greatest overall effect on the design and then consider more
detailed questions. Ultimately, however, designing a manipulator is an iterative
process. More often than not, problems that arise in the solving of a design detail
will force rethinking of previous higher level design decisions.
Although robots are nominally "universally programmable" machines capable of
performing a wide variety of tasks, economies and practicalities dictate that different
manipulators be designed for particular types of tasks. For example, large robots
capable of handling payloads of hundreds of pounds do not generally have the
capability to insert electronic components into circuit boards. As we shall see, not
only the size, but the number of joints, the arrangement of the joints, and the types
of actuation, sensing, and control wifi all vary greatly with the sort of task to be
performed.
Number of degrees of freedom
number of degrees of freedom in a manipulator should match the number
required by the task. Not all tasks require a full six degrees of freedom.
The most common such circumstance occurs when the end-effector has an
axis of symmetry. Figure 8.1 shows a manipulator positioning a grinding tool in two
different ways. In this case, the orientation of the tool with respect to the axis of the
tool, ZT, is immaterial, because the grinding wheel is spinning at several hundred
RPM. To say that we can position this 6-DOF robot in an infinity of ways for this
task (rotation about ZT is a free variable), we say that the robot is redundant for
this task. Arc welding, spot welding, deburring, glueing, and polishing provide other
examples of tasks that often employ end-effectors with at least one axis of symmetry.
FIGURE 8.1: A 6-DOF manipulator with a symmetric tool contains a redundant
232
Chapter 8
In analyzing the symmetric-tool situation, it is sometimes helpful to imagine
a fictitious joint whose axis lies along the axis of symmetry. In positioning any
end-effector to a specific pose, we need a total of six degrees of freedom. Because
one of these six is our fictitious joint, the actual manipulator need not have more
than five degrees of freedom. If a 5-DOF robot were used in the application of
Fig. 8.1, then we would be back to the usual case in which only a finite number of
different solutions are available for positioning the tool. Quite a large percentage
of existing industrial robots are 5-DOF, in recognition of the relative prevalence of
symmetric-tool applications.
Some tasks are performed in domains that, fundamentally, have fewer than six
degrees of freedom. Placement of components on circuit boards provides a common
example of this. Circuit boards generally are planar and contain parts of various
heights. Positioning parts on a planar surface requires three degrees of freedom (x,
y, and 0); in order to lift and insert the parts, a fourth motion normal to the plane is
added (z).
Robots with fewer than six degrees of freedom can also perform tasks in
which some sort of active positioning device presents the parts. In welding pipes,
for example, a tilt/roll platform, shown in Fig. 8.2, often presents the parts to be
welded. In counting the number of degrees of freedom between the pipes and the
end-effector, the tilt/roll platform accounts for two. This, together with the fact that
arc welding is a symmetric-tool task, means that, in theory, a 3-DOF manipulator
could be used. In practice, realities such as the need to avoid coffisions with the
workpiece generally dictate the use of a robot with more degrees of freedom.
Parts with an axis of symmetry also reduce the required degrees of freedom
for the manipulator. For example, cylindrical parts can in many cases be picked up
and inserted independent of the orientation of the gripper with respect to the axis of
the cylinder. Note, however, that after the part is grasped, the orientation of the part
about its symmetric axis must fail to matter for all subsequent operations, because
its orientation is not guaranteed.
FIGURE 8.2: A tilt/roll platform provides two degrees of freedom to the overall
manipulator system.
Workspace
In performing tasks, a manipulator has to reach a number of workpieces or fixtures.
In some cases, these can be positioned as needed to suit the workspace of the
manipulator. In other cases, a robot can be installed in a fixed environment with
rigid workspace requirements. Workspace is also sometimes called work voiwne or
work envelope.
The overall scale of the task sets the required workspace of the manipulator. In
some cases, the details of the shape of the workspace and the location of workspace
singularities wifi be important considerations.
The intrusion of the manipulator itself in the workspace can sometimes
be a factor. Depending on the kinematic design, operating a manipulator in a
given application could require more or less space around the fixtures in order
to avoid coffisions. Restricted environments can affect the choice of kinematic
configuration.
Load capacity
load capacity of a manipulator depends upon the sizing of its structural
members, power-transmission system, and actuators. The load placed on actuators
and drive system is a function of the configuration of the robot, the percentage of
time supporting a load, and dynamic loading due to inertial- and velocity-related
Speed
An obvious goal in design has been for faster and faster manipulators. High
speed offers advantages in many applications when a proposed robotic solution
must compete on economic terms with hard automation or human workers.
For some applications, however, the process itself limits the speed rather than
the manipulator. This is the case with many welding and spray-painting applications.
An important distinction is that between the maximum end-effector speed
and the overall cycle time for a particular task. For pick-and-place applications, the
manipulator must accelerate and decelerate to and from the pick and place locations
within some positional accuracy bounds. Often, the acceleration and deceleration
phases take up most of the cycle time. Hence, acceleration capability, not just peak
speed, is very important.
Repeatability and accuracy
High repeatability and accuracy, although desirable in any manipulator design, are
expensive to achieve. For example, it would be absurd to design a paint-spraying
robot to be accurate to within 0.001 inches when the spray spot diameter is 8 inches
±2 inches. To a large extent, accuracy of a particular model of industrial robot
depends upon the details of its manufacture rather than on its design. High accuracy
is achieved by having good knowledge of the link (and other) parameters. Making
it possible are accurate measurements after manufacture or careful attention to
tolerances during manufacturing.
234
Once
the required number of degrees of freedom has been decided upon, a
particular configuration of joints must be chosen to realize those freedoms. For
serial kinematic linkages, the number of joints equals the required number of
degrees of freedom. Most manipulators are designed so that the last n — 3 joints
orient the end-effector and have axes that intersect at the wrist point, and the first
three joints position this wrist point. Manipulators with this design could be said to
be composed of a positioning structure followed by an orienting structure or wrist.
As we saw in Chapter 4, these manipulators always have closed-form kinematic
solutions. Although other configurations exist that possess closed-form kinematic
solutions, almost every industrial manipulator belongs to this wrist-partitioned class
of mechanisms. Furthermore, the positioning structure is almost without exception
designed to be kinematically simple, having link twists equal to 0° or ±90° and
having many of the link lengths and offsets equal to zero.
It has become customary to classify manipulators of the wrist-partitioned,
kinematically simple class according to the design of their first three joints (the
positioning structure). The following paragraphs briefly describe the most common
of these classifications.
A Cartesian manipulator has perhaps the most straightforward configuration. As
shown in Fig. 8.3, joints 1 through 3 are prismatic, mutually orthogonal, and
correspond to the X, Y, and Z Cartesian directions. The inverse kinematic solution
for this configuration is trivial.
This configuration produces robots with very stiff structures. As a consequence,
very large robots can be built. These large robots, often called gantry robots, resemble
overhead gantry cranes. Gantry robots sometimes manipulate entire automobiles
or inspect entire aircraft.
The other advantages of Cartesian manipulators stem from the fact that the
first three joints are decoupled. This makes them simpler to design and prevents
kinematic singularities due to the first three joints.
Side view
FIGURE 8.3:
Top view
A Cartesian manipulator.
Kinematic configuration
Section 8.3
Their primary disadvantage is that all of the feeders and fixtures associated with
an application must lie "inside" the robot. Consequently, application workcells for
Cartesian robots become very machine dependent. The size of the robot's support
structure limits the size and placement of fixtures and sensors. These limitations
make retrofitting Cartesian robots into existing workcells extremely difficult.
Articulated
Figure 8.4 shows an articulated manipulator, sometimes also called ajointed, elbow,
or anthropomorphic manipulator. A manipulator of this kind typically consists of
two "shoulder" joints (one for rotation about a vertical axis and one for elevation
out of the horizontal plane), an "elbow" joint (whose axis is usually parallel to the
shoulder elevation joint), and two or three wrist joints at the end of the manipulator.
Both the PUMA 560 and the Motoman L-3, which we studied in earlier chapters,
fall into this class.
Articulated robots minimize the intrusion of the manipulator structure into
the workspace, making them capable of reaching into confined spaces. They require
much less overall structure than Cartesian robots, making them less expensive for
applications needing smaller workspaces.
SCARA
The SCARA' configuration, shown in Fig. 8.5, has three parallel revolute joints
(allowing it to move and orient in a plane), with a fourth prismatic joint for moving
the end-effector normal to the plane. The chief advantage is that the first three
joints don't have to support any of the weight of the manipulator or the load. In
addition, link 0 can easily house the actuators for the first two joints. The actuators
can be made very large, so the robot can move very fast. For example, the Adept
FIGURE 8.4: An articulated manipulator.
1SCARA stands for "selectively compliant assembly robot arm."
236
FIGURE 8.5: A SCARA manipulator.
One SCARA manipulator can move at up to 30 feet per second, about 10 times
faster than most articulated industrial robots [1]. This configuration is best suited to
planar tasks.
spherical configuration in Fig. 8.6 has many similarities to the articulated
manipulator, but with the elbow joint replaced by a prismatic joint. This design is
better suited to some applications than is the elbow design. The link that moves
prismatically might telescope—or even "stick out the back" when retracted.
Cylindrical manipulators (Fig. 8.7) consist of a prismatic joint for translating the arm
vertically, a revolute joint with a vertical axis, another prismatic joint orthogonal to
the revolute joint axis, and, finally, a wrist of some sort.
FIGURE 8.6:
A spherical manipulator.
Section 8.3
Kinematic configuration
FIGURE 8.7:
A cylindrical manipulator.
Wrists
The most common wrist configurations consist of either two or three revolute joints
with orthogonal, intersecting axes. The first of the wrist joints usually forms joint 4
of the manipulator.
A configuration of three orthogonal axes wifi guarantee that any orientation
can be achieved (assuming no joint-angle limits) [2]. As was stated in Chapter 4,
any manipulator with three consecutive intersecting axes wifi possess a closed-form
kinematic solution. Therefore, a three-orthogonal-axis wrist can be located at the
end of the manipulator in any desired orientation with no penalty. Figure 8.8 is a
schematic of one possible design of such a wrist, which uses several sets of bevel
gears to drive the mechanism from remotely located actuators.
In practice, it is difficult to build a three-orthogonal-axis wrist not subject to
rather severe joint-angle limitations. An interesting design used in several robots
An orthogonal-axis wrist driven by remotely located actuators via three
concentric shafts.
FIGURE 8.8:
238
manufactured by Cincinatti Milacron (Fig. 1.4) employs a wrist that has three
intersecting but nonorthogonal axes. In this design (called the "three roll wrist"), all
three joints of the wrist can rotate continuously without limits. The nonorthogonality
of the axes creates, however, a set of orientations that are impossible to reach with
this wrist. This set of unattainable orientations is described by a cone within which
the third axis of the wrist cannot lie. (See Exercise 8.11.) However, the wrist can be
mounted to link 3 of the manipulator in such a way that the link structure occupies
this cone and so would be block access anyway. Figure 8.9 shows two drawings of
such a wrist [24].
Some industrial robots have wrists that do not have intersecting axes. This
implies that a closed-form kinematic solution might not exist. If, however, the wrist is
mounted on an articulated manipulator in such a way that the joint-4 axis is parallel
to the joint-2 and -3 axes, as in Fig. 8.10, there will be a closed-form kinematic
solution. Likewise, a nonintersecting-axis wrist mounted on a Cartesian robot yields
a closed-form-solvable manipulator.
Typically, 5-DOF welding robots use two-axis wrists oriented as shown in
Fig. 8.11. Note that, if the robot has a symmetric tool, this "fictitious joint" must
follow the rules of wrist design. That is, in order to reach all orientations, the tool
must be mounted with its axis of symmetry orthogonal to the joint-S axis. In the
worst case, when the axis of symmetry is parallel to the joint-5 axis, the fictitious
sixth axis is in a permanently singular configuration.
FIGURE 8.9: Two views of a nonorthogonal-axis wrist [24]. From International Encyclopedia ofRobotics, by R. Dorf and S. Nof (editors). From "Wrists" by M. Rosheim,
John C. Wiley and Sons, Inc., New York, NY ©1988. Reprinted by permission.
Section 8.4
Quantitative measures of workspace attributes
A manipulator with a wrist whose axes do not intersect. However, this
robot does possess a closed-form kinematic solution.
FIGURE 8.10:
FIGURE 8.11: Typical wrist design of a 5-DOF welding robot.
QUANTITATIVE MEASURES OF WORKSPACE A1TRIBUTES
Manipulator designers have proposed several interesting quantitative measures of
various workspace attributes.
Chapter 8
Efficiency of design in terms of generating workspace
designers noticed that it seemed to take more material to build a Cartesian
manipulator than to build an articulated manipulator of similar workspace volume.
To get a quantitative handle on this, we first define the length sum of a manipulator as
Some
+ di),
(8.1)
are the link length and joint offset as defined in Chapter 3. Thus,
the length sum of a manipulator gives a rough measure of the "length" of the
complete linkage. Note that, for prismatic joints, must here be interpreted as a
constant equal to the length of travel between the joint-travel limits.
In [3], the structural length index, QL' is defined as the ratio of the manipulator's length sum to the cube root of the workspace volume—that is,
(8.2)
where L is given in (8.1) and W is the volume of the manipulator's workspace.
Hence, QL attempts to index the relative amount of structure (linkage length)
required by different configurations to generate a given work volume. Thus, a good
design would be one in which a manipulator with a small length sum nonetheless
possessed a large workspace volume. Good designs have a low
Considering just the positioning structure of a Cartesian manipulator (and
therefore the workspace of the wrist point), the value of QL is minimized when
all three joints have the same length of travel. This minimal value is QL = 3.0.
On the other hand, an ideal articulated manipulator, such as the one in Fig. 8.4,
0.62. This helps quantify our earlier statement that articulated
has QL
manipulators are superior to other configurations in that they have minimal intrusion
into their own workspace. Of course, in any real manipulator structure, the figure
just given would be made somewhat larger by the effect of joint limits in reducing
the workspace volume.
EXAMPLE 8.1
A SCARA manipulator like that of Fig. 8.5 has links 1 and 2 of equal length 1/2, and
the range of motion of the prismatic joint 3 is given by d3. Assume for simplicity that
the joint limits are absent, and find QL. What value of d3 minimizes QL and what is
this minimal value?
The length sum of this manipulator is L =
+ 1/2 + d3 = + d3, and the
workspace volume is that of a right cylinder of radius 1 and height d3; therefore,
l+d3
Minimizing QL as a function of the ratio d3 / gives d3 =
corresponding minimal value of QL is 1.29.
(8.3)
as optimal [3]. The
Section 8.5
Redundant and closed-chain structures
Designing well-conditioned workspaces
At singular points, a manipulator effectively loses one or more degrees of freedom, so certain tasks may not be able to be performed at that point. In fact, in
the neighborhood of singular points (including workspace-boundary singularities),
actions of the manipulator could fail to be well-conditioned. In some sense, the
farther the manipulator is away from singularities, the better able it is to move
uniformly and apply forces uniformly in all directions. Several measures have been
suggested for quantifying this effect. The use of such measures at design time might
yield a manipulator design with a maximally large well-conditioned subspace of the
Singular configurations are given by
det(J(O)) = 0,
(8.4)
so it is natural to use the determinant of the Jacobian in a measure of manipulator
dexterity. In [4], the manipulability measure, w, is defined as
(8.5)
which, for a nonredundant manipulator, reduces to
= Idet(J(®))I.
(8.6)
A good manipulator design has large areas of its workspace characterized by high
values of w.
Whereas velocity analysis motivated (8.6), other researchers have proposed
manipulability measures based on acceleration analysis or force-application capability. Asada [5] suggested an examination of the eigenvalues of the Cartesian mass
matrix
= J_T(e)M(O)J_l(O)
(8.7)
as a measure of how well the manipulator can accelerate in various Cartesian
directions. He suggests a graphic representation of this measure as an inertia
effipsoid, given by
XTMX(O)X
= 1,
(8.8)
the equation of an n-dimensional ellipse, where n is the dimension of X. The axes of
the ellipsoid given in (8.8) lie in the directions of the eigenvectors of (0), and the
reciprocals of the square roots of the corresponding eigenvalues provide the lengths
of the axes of the effipsoid. Well-conditioned points in the manipulator workspace
are characterized by inertia effipsoids that are spherical (or nearly so).
Figure 8.12 shows graphically the properties of a planar two-link manipulator.
In the center of the workspace, the manipulator is well conditioned, as is indicated
by nearly circular ellipsoids. At workspace boundaries, the effipses flatten, indicating
the manipulator's difficulty in accelerating in certain directions.
Other measures of workspace conditioning have been proposed in [6—8, 25].
In general, the scope of this book is limited to manipulators that are serial-
chain linkages of six or fewer joints. In this section, however, we briefly discuss
manipulators outside of this class.
242
4-FIGURE 8.12: Workspace of a 2-DOF planar arm, showing inertia ellipsoids, from [5]
(© 1984 IEEE). The dashed line indicates a locus of isotropic points in the workspace.
Reprinted by permission.
Micromanipulators and other redundancies
General spatial positioning capability requires only six degrees of freedom, but there
are advantages to having even more controllable joints.
One use for these extra freedoms is abeady finding some practical application [9,10] and is of growing interest in the research community: a micromanipulator.
A micromanipulator is generally formed by several fast, precise degrees of freedom
located near the distal end of a "conventional" manipulator. The conventional
manipulator takes care of large motions, while the micromanipulator, whose joints
generally have a small range of motion, accomplishes fine motion and force control.
Additional joints can also help a mechanism avoid singular configurations,
as is suggested in [11, 12]. For example, any three-degree-of-freedom wrist wifi
suffer from singular configurations (when all three axes lie in a plane), but a
four-degree-of-freedom wrist can effectively avoid such configurations [13—15].
Figure 8.13 shows two configurations suggested [11, 12] for seven-degree-offreedom manipulators.
A major potential use of redundant robots is in avoiding coffisions while
operating in cluttered work environments. As we have seen, a six-degree-of-freedom
manipulator can reach a given position and orientation in only a finite number of
ways. The addition of a seventh joint allows an infinity of ways, permitting the desire
to avoid obstacles to influence the choice.
Closed-loop structures
Although we have considered only serial-chain manipulators in our analysis, some
manipulators contain closed-loop structures. For example, the Motoman L-3 robot
described in Chapters 3 and 4 possesses closed-loop structures in the drive mechanism of joints 2 and 3. Closed-loop structures offer a benefit: increased stiffness of
FIGURE 8.13:
Two suggested seven-degree-of-freedom manipulator designs [3].
the mechanism [16]. On the other hand, closed-loop structures generally reduce the
allowable range of motion of the joints and thus decrease the workspace size.
Figure 8.14 depicts a Stewart mechanism, a closed-loop alternative to the serial
6-DOF manipulator. The position and orientation of the "end-effector" is controlled
by the lengths of the six linear actuators which connect it to the base. At the base end,
each actuator is connected by a two-degree-of-freedom universal joint. At the end-
effector, each actuator is attached with a three-degree-of-freedom ball-and-socket
joint. It exhibits characteristics common to most closed-loop mechanisms: it can be
made very stiff, but the links have a much more limited range of motion than do
serial linkages. The Stewart mechanism, in particular, demonstrates an interesting
reversal in the nature of the forward and inverse kinematic solutions: the inverse
solution is quite simple, whereas the forward solution is typically quite complex,
sometimes lacking a closed-form formulation. (See Exercises 8.7 and 8.12.)
In general, the number of degrees of freedom of a closed-loop mechanism is
not obvious. The total number of degrees of freedom can be computed by means of
Grübler's formula [17],
(8.9)
where F is the total number of degrees of freedom in the mechanism, 1 is the
number of links (including the base), n is the total number of joints, and is the
number of degrees of freedom associated with the ith joint. A planar version of
Grübler's formula (when all objects are considered to have three degrees of freedom
if unconstrained) is obtained by replacing the 6 in (8.9) with a 3.
244
FIG U RE 8.14:
The Stewart mechanism is a six-degree-of-freedom fully parallel manip-
ulator.
EXAMPLE 8.2
Use Grübler's formula to verify that the Stewart mechanism (Fig. 8.14) indeed has
six degrees of freedom.
The number of joints is 18 (6 universal, 6 ball and socket, and 6 prismatic in
the actuators). The number of links is 14 (2 parts for each actuator, the end-effector,
and the base). The sum of all the joint freedoms is 36. Using Grubler's formula, we
can verify that the total number of degrees of freedom is six:
F=6(14—18—1)+36=6.
(8.10)
Once the general kinematic structure of a manipulator has been chosen, the next
most important matter of concern is the actuation of the joints. Typically, the
actuator, reduction, and transmission are closely coupled and must be designed
together.
Actuator location
The most straightforward choice of actuator location is at or near the joint it drives.
If the actuator can produce enough torque or force, its output can attach directly
to the joint. This arrangement, known as a direct-drive configuration [18], offers
Section 8.6
Actuation schemes
the advantages of simplicity in design and superior controllability—that is, with no
transmission or reduction elements between the actuator and the joint, the joint
motions can be controlled with the same fidelity as the actuator itself.
Unfortunately, many actuators are best suited to relatively high speeds and
low torques and therefore require a speed-reduction system. Furthermore, actuators
tend to be rather heavy. If they can be located remotely from the joint and toward
the base of the manipulator, the overall inertia of the manipulator can be reduced
considerably. This, in turn, reduces the size needed for the actuators. To realize
these benefits, a transmission system is needed to transfer the motion from the
actuator to the joint.
In a joint-drive system with a remotely mounted actuator, the reduction system
could be placed either at the actuator or at the joint. Some arrangements combine
the functions of transmission and reduction. Aside from added complexity, the
major disadvantage of reduction and transmission systems is that they introduce
additional friction and flexibility into the mechanism. When the reduction is at the
joint, the transmission wifi be working at higher speeds and lower torques. Lower
torque means that flexibility will be less of a problem. However, if the weight of the
reducer is significant, some of the advantage of remotely mounted actuators is lost.
In Chapter 3, details were given for the actuation scheme of the Yasukawa
Motoman L-3, which is typical of a design in which actuators are mounted remotely
and resulting joint motions are coupled. Equations (3.16) show explicitly how
actuator motions cause joint motions. Note, for example, that motion of actuator 2
causes motion of joints 2, 3, and 4.
The optimal distribution of reduction stages throughout the transmission
will depend ultimately on the flexibility of the transmission, the weight of the
reduction system, the friction associated with the reduction system, and the ease of
incorporating these components into the overall manipulator design.
Reduction and transmission systems
Gears are the most common element used for reduction. They can provide for
large reductions in relatively compact configurations. Gear pairs come in various
configurations for parallel shafts (spur gears), orthogonal intersecting shafts (bevel
gears), skew shafts (worm gears or cross helical gears), and other configurations.
Different types of gears have different load ratings, wear characteristics, and
frictional properties.
The major disadvantages of using gearing are added backlash and friction.
Backlash, which arises from the imperfect meshing of gears, can be defined as the
maximum angular motion of the output gear when the input gear remains fixed.
If the gear teeth are meshed tightly to eliminate backlash, there can be excessive
amounts of friction. Very precise gears and very precise mounting minimize these
problems, but also increase cost.
The gear ratio, describes the speed-reducing and torque-increasing effects of
a gear pair. For speed-reduction systems, we will define > 1; then the relationships
between input and output speeds and torques are given by
(8.11)
246
are output and input speeds, respectively, and r0 and tj are output
and input torques, respectively.
The second broad class of reduction elements includes flexible bands, cables,
and belts. Because all of these elements must be flexible enough to bend around
pulleys, they also tend to be flexible in the longitudinal direction. The flexibility of
these elements is proportional to their length. Because these systems are flexible,
where é0 and
there must be some mechanism for preloading the loop to ensure that the belt
or cable stays engaged on the pulley. Large preloads can add undue strain to the
flexible element and introduce excessive friction.
Cables or flexible bands can be used either in a closed loop or as singleended elements that are always kept in tension by some sort of preload. In a joint
that is spring loaded in one direction, a single-ended cable could be used to pull
against it. Alternately, two active single-ended systems can oppose each other.
This arrangement eliminates the problem of excessive preloads but adds more
actuators.
Roller chains are similar to flexible bands but can bend around relatively small
pulleys while retaining a high stiffness. As a result of wear and high loads on the
pins connecting the links, toothed-belt systems are more compact than roller chains
for certain applications.
Band, cable, belt, and chain drives have the ability to combine transmission
with reduction. As is shown in Fig. 8.15, when the input pulley has radius r1 and the
output pulley has radius r9, the "gear" ratio of the transmission system is
(8.12)
Lead screws or ball-bearing screws provide another popular method of getting
a large reduction in a compact package (Fig. 8.16). Lead screws are very stiff and can
support very large loads, and have the property that they transform rotary motion
into linear motion. Ball-bearing screws are similar to lead screws, but instead of
having the nut threads riding directly on the screw threads, a recirculating circuit of
ball bearings rolls between the sets of threads. Ball-bearings screws have very low
friction and are usually backdrivable.
Input
FIGURE 8.15: Band, cable, belt, and chain drives have the ability to combine transmission with reduction.
Stiffness and deflections
Section 8.7
Race
FIGURE 8.16: Lead screws (a) and ball-bearing screws (b) combine a large reduction
and transformation from rotary to linear motion.
An important goal for the design of most manipulators is overall stiffness of the
structure and the drive system. Stiff systems provide two main benefits. First,
because typical manipulators do not have sensors to measure the tool frame
location directly, it is calculated by using the forward kinematics based on sensed
joint positions. For an accurate calculation, the links cannot sag under gravity or
other loads. In other words, we wish our Denavit—Hartenberg description of the
linkages to remain fixed under various loading conditions. Second, fiexibilities in
the structure or drive train wifi lead to resonances, which have an undesirable effect
on manipulator performance. In this section, we consider issues of stiffness and
the resulting defiections under loads. We postpone further discussion of resonances
until Chapter 9.
Flexible elements in parallel and in series
As can be easily shown (see Exercise 8.21), the combination of two flexible members
of stiffness k1 and k2 "connected in parallel" produces the net stiffness
kparallei =
+ k2;
(8.13)
"connected in series," the combination produces the net stiffness
ksedes
(8.14)
In considering transmission systems, we often have the case of one stage
of reduction or transmission in series with a following stage of reduction or
transmission; hence, (8.14) becomes useful.
Shafts
A common method for transmitting rotary motion is through shafts. The torsional
stiffness of a round shaft can be calculated [19] as
G7rd4
(8.15)
248
where d is the shaft diameter, 1 is the shaft length, and G is the shear modulus of
elasticity (about 7.5 x 1010 Nt/rn2 for steel, and about a third as much for aluminum).
Gears
Gears, although typically quite stiff, introduce compliance into the drive system. An
approximate formula to estimate the stiffness of the output gear (assuming the input
gear is fixed) is given in [20] as
C8br2,
(8.16)
where b is the face width of the gears, r is the radius of the output gear, and
Cg = 1.34 x 1010 Nt/m2 for steel.
Gearing also has the effect of changing the effective stiffness of the drive
system by a factor of
If the stiffness of the transmission system prior to the
reduction (i.e., on the input side) is
so that
(8.17)
and the stiffness of the output side of the reduction is k0, so that
(8.18)
then we can compute the relationship between
perfectly rigid gear pair) as
and k0 (under the assumption of a
(8.19)
Hence, a gear reduction has the effect of increasing the stiffness by the square of the
gear ratio.
EXAMPLE 8.3
A shaft with torsional stiffness equal to 500.0 Nt-rn/radian is connected to the
input side of a gear set with i, = 10, whose output gear (when the input gear is
fixed) exhibits a stiffness of 5000.0 Nt mlradian. What is the output stiffness of the
combined drive system?
Using (8.14) and (8.19), we have
+ 102(500.0)'
(8.20)
4545.4 Nt rn/radian.
(8.21)
kseries = 5000.0
kseñes = 50000
When a relatively large speed reduction is the last element of a multielement
transmission system, the stiffnesses of the preceding elements can generally be
ignored.
FIGURE 8.17:
Simple cantilever beam used to model the stiffness of a link to an end
load.
Belts
In such a belt drive as that of Fig. 8.15, stiffness is given by
(8.22)
where A is the cross-sectional area of the belt, E is the modulus of elasticity of the
belt, and 1 is the length of the free belt between pulleys plus one-third of the length
of the belt in contact with the pulleys [19].
Links
As a rough approximation of the stiffness of a link, we might model a single link as
a cantilever beam and calculate the stiffness at the end point, as in Fig. 8.17. For a
round hollow beam, this stiffness is given by [19]
3irE(d4
(8.23)
and d0 are the inner and outer diameters of the tubular beam, 1 is the
length, and E is the modulus of elasticity (about 2 x 1011 Nt/rn2 for steel, and about
a third as much for aluminum). For a square-cross-section hollow beam, this stiffness
(8.24)
and w0 are the outer and inner widths of the beam (i.e., the wall thickness
is w0 — wi).
EXAMPLE 8.4
A square-cross-section link of dimensions 5 x 5 x 50 cm with a wall thickness of
1 cm is driven by a set of rigid gears with = 10, and the input of the gears is driven
by a shaft having diameter 0.5 cm and length 30 cm. What deflection is caused by a
force of 100 Nt at the end of the link?
250
Using (8.24), we calculate the stiffness of the link as
(2 x 1011)(ft054 —
3.69 x
(8.25)
Hence, for a load of 100 Nt, there is a deflection in the link itself of
2.7 x
(8.26)
or 0.027 cm.
Additionally, 100 Nt at the end of a 50-cm link is placing a torque of 50 Nt-rn
on the output gear. The gears are rigid, but the flexibility of the input shaft is
(7 5
1010) (3 14)(5 x
(32)(0.3)
15.3 Nt rn/radian,
(8.27)
which, viewed from the output gear, is
(15.3) (102)
1530.0
Nt-rn/radian.
(8.28)
Loading with 50 Nt-rn causes an angular deflection of
0.0326
radian,
(8.29)
so the total linear deflection at the tip of the link is
0.027 + (0.0326) (50) = 0.027 + 1.630 = 1.657 cm.
(8.30)
In our solution, we have assumed that the shaft and link are made of steel. The
stiffness of both members is linear in E, the modulus of elasticity, so, for aluminum
elements, we can multiply our result by about 3.
In this section, we have examined some simple formulas for estimating the
stiffness of gears, shafts, belts, and links. They are meant to give some guidance
in sizing structural members and transmission elements. However, in practical
applications, many sources of flexibility are very difficult to model. Often, the
drive train introduces significantly more flexibility than the link of a manipulator.
Furthennore, many sources of flexibility in the drive system have not been considered
here (bearing flexibility, flexibility of the actuator mounting, etc.). Generally, any
attempt to predict stiffness analytically results in an overly high prediction, because
many sources are not considered.
Finite-element techniques can be used to predict the stiffness (and other
properties) of more realistic structural elements more accurately. This is an entire
field in itself [21] and is beyond the scope of this book.
Actuators
Among various actuators, hydraulic cylinders or vane actuators were originally
the most popular for use in manipulators. In a relatively compact package, they
Section 8.7
Stiffness and deflections
can produce enough force to drive joints without a reduction system. The speed of
operation depends upon the pump and accumulator system, usually located remotely
from the manipulator. The position control of hydraulic systems is well understood
and relatively straightforward. All of the early industrial robots and many modern
large industrial robots use hydraulic actuators.
Unfortunately, hydraulics require a great deal of equipment, such as pumps,
accumulators, hoses, and servo valves. Hydraulic systems also tend to be inherently
messy, making them unsuitable for some applications. With the advent of more
advanced robot-control strategies, in which actuator forces must be applied accurately, hydraulics proved disadvantageous, because of the friction contributed by
their seals.
Pneumatic cylinders possess all the favorable attributes of hydraulics, and
they are cleaner than hydraulics—air seeps out instead of hydraulic fluid. However,
pneumatic actuators have proven difficult to control accurately, because of the
compressibility of air and the high friction of the seals.
Electric motors are the most popular actuator for manipulators. Although
they don't have the power-to-weight ratio of hydraulics or pneumatics, their controllability and ease of interface makes them attractive for small-to-medium-sized
manipulators.
Direct current (DC) brush motors (Fig. 8.18) are the most straightforward
to interface and control. The current is conducted to the windings of the rotor
via brushes, which make contact with the revolving commutator. Brush wear and
friction can be problems. New magnetic materials have made high peak torques
possible. The limiting factor on the torque output of these motors is the overheating
Stator magnet
Rotor windings
Shaft
Bearings
• Stator magnet
Commutator
DC brush motors are among the actuators occurring most frequently in
manipulator design. Franklin, Powell, Emami-Naeini, Feedback Control ofDynamic
Systems, © 1988, Addison-Wesley, Reading, MA. Reprinted with permission.
FIG U RE 8.18:
252
of the windings. For short duty cycles, high torques can be achieved, but only much
lower torques can be sustained over long periods of time.
Brushless motors solve brush wear and friction problems. Here, the windings
remain stationary and the magnetic field piece rotates. A sensor on the rotor detects
the shaft angle and is then used by external electronics to perform the conunutation.
Another advantage of brushless motors is that the winding is on the outside, attached
to the motor case, affording it much better cooling. Sustained torque ratings tend to
be somewhat higher than for similar-sized brush motors.
Alternating current (AC) motors and stepper motors have been used infrequently in industrial robotics. Difficulty of control of the former and low torque
ability of the latter have limited their use.
Virtually all manipulators are servo-controlled mechanisms—that is, the force or
torque command to an actuator is based on the error between the sensed position
of the joint and the desired position. This requires that each joint have some sort of
position-sensing device.
The most common approach is to locate a position sensor directly on the shaft
of the actuator. If the drive train is stiff and has no backlash, the true joint angles can
be calculated from the actuator shaft positions. Such co-located sensor and actuator
pairs are easiest to control.
The most popular position-feedback device is the rotary optical encoder.
As the encoder shaft turns, a disk containing a pattern of fine lines interrupts
a light beam. A photodetector turns these light pulses into a binary waveform.
Typically, there are two such channels, with wave pulse trains 90 degrees out
of phase. The shaft angle is determined by counting the number of pulses, and
the direction of rotation is determined by the relative phase of the two square
waves. Additionally, encoders generally emit an index pulse at one location, which
can be used to set a home position in order to compute an absolute angular
position.
Resolvers are devices that output two analog signals—one the sine of the shaft
angle, the other the cosine. The shaft angle is computed from the relative magnitude
of the two signals. The resolution is a function of the quality of the resolver and the
amount of noise picked up in the electronics and cabling. Resolvers are often more
reliable than optical encoders, but their resolution is lower. Typically, resolvers
cannot be placed directly at the joint without additional gearing to improve the
resolution.
Potentiometers provide the most straightforward form of position sensing.
Connected in a bridge configuration, they produce a voltage proportional to the
shaft position. Difficulties with resolution, linearity, and noise susceptibility limit
their use.
Tachometers are sometimes used to provide an analog signal proportional to
the shaft velocity. In the absence of such velocity sensors, the velocity feedback
is derived by taking differences of sensed position over time. This numerical
differentiation can introduce both noise and a time lag. Despite these potential
problems, most manipulators are without direct velocity sensing.
Section 8.9
Force sensing
A variety of devices have been designed to measure forces of contact between a
manipulator's end-effector and the environment that it touches. Most such sensors
make use of sensing elements called strain gauges, of either the semiconductor or the
metal-foil variety. These strain gauges are bonded to a metal structure and produce
an output proportional to the strain in the metal. In this type of force-sensor design,
the issues the designer must address include the following:
1. How many sensors are needed to resolve the desired information?
2. How are the sensors mounted relative to each other on the structure?
3. What structure allows good sensitivity while maintaining stiffness?
4. How can protection against mechanical overload be built into the device?
There are three places where such sensors are usually placed on a manipulator:
1. At the joint actuators. These sensors measure the torque or force output of
the actuator/reduction itself. These are useful for some control schemes, but
usually do not provide good sensing of contact between the end-effector and
the environment.
2. Between the end-effector and last joint of the manipulator. These sensors
are usually referred to as wrist sensors. They are mechanical structures
instrumented with strain gauges, which can measure the forces and torques
acting on the end-effector. Typically, these sensors are capable of measuring
from three to six components of the force/torque vector acting on the endeffector.
3. At the "fingertips" of the end-effector. Usually, these force-sensing fingers
have built-in strain gauges to measure from one to four components of force
acting at each fingertip.
As an example, Fig. 8.19 is a drawing of the internal structure of a popular style
of wrist-force sensor designed by Scheinman [22]. Bonded to the cross-bar structure
of the device are eight pairs of semiconductor strain gauges. Each pair is wired in a
voltage-divider arrangement. Each time the wrist is queried, eight analog voltages
are digitized and read into the computer. Calibration schemes have been designed
with which to arrive at a constant 6 x 8 calibration matrix that maps these eight
strain measurements into the force—torque vector,
acting on the end-effector.
The sensed force—torque vector can be transformed to a reference frame of interest,
as we saw in Example 5.8.
Force-sensor design issues
Use of strain gauges to measure force relies on measuring the deflection of a stressed
fiexure. Therefore, one of the primary design trade-offs is between the stiffness and
the sensitivity of the sensor. A stiffer sensor is inherently less sensitive.
The stiffness of the sensor also affects the construction of overload protection.
Strain gauges can be damaged by impact loading and therefore must be protected
against such overloads. Transducer damage can be prevented by having limit stops,
254
8.19: The internal structure of a typical force-sensing wrist.
which prevent the flexures from deflecting past a certain point. Unfortunately, a
very stiff sensor might deflect only a few ten-thousandths of an inch. Manufacturing
limit stops with such small clearances is very difficult. Consequently, for many types
of transducers, a certain amount of flexibility must be built-in in order to make
possible effective limit stops.
Eliminating hysteresis is one of the most cumbersome restrictions in the sensor
design. Most metals used as flexures, if not overstrained, have very little hysteresis.
However, bolted, press-fit, or welded joints near the flexure introduce hysteresis.
Ideally, the flexure and the material near it are made from a single piece of metal.
It is also important to use differential measurements to increase the linearity
and disturbance rejection of torque sensors. Different physical configurations of
transducers can eliminate influences due to temperature effects and off-axis forces.
Foil gauges are relatively durable, but they produce a very small resistance
change at full strain. Eliminating noise in the strain-gauge cabling and amplification
electronics is of crucial importance for a good dynamic range.
Semiconductor strain gauges are much more susceptible to damage through
overload. In their favor, they produce a resistance change about seventy times that
of foil gauges for a given strain. This makes the task of signal processing much
simpler for a given dynamic range.
[1] W. Rowe, Editor, Robotics Technical Directory 1986, Instrument Society of America,
Research Triangle Park, NC, 1986.
[2] R. Vijaykumar and K. Waldron, "Geometric Optimization of Manipulator Structures
for Working Volume and Dexterity," Intern ational Journal of Robotics Research, Vol.
5, No. 2, 1986.
[3] K. Waldron, "Design of Arms," in The International Encyclopedia ofRobotics, R. Dorf
and S. Not, Editors, John Wiley and Sons, New York, 1988.
[4] T. Yoshikawa, "Manipulability of Robotic Mechanisms," The International Journal of
Robotics Research, Vol. 4, No. 2, MIT Press, Cambridge, MA, 1985.
[5] H. Asada, "Dynamic Analysis and Design of Robot Manipulators Using Inertia
Effipsoids," Proceedings of the IEEE International Conference on Robotics, Atlanta,
March 1984.
[6] J.K. Salisbury and J. Craig, "Articulated Hands: Force Control and Kinematic Issues,"
The International Journal of Robotics Research, Vol. 1, No. 1, 1982.
[7] 0. Khatib and I. Burdick, "Optimization of Dynamics in Manipulator Design: The
Operational Space Formulation," International Journal of Robotics and Automation,
Vol. 2, No. 2, TASTED, 1987.
[8] T. Yoshikawa, "Dynamic Manipulability of Robot Manipulators," Proceedings of the
IEEE International Conference on Robotics and Automation, St. Louis, March 1985.
[9] J. Trevelyan, P. Kovesi, and M. Ong, "Motion Control for a Sheep Shearing Robot,"
The 1st International Symposium of Robotics Research, MIT Press, Cambridge, MA,
1984.
[10] P. Marchal, J. Cornu, and J. Detriche, "Self Adaptive Arc Welding Operation by
Means of an Automatic Joint Following System," Proceedings of the 4th Symposium
on Theory and Practice of Robots and Manipulators, Zaburow, Poland, September
[II] J.M. Hollerbach, "Optimum Kinematic Design for a Seven Degree of Freedom
Manipulator," Proceedings of the 2nd International Symposium of Robotics Research,
Kyoto, Japan, August 1984.
[12] K. Waldron and J. Reidy, "A Study of Kinematically Redundant Manipulator Structure," Proceedings of the IEEE Robotics and Automation Conference, San Francisco,
April 1986.
[13] V. Milenkovic, "New Nonsingular Robot Wrist Design," Proceedings of the Robots
11/17th ISIR Conference, SME, 1987.
[14] E. Rivin, Mechanical Design of Robots, McGraw-Hill, New York, 1988.
[15] T. Yosliikawa, "Manipulability of Robotic Mechanisms," in Proceedings of the 2nd
International Symposium on Robotics Research, Kyoto, Japan, 1984.
[16] M. Leu, V. Dukowski, and K. Wang, "An Analytical and Experimental Study of the
Stiffness of Robot Manipulators with Parallel Mechanisms," in Robotics and Manufacturing Automation, M. Donath and M. Leu, Editors, ASME, New York, 1985.
[17] K. Hunt, Kinematic Geometry of Mechanisms, Cambridge University Press, Cambridge, MA, 1978.
[18] H. Asada and K. Youcef-Toumi, Design of Direct Drive Manipulators, MIT Press,
Cambridge, MA, 1987.
[19] J. Shigley, Mechanical Engineering Design, 3rd edition, McGraw-Hill, New York,
1977.
[20] D. Welbourne, "Fundamental Knowledge of Gear Noise—A Survey," Proceedings
of the Conference on Noise and Vibrations of Engines and Transmissions, Institute of
Mechanical Engineers, Cranffeld, UK, 1979.
[21] 0. Zienkiewicz, The Finite Element Method, 3rd edition, McGraw-Hill, New York,
256
[22]
V. Scheinman, "Design of a Computer Controlled Manipulator," M.S. Thesis,
Mechanical Engineering Department, Stanford University, 1969.
[23] K. Lau, N. Dagalakis, and D. Meyers, "Testing," in The International Encyclopedia of
Robotics, R. Don and S. Nof, Editors, John Wiley and Sons, New York, 1988.
[24] M. Roshiem, "Wrists," in The International Encyclopedia of Robotics, R. Dorf and
S. Nof, Editors, John Wiley and Sons, New York, 1988.
[251 A. Bowling and 0. Khatib, "Robot Acceleration Capability: The Actuation Efficiency Measure," Proceedings of the IEEE International Conference on Robotics and
Automation, San Francisco, April 2000.
8.1 [15] A robot is to be used for positioning a laser cutting device. The laser produces
a pinpoint, nondivergent beam. For general cutting tasks, how many degrees of
freedom does the positioning robot need? Justify your answer.
8.2 [15] Sketch a possible joint configuration for the laser-positioning robot of
Exercise 8.1, assuming that it will be used primarily for cutting at odd angles
through 1-inch-thick, 8 x 8-foot plates.
8.3 [17] For a spherical robot like that of Fig. 8.6, if joints 1 and 2 have no limits and
joint 3 has lower limit 1 and upper limit ii, find the structural length index,
the wrist point of this robot.
8.4 [25] A steel shaft of length 30 cm and diameter 0.2 cm drives the input gear of a
reduction having 17 = 8. The output gear drives a steel shaft having length 30 cm
and diameter 0.3 cm. If the gears introduce no compliance of their own, what is
the overall stiffness of the transmission system?
8.5 [20] In Fig. 8.20, a link is driven through a shaft after a gear reduction. Model
the link as rigid with mass of 10 Kg located at a point 30 cm from the shaft axis.
Assume that the gears are rigid and that the reduction, is large. The shaft is
steel and must be 30 cm long, if the design specifications call for the center of link
mass to undergo accelerations of 2.0 g, what should the shaft diameter be to limit
dynamic deflections to 0.1 radian at the joint angle?
FIGURE 8.20: A link actuated through a shaft after a gear reduction.
Electric motor
#1 Coupling
#2 Coupling
#1 Gear
Gear
FIGURE 8.21:
Simplified version of the drive train of joint 4 of the PUMA 560
manipulator (from [23]). From International Encyclopedia of Robotics, by R. Dorf
and S. Nof, editors. From "Testing," by K. Law, N. Dagalakis, and D. Myers.
8.6 [15] If the output gear exhibits a stiffness of 1000 Nt-ni/radian with input gear
locked and the shaft has stiffness of 300 Nt-rn/radian, what is the combined
stiffness of the drive system in Fig. 8.20?
8.7 [43] Pieper's criteria for serial-linlc manipulators state that the manipulator will
be solvable if three consecutive axes intersect at a single point or are parallel.
This is based on the idea that inverse kinematics can be decoupled by looking
at the position of the wrist point independently from the orientation of the wrist
frame. Propose a similar result for the Stewart mechanism in Fig. 8.14, to allow
the forward kinematic solution to be similarly decoupled.
8.8 [20] Tn the Stewart mechanism of Fig. 8.14, if the 2-DOF universal joints at the
base were replaced with 3-DOF ball-and-socket joints, what would the total
number of degrees of freedom of the mechanism be? Use Grubler's formula.
8.9 [22] Figure 8.21 shows a simplified schematic of the drive system of joint 4 of the
PUMA 560 [23]. The torsional stiffness of the couplings is 100 Nt-rn/radian each,
that of the shaft is 400 Nt-rn/radian, and each of the reduction pairs has been
measured to have output stiffness of 2000 Nt-rn/radian with its input gears fixed.
Both the first and second reductions have = 6.2 Assuming the structure and
bearing are perfectly rigid, what is the stiffness of the joint (i.e., when the motor's
shaft is locked)?
8.10 [25] What is the error if one approximates the answer to Exercise 8.9 by considering just the stiffness of the final speed-reduction gearing?
8.11 [20] Figure 4.14 shows an orthogonal-axis wrist and a nonorthogonal wrist. The
orthogonal-axis wrist has link twists of magnitude 900; the nonorthogonal wrist
has link twists of and 180° — in magnitude. Describe the set of orientations that
are unattainable with the nonorthogonal mechanism. Assume that all axes can
turn 360° and that links can pass through one another if need be (i.e., workspace
is not limited by self-coffision).
2None of the numerical values in this exercise is meant to be realistic!
258
FIGURE 8.22:
Stewart mechanism of Exercise 8.12.
8.12 [18] Write down a general inverse-kinematic solution for the Stewart mechanism
shown in Fig. 8.22. Given the location of {T} relative to the base frame {B), solve
are 3 x 1 vectors which
for the joint-position variables d1 through d6. The
locate the base connections of the linear actuators relative to frame {B}. The
Tq. are 3 x 1 vectors which locate the upper connections of the linear actuators
relative to the frame {T}.
8.13 [201 The planar two-link of example 5.3 has the determinant of its Jacobian given
det(J(O)) =
l112s2.
(8.31)
If the sum of the two link lengths, 11 + 12, is constrained to be equal to a constant,
what should the relative lengths be in order to maximize the manipulator's
manipulability as defined by (8.6)?
[281 For a SCARA robot, given that the sum of the link lengths of link 1 and link
2 must be constant, what is the optimal choice of relative length in terms of the
manipulability index given in (8.6)? Solving Exercise 8.13 first could be helpful.
8.15 [35] Show that the manipulability measure defined in (8.6) is also equal to the
product of the eigenvalues of J(e).
8.16 [15] What is the torsional stiffness of a 40-cm aluminum rod with radius 0.1 cm?
of a belt system having an input
8.17 [5] What is the effective "gear" reduction,
pulley of radius 2.0 cm and an output pulley of radius 12.0 cm?
8.14
8.18 [10]
How many degrees of freedom are required in a manipulator used to
place cylindrical-shaped parts on a flat plane? The cylindrical parts are perfectly
symmetrical about their main axes.
8.19 [25] Figure 8.23 shows a three-fingered hand grasping an object. Each finger has
three single-degree-of-freedom joints. The contact points between fingertips and
the object are modeled as "point contact"—that is, the position is fixed, but the
relative orientation is free in all three degrees of freedom. Hence, these point
contacts can be replaced by 3-DOF ball-and-socket joints for the purposes of
analysis.
Apply Grubler's formula to compute how many degrees of freedom the
overall system possesses.
8.20 [23] Figure 8.24 shows an object connected to the ground with three rods. Each
rod is connected to the object with a 2-DOF universal joint and to the ground with
a 3-DOF ball-and-socket joint. How many degrees of freedom does the system
possess?
FIG U RE 8.23: A three-fingered hand in which each finger has three degrees of freedom
grasps an object with "point contact."
FIGURE 8.24:
Closed ioop mechanism of Exercise 8.20.
8.21 [18] Verify that, if two transmission systems are connected serially, then the
equivalent stiffness of the overall system is given by (8.14). It is perhaps simplest
to think of the serial connection of two linear springs having stiffness coefficients
260
and k2 and of the resulting equations:
f = k18x1,
(8.32)
+ 8x7).
8.22 [20] Derive a formula for the stiffness of a belt-drive system in terms of the pulley
Start
radii (r1 and r2) and the center-to-center distance between the pulleys,
from (8.22).
PROGRAMMING EXERCISE (PART 8)
1. Write a program to compute the determinant of a 3 x 3 matrix.
2. Write a program to move the simulated three-link robot in 20 steps in a straight
line and constant orientation from
r 0.25
0.95
in increments of 0.05 meter. At each location, compute the manipulability measure
for the robot at that configuration (i.e., the determinant of the Jacobian). List, or,
better yet, make a plot of the values as a function of the position along the axis.
Generate the preceding data for two cases:
(a) 11 = 12 = 0.5 meter, and
(b) 11 = 0.625 meter, 12 = 0.375 meter.
Which manipulator design do you think is better? Explain your answer.
MATLAB EXERCISE 8
8.5 introduced the concept of kinematically redundant robots. This exercise
deals with the resolved-rate control simulation for a kinematically redundant robot. We
will focus on the planar 4-DOF 4R robot with one degree of kinematic redundancy (four
joints to provide three Cartesian motions: two translations and one rotation). This robot
is obtained by adding a fourth R-joint and a fourth moving link L4 to the planar 3-DOF,
3R robot (of Figures 3.6 and 3.7; the DH parameters can be extended by adding one row
to Figure 3.8).
Section
For the planar 4R robot, derive analytical expressions for the 3 x 4 Jacobian
matrix; then, perform resolved-rate control simulation in MATLAB (as in MATLAB
Exercise 5). The form of the velocity equation is again kX = k Jo; however, this equation
cannot be inverted by means of the nonnal matrix inverse, because the Jacobian matrix
infinite solutions to 0). Therefore, let us
is nonsquare (three equations, four
of the Jacobian matrix: j* = jT (JJT)
use the Moore—Penrose pseudoinverse
the resulting commanded relative joint rates for the resolved-rate algorithm, 0 = kJ*kX,
MATLAB Exercise 8
choose
the minimum-norm solution from the infinite possibilities (i.e., this specific 0 is
as small as possible to satisfy the commanded Cartesian velocities kX).
This solution represents the particular solution only—that is, there exists a homogeneous solution to optimize performance (such as avoiding manipulator singularities
or avoiding joint limits) in addition to satisfying the commanded Cartesian motion.
Performance optimization is beyond the scope of this exercise.
Given: L1 = 1.0 in, L2 = 1.0 m, L3 = 0.2 in, L4 = 0.2 in.
The initial angles are:
—30°
0—
40°
01021
—0.2
(mIs, rad/s).
Simulate resolved-rate motion, for the particular solution only, for 3 sec, with a
control time step of 0.1 sec. Also, in the same loop, animate the robot to the screen
during each time step, so that you can watch the simulated motion to verify that it is
correct.
a) Present four plots (each set on a separate graph, please):
1. the four joint angles (degrees) 0
02 03 041T vs. time;
2. the four joint rates (radls) e = {Oi °2 03 O4}T vs. time;
3. the joint-rate Eucidean norm 0 (vector magnitude) vs. time;
X = {x y çb}T (rad is fine for
that it will fit) vs. time.
means of the Corke MATLAB Robotics Toolbox. Try function jacobOO. Caution:
The toolbox Jacobian functions are for motion of {4} with respect to {0), not for {H}
Jacobian result in {0} coordinates; jacobn() would give results in {4) coordinates.
9.2 FEEDBACK AND CLOSED-LOOP CONTROL
SECOND-ORDER LINEAR SYSTEMS
9.4 CONTROL OF SECOND-ORDER SYSTEMS
9.5 CONTROL-LAW PARTITIONING
9.6 TRAJECTORY-FOLLOWING CONTROL
9.7 DISTURBANCE REJECTION
9.8 CONTINUOUS VS. DISCRETE TIME CONTROL
9.9 MODELING AND CONTROL OF A SINGLE JOINT
9.10 ARCHITECTURE OF AN INDUSTRIAL-ROBOT CONTROLLER
Armed with the previous material, we now have the means to calculate joint-
position time histories that correspond to desired end-effector motions through
space. In this chapter, we begin to discuss how to cause the manipulator actually to
perform these desired motions.
The control methods that we wifi discuss fall into the class called linear-control
systems. Strictly speaking, the use of linear-control techniques is valid only when
the system being studied can be modeled mathematically by linear differential
equations. For the case of manipulator control, such linear methods must essentially
be viewed as approximate methods, for, as we have seen in Chapter 6, the dynamics
of a manipulator are more properly represented by a nonlinear differential equation.
Nonetheless, we wifi see that it is often reasonable to make such approximations,
and it also is the case that these linear methods are the ones most often used in
current industrial practice.
Finally, consideration of the linear approach will serve as a basis for the
more complex treatment of nonlinear control systems in Chapter 10. Although we
approach linear control as an approximate method for manipulator control, the
justification for using linear controllers is not only empirical. In Chapter 10, we
will prove that a certain linear controller leads to a reasonable control system
even without resorting to a linear approximation of manipulator dynamics. Readers
familiar with linear-control systems might wish to skip the first four sections of the
current chapter.
Section 9.2
Feedback and closed-loop control
FEEDBACK AND CLOSED-LOOP CONTROL
We will model a manipulator as a mechanism that is instrumented with sensors
at each joint to measure the joint angle and that has an actuator at each joint to
apply a torque on the neighboring (next higher) link.1. Although other physical
arrangements of sensors are sometimes used, the vast majority of robots have a
position sensor at each joint. Sometimes velocity sensors (tachometers) are also
present at the joints. Various actuation and transmission schemes are prevalent in
industrial robots, but many of these can be modeled by supposing that there is a
single actuator at each joint.
We wish to cause the manipulator joints to follow prescribed position trajectories, but the actuators are commanded in terms of torque, so we must use some
kind of control system to compute appropriate actuator commands that will realize
this desired motion. Almost always, these torques are determined by using feedback
from the joint sensors to compute the torque required.
Figure 9.1 shows the relationship between the trajectory generator and the
physical robot. The robot accepts a vector of joint torques, r, from the control
system. The manipulator's sensors allow the controller to read the vectors of joint
positions, e, and joint velocities, e. All signal lines in Fig. 9.1 carry N x 1 vectors
(where N is the number of joints in the manipulator).
Let's consider what algorithm might be implemented in the block labeled
"control system" in Fig. 9.1. One possibility is to use the dynamic equation of the
robot (as studied in Chapter 6) to calculate the torques required for a particular
trajectory. We are given ed, ®d, and °d by the trajectory generator, so we could
use (6.59) to compute
+ V(Od, ed) + G(ed).
(9.1)
This computes the torques that our model dictates would be required to realize
the desired trajectory. If our dynamic model were complete and accurate and no
"noise" or other disturbances were present, continuous use of (9.1) along the desired
trajectory would realize the desired trajectory. Unfortunately, imperfection in the
dynamic model and the inevitable presence of disturbances make such a scheme
impractical for use in real applications. Such a control technique is termed an openloop scheme, because there is no use made of the feedback from the joint sensors
FIGURE 9.1: High-level block diagram of a robot-control system.
1Remember all remarks made concerning rotational joints hold analogously for linear joints, and vice
versa
264
(i.e., (9.1) is a function oniy of the desired trajectory, ®d' and its derivatives, and not
function of 0, the actual trajectory).
Generally, the only way to build a high-performance control system is to make
use of feedback from joint sensors, as indicated in Fig. 9.1. Typically, this feedback
is used to compute any servo error by finding the difference between the desired
and the actual position and that between the desired and the actual velocity:
—0,
(9.2)
The control system can then compute how much torque to require of the actuators
as some function of the servo error. Obviously, the basic idea is to compute actuator
torques that would tend to reduce servo errors. A control system that makes use of
feedback is called a closed-loop system. The "loop" closed by such a control system
around the manipulator is apparent in Fig. 9.1.
The central problem in designing a control system is to ensure that the resulting
closed-loop system meets certain performance specifications. The most basic such
criterion is that the system remain stable. For our purposes, we wifi define a system
to be stable if the errors remain "small" when executing various desired trajectories
even in the presence of some "moderate" disturbances. It should be noted that an
improperly designed control system can sometimes result in unstable performance,
in which servo errors are enlarged instead of reduced. Hence, the first task of a
control engineer is to prove that his or her design yields a stable system; the second
is to prove that the closed-loop performance of the system is satisfactory. In practice,
such "proofs" range from mathematical proofs based on certain assumptions and
models to more empirical results, such as those obtained through simulation or
experimentation.
Figure 9.1, in which all signals lines represent N xl vectors, summarizes the fact
that the manipulator-control problem is a multi-input, multi-output (MIMO) control
problem. In this chapter, we take a simple approach to constructing a control system
by treating each joint as a separate system to be controlled. Hence, for an N-jointed
manipulator, we will design N independent single-input, single-output (SISO)
control systems. This is the design approach presently adopted by most industrialrobot suppliers. This independent joint control approach is an approximate method
in that the equations of motion (developed in Chapter 6) are not independent, but
rather are highly coupled. Later, this chapter wifi present justification for the linear
approach, at least for the case of highly geared manipulators.
Before considering the manipulator control problem, let's step back and start by
considering a simple mechanical system. Figure 9.2 shows a block of mass in attached
to a spring of stiffness k and subject to friction of coefficient b. Figure 9.2 also indicates
the zero position and positive sense of x, the block's position. Assuming a frictional
force proportional to the block's velocity, a free-body diagram of the forces acting
on the block leads directly to the equation of motion,
niI+bi+kx =0.
(9.3)
Section 9.3
FIGURE 9.2: Spring—mass
Second-order linear systems
system with friction.
Hence, the open-loop dynamics of this one-degree-of-freedom system are described
by a second-order linear constant-coefficient differential equation [1]. The solution
to the differential equation (9.3) is a time function, x (t), that specifies the motion
of the block. This solution will depend on the block's initial conditions—that is, its
initial position and velocity.
We wifi use this simple mechanical system as an example with which to review
some basic control system concepts. Unfortunately, it is impossible to do justice to
the field of control theory with only a brief introduction here. We wifi discuss the
control problem, assuming no more than that the student is familiar with simple
differential equations. Hence, we wifi not use many of the popular tools of the
control-engineering trade. For example, Laplace transforms and other common
techniques neither are a prerequisite nor are introduced here. A good reference for
the field is [4].
Intuition suggests that the system of Fig. 9.2 might exhibit several different
characteristic motions. For example, in the case of a very weak spring (i.e., k small)
and very heavy friction (i.e., b large) one imagines that, if the block were perturbed,
it would return to its resting position in a very slow, sluggish manner. However,
with a very stiff spring and very low friction, the block might oscifiate several times
before coming to rest. These different possibilities arise because the character of the
solution to (9.3) depends upon the values of the parameters in, b, and k.
From the study of differential equations [1], we know that the form of the
solution to an equation of the form of (9.3) depends on the roots of its characteristic
equation,
ins2+bs-j-k=O.
(9.4)
This equation has the roots
2iii
The location of
(9.5)
and s2 (sometimes called the poles of the system) in the
real—imaginary plane dictate the nature of the motions of the system. If and s2
are real, then the behavior of the system is sluggish and nonoscillatory. If and
are complex (i.e., have an imaginary component) then the behavior of the system is
266
oscifiatory. If we include the special limiting case between these two behaviors, we
have three classes of response to study:
4 ink; that is, friction
dominates, and sluggish behavior results. This response is called overdamped.
2. Complex Roots. This is the case when b2 <4 ink; that is, stiffness dominates,
and oscifiatory behavior results. This response is called underdamped.
1. Real and Unequal Roots. This is the case when b2 >
3. Real and Equal Roots. This is the special case when b2 =
ink; that is,
friction and stiffness are "balanced," yielding the fastest possible nonosdillatory
response. This response is called critically damped.
The third case (critical damping) is generally a desirable situation: the system
nulls out nonzero initial conditions and returns to its nominal position as rapidly as
possible, yet without oscillatory behavior.
Real and unequal roots
It can easily be shown (by direct substitution into (9.3)) that the solution, x(t), giving
the motion of the block in the case of real, unequal roots has the form
x(t) =
(9.6)
+ c2eS2t,
where s1 and s2 are given by (9.5). The coefficients c1 and c2 are constants that can
be computed for any given set of initial conditions (i.e., initial position and velocity
of the block).
Figure 9.3 shows an example of pole locations• and the corresponding time
response to a nonzero initial condition. When the poles of a second-order system
are real and unequal, the system exhibits sluggish or overdamped motion.
In cases where one of the poles has a much greater magnitude than the other,
the pole of larger magnitude can be neglected, because the term corresponding
to it wifi decay to zero rapidly in comparison to the other, dominant pole. This
same notion of dominance extends to higher order systems—for example, often a
FIGURE 9.3:
system.
x(t)
Rejs}
Root location and response to initial conditions for an overdamped
third-order system can be studied as a second-order system by considering only two
dominant poles.
EXAMPLE 9.1
Determine the motion of the system in Fig. 9.2 if parameter values are in = 1, b =
and k
= 6 and the block (initially at rest) is released from the position x = —1.
The characteristic equation is
(9.7)
which has the roots s1
—2 and
Hence, the response has the form
+ c2e_3t
(9.8)
We now use the given initial conditions, x(0) = —1 and i(0) = 0, to compute c1 and
c2. To satisfy these conditions at t = 0, we must have
+ C2 =
—1
—2c1 — 3c2
which are satisfied by c1
given by
—3 and c2
(9.9)
= 2. So, the motion of the system for t ? 0 is
x(t) = _3e_2t + 2e_3t.
(9.10)
Complex roots
For the case where the characteristic equation has complex roots of the form
= A + /Li,
= A—
(9.11)
it is stifi the case that the solution has the form
x(t) = c1eS1t + c2eS2t.
(9.12)
However, equation (9.12) is difficult to use directly, because it involves imaginary
numbers explicitly. It can be shown (see Exercise 9.1) that Euler's formula,
= cosx + i sinx,
(9.13)
allows the solution (9.12) to be manipulated into the form
x(t) = cieAt cos(/Lt) +
(9.14)
As before, the coefficients c1 and c2 are constants that can be computed for any
given set of initial conditions (i.e., initial position and velocity of the block). If we
write the constants c1 and c2 in the form
C1 = r cos 8,
c2=rsin8,
(9.15)
268
then (9.14) can be written in the form
x(t) = rext
(9.16)
(9.17)
8 = Atan2(c2, c1).
In this form, it is easier to see that the resulting motion is an oscifiation whose
amplitude is exponentially decreasing toward zero.
Another common way of describing oscillatory second-order systems is in
terms of damping ratio and natural frequency. These terms are defined by the
parameterization of the characteristic equation given by
(9.18)
is the damping ratio (a dimensionkss number between 0 and 1) and
w71 is the natural frequency.2 Relationships between the pole locations and these
parameters are
(9.19)
the imaginary part of the poles, is sometimes called the
In this terminology,
damped natural frequency. For a damped spring—mass system such as the one in
Fig. 9.2, the damping ratio and natural frequency are, respectively,
(9.20)
0 in our example), the damping ratio becomes
zero; for critical damping (b2 = 4km), the damping ratio is 1.
Figure 9.4 shows an example of pole locations and the corresponding time
are complex, the system exhibits oscifiatory or underdamped motion.
When no damping is present (b =
EXAMPLE 9.2
Find the motion of the system in Fig. 9.2 if parameter values are m =
k = 1 and the block (initially at rest) is released from the position x =
—1.
s2+s+1=0,
(9.21)
2The terms damping ratio and natural frequency can also be applied to overdamped systems, in which
> 1.0.
case
Re(s}
FIGURE 9.4: Root location and response to initial conditions for an underdamped
which has the roots
x(t) = e
+ c2 sin
c1 cos
(9.22)
We now use the given initial conditions, x (0) = —1 and (0) = 0, to compute
c1 and c2. To satisfy these conditions at t = 0, we must have
C1 = —1
which are satisfied by c1 = —1 and c2
(9.23)
So, the motion of the system for t
(9.24)
This result can also be put in the form of (9.16), as
(4t + 1200).
(9.25)
Real and equal roots
By substitution into (9.3), it can be shown that, in the case of real and equal roots
(i.e., repeated roots), the solution has the form
x(t) = c1eSlt + c2teS2t,
(9.26)
270
Chapter 9
Tm(s)
Re(s)
9.5: Root location and response to initial conditions for a critically damped
where, in this case, s1
(9.26) can be written
x(t) = (c1 +
(9.27)
In case it is not clear, a quick application of l'Hôpital's rule [2] shows that, for
any c1, c2, and a,
urn (c1
+ c7t)e_at = 0.
(9.28)
Figure 9.5 shows an example of pole locations and the corresponding time
are real and equal, the system exhibits critically damped motion, the fastest possible
nonoscifiatory response.
EXAMPLE 9.3
Work out the motion of the system in Fig. 9.2 if parameter values are in = 1, b = 4,
= 4 and the block (initially at rest) is released from the position x = —1.
(9.29)
—2. Hence, the response has the form
x(t) = (c1 + c7t)e_2t.
(9.30)
We now use the given initial conditions, x(0) = —1 and ±(0) = 0, to calculate
Cl = —1
—2c1 + c2 = 0,
(9.31)
which are satisfied by c1 = —1 and c2 = —2. So, the motion of the system for t
(—1 — 2t)e_2t.
(9.32)
Section 9.4
Control of second-order systems
In Examples 9.1 through 9.3, all the systems were stable. For any passive
physical system like that of Fig. 9.2, this will be the case. Such mechanical systems
always have the properties
in >0,
(9.33)
k >0.
In the next section, we wifi see that the action of a control system is, in effect, to
change the value of one or more of these coefficients. It will then be necessary to
consider whether the resulting system is stable.
Suppose
that the natural response of our second-order mechanical system is not
what we wish it to be. Perhaps it is underdamped and oscillatory, and we would like
it to be critically damped; or perhaps the spring is missing altogether (k = 0), so the
system never returns to x = 0 if disturbed. Through the use of sensors, an actuator,
and a control system, we can modify the system's behavior as desired.
Figure 9.6 shows a damped spring—mass system with the addition of an actuator
with which it is possible to apply a force f to the block. A free-body diagram leads
to the equation of motion,
nil +
(9.34)
Let's also assume that we have sensors capable of detecting the block's position and
velocity. We now propose a control law which computes the force that should be
applied by the actuator as a function of the sensed feedback:
(9.35)
Figure 9.7 is a block diagram of the closed-loop system, where the portion to the left
of the dashed line is the control system (usually implemented in a computer) and
that to the right of the dashed line is the physical system. Implicit in the figure are
interfaces between the control computer and the output actuator commands and
the input sensor information.
The control system we have proposed is a position-regulation system—it
simply attempts to maintain the position of the block in one fixed place regardless
FIGURE 9.6:
A damped spring—mass system with an actuator.
272
A closed-loop control system. The control computer (to the left of the
dashed line) reads sensor input and writes actuator output commands.
FIGURE 9.7:
of disturbance forces applied to the block. In a later section, we will construct a
trajectory-following control system, which can cause the block to follow a desired
position trajectory.
By equating the open-loop dynamics of (9.34) with the control law of (9.35),
we can derive the closed-loop dynamics as
ml + bi + kx =
(9.36)
(9.37)
and (9.38), it is clear that, by setting
we can cause the closed-loop system to appear to have
the control gains, and
any second system behavior that we wish. Often, gains would be chosen to obtain
and some desired closed-loop stiffness given
critical damping (i.e., b' =
directly by k'.
Note that and could be positive or negative, depending on the parameters
of the original system. However, if b' or k' became negative, the result would be
an unstable control system. This instability will be obvious if one writes down the
solution of the second-order differential equation (in the form of (9.6), (9.14), or
(9.26)). It also makes intuitive sense that, if b' or k' is negative, servo errors tend to
get magnified rather than reduced.
EXAMPLE 9.4
If the parameters of the system in Fig. 9.6 are in = 1, b = 1, and k =
find gains
for a position-regulation control law that results in the system's being
critically damped with a closed-loop stiffness of 16.0.
Section 9.5
Control-law partitioning
we wish k' to be 16.0, then, for critical damping,
= 8.0. Now, k = 1 and b = 1, so we need
we require that b' =
= 15.0,
= 7.0.
(9.39)
CONTROL-LAW PARTITIONING
In preparation for designing control laws for more complicated systems, let us
consider a slightly different controller structure for the sample problem of Fig. 9.6.
In this method, we wifi partition the controller into a model-based portion and a
servo portion. The result is that the system's parameters (i.e., in, b, and k, in this case)
appear only in the model-based portion and that the servo portion is independent
of these parameters. At the moment, this distinction might not seem important,
but it wifi become more obviously important as we consider nonlinear systems
in Chapter 10. We will adopt this control-law partitioning approach throughout
the book.
The open-loop equation of motion for the system is
ml + hi + kx = f.
(9.40)
We wish to decompose the controller for this system into two parts. In this case, the
model-based portion of the control law wifi make use of supposed knowledge of in,
b, and k. This portion of the control law is set up such that it reduces the system so
that it appears to be a unit mass. This will become clear when we do Example 9.5.
The second part of the control law makes use of feedback to modify the behavior of
the system. The model-based portion of the control law has the effect of making the
system appear as a unit mass, so the design of the servo portion is very simple—gains
are chosen to control a system composed of a single unit mass (i.e., no friction, no
stiffness).
The model-based portion of the control appears in a control law of the form
(9.41)
where u and are functions or constants and are chosen so that, if f'is taken as the
new input to the system, the system appears to be a unit mass. With this structure of
the control law, the system equation (the result of combining (9.40) and (9.41)) is
inl+bi+kx =af'+tl.
(9.42)
Clearly, in order to make the system appear as a unit mass from the f' input, for
this particular system we should choose a and as follows:
a = in,
(9.43)
Making these assignments and plugging them into (9.42), we have the system
equation
I = f'.
(9.44)
274
FIGURE 9.8:
A closed-loop control system employing the partitioned control method.
This is the equation of motion for a unit mass. We now proceed as if (9.44) were
the open-loop dynamics of a system to be controlled. We design a control law to
compute f ', just as we did before:
(9.45)
Combining this control law with (9.44) yields
(9.46)
Under this methodology, the setting of the control gains is simple and is independent
of the system parameters; that is,
(9.47)
must hold for critical damping. Figure 9.8 shows a block diagram of the partitioned
controller used to control the system of Fig. 9.6.
EXAMPLE 9.5
If the parameters of the system in Fig. 9.6 are in = 1, b = 1, and k = 1, find a, and
and for a position-regulation control law that results in the system's
the gains
being critically damped with a closed-loop stiffness of 16.0.
We choose
a = 1,
(9.48)
so that the system appears as a unit mass from the fictitious f'input. We then set
for critical damping.
to the desired closed-loop stiffness and set =
gain
Section 9.6
Trajectory-following control
This gives
16.0,
= 8.0.
(9.49)
TRAJECTORY-FOLLOWING CONTROL
Rather than just maintaining the block at a desired location, let us enhance our
controller so that the block can be made to follow a trajectory. The trajectory is
given by a ftnction of time, xd(t), that specifies the desired position of the block.
We assume that the trajectory is smooth (i.e., the first two derivatives exist) and that
our trajectory generator provides xd, ia, and 1d at all times t. We define the servo
error between the desired and actual trajectory as e = xd — x. A servo-control law
that will cause trajectory following is
(9.50)
We see that (9.50) is a good choice if we combine it with the equation of motion of
a unit mass (9.44), which leads to
(9.51)
(9.52)
This is a second-order differential equation for which we can choose the coefficients,
so we can design any response we wish. (Often, critical damping is the choice made.)
Such an equation is sometimes said to be written in error space, because it describes
the evolution of errors relative to the desired trajectory. Figure 9.9 shows a block
diagram of our trajectory-following controller.
If our model is perfect (i.e., our knowledge of in, b, and k), and if there is
no noise and no initial error, the block will follow the desired trajectory exactly. If
there is an initial error, it will be suppressed according to (9.52), and thereafter the
system wifi follow the trajectory exactly.
FIG URE 9.9: A trajectory-following controller for the system in Fig. 9.6.
Chapter 9
DISTURBANCE REJECTION
rejection, that
of the purposes of a control system is to provide
is, to maintain good performance (i.e., minimize errors) even in the presence of
some external disturbances or noise. In Fig. 9.10, we show the trajectory-following
An analysis of our
controller with an additional input: a disturbance force
closed-loop system leads to the error equation
(9.53)
Equation (9.53) is that of a differential equation driven by a forcing function.
is bounded—that is, that a constant a exists such that
If it is known that
(9.54)
then the solution of the differential equation, e(t), is also bounded. This result is due
to a property of stable linear systems known as bounded-input, bounded-output or
BIIBO stability {3, 4]. This very basic result ensures that, for a large class of possible
disturbances, we can at least be assured that the system remains stable.
Steady-state error
is a constant. In
this case, we can perform a steady-state analysis by analyzing the system at rest (i.e.,
the derivatives of all system variables are zero). Setting derivatives to zero in (9.53)
yields the steady-state equation
Let's consider the simplest kind of disturbance—namely, that
(9.55)
= fdist/kp.
(9.56)
The value of e given by (9.56) represents a steady-state error. Thus, it is clear that
the smaller will be the steady-state error.
the higher the position gain
FIG U RE 9.10: A trajectory-following control system with a disturbance acting.
Section 9.8
Continuous vs. discrete time control
Addition of an integral term
In order to eliminate steady-state error, a modified control law is sometimes used.
The modification involves the addition of an integral term to the control law. The
control law becomes
+ k1 f edt,
(9.57)
which results in the error equation
(9.58)
The term is added so that the system wifi have no steady-state error in the presence
of constant disturbances. If e(t) = 0 for t < 0, we can write (9.58) for t > 0 as
fdist'
(9.59)
which, in the steady state (for a constant disturbance), becomes
(9.60)
(9.61)
With this control law, the system becomes a third-order system, and one can
solve the corresponding third-order differential equation to work out the response
of the system to initial conditions. Often, is kept quite small so that the third-order
system is "close" to the second-order system without this term (i.e., a dominantpole analysis can be performed). The form of control law (9.57) is called a P11.)
control law, or "proportional, integral, derivative" control law [4]. For simplicity,
the displayed equations generally do not show an integral term in the control laws
that we develop in this book.
CONTINUOUS VS. DISCRETE TIME CONTROL
In the control systems we have discussed, we implicitly assumed that the control
computer performs the computation of the control law in zero time (i.e., infinitely
fast), so that the value of the actuator force f is a continuous function of time. Of
course, in reality, the computation requires some time, and the resulting commanded
force is therefore a discrete "staircase" function. We shall employ this approximation
of a very fast control computer throughout the book. This approximation is good
if the rate at which new values of f are computed is much faster than the natural
frequency of the system being controlled. In the field of discrete time control or
digital control, one does not make this approximation but rather takes the servo
rate of the control system into account when analyzing the system [3].
We will generally assume that the computations can be performed quickly
enough that our continuous time assumption is valid. This raises a question: How
quick is quick enough? There are several points that need to be considered in
choosing a sufficiently fast servo (or sample) rate:
278
Tracking reference inputs: The frequency content of the desired or reference input
places an absolute lower bound on the sample rate. The sample rate must be
at least twice the bandwidth of reference inputs. This is usually not the limiting
factor.
Disturbance rejection: In disturbance rejection, an upper bound on performance
is given by a continuous-time system. If the sample period is longer than the
correlation time of the disturbance effects (assuming a statistical model for
random disturbances), then these disturbances wifi not be suppressed. Perhaps
a good rule of thumb is that the sample period should be 10 times shorter than
the correlation time of the noise [3].
Antialiasing: Any time an analog sensor is used in a digital control scheme, there
wifi be a problem with aliasing unless the sensor's output is strictly band
limited. In most cases, sensors do not have a band limited output, and so
sample rate should be chosen such that the amount of energy that appears in
the aliased signal is small.
Structural resonances: We have not included bending modes in our characterization
of a manipulator's dynamics. All real mechanisms have finite stiffness and so
wifi be subject to various kinds of vibrations. If it is important to suppress these
vibrations (and it often is), we must choose a sample rate at least twice the
natural frequency of these resonances. We wifi return to the topic of resonance
later in this chapter.
MODELING AND CONTROL OF A SINGLE JOINT
In this section, we wifi develop a simplified model of a single rotary joint of a
manipulator. A few assumptions wifi be made that wifi allow us to model the
resulting system as a second-order linear system. For a more complete model of an
actuated joint, see [5].
A common actuator found in many industrial robots is the direct current (DC)
torque motor (as in Fig. 8.18). The nonturning part of the motor (the stator) consists
of a housing, bearings, and either permanent magnets or electromagnets. These
stator magnets establish a magnetic field across the turning part of the motor (the
rotor). The rotor consists of a shaft and windings through which current moves to
power the motor. The current is conducted to the windings via brushes, which make
contact with the commutator. The commutator is wired to the various windings (also
called the armature) in such a way that torque is always produced in the desired
direction. The underlying physical phenomenon [6] that causes a motor to generate
a torque when current passes through the windings can be expressed as
(9.62)
where charge q, moving with velocity V through a magnetic field B, experiences a
force F. The charges are those of electrons moving through the windings, and the
magnetic field is that set up by the stator magnets. Generally, the torque-producing
ability of a motor is stated by means of a single motor torque constant, which relates
armature current to the output torque as
(9.63)
Section 9.9
Modeling and control of a single joint
When a motor is rotating, it acts as a generator, and a voltage develops across the
armature. A second motor constant, the back emf constant,3 describes the voltage
generated for a given rotational velocity:
v = ke8i)i.
(9.64)
Generally, the fact that the commutator is switching the current through various sets
of windings causes the torque produced to contain some torque ripple. Although
sometimes important, this effect can usually be ignored. (In any case, it is quite hard
to model—and quite hard to compensate for, even if it is modeled.)
Motor-armature inductance
Figure 9.11 shows the electric circuit of the armature. The major components are a
voltage source, V0, the inductance of the armature windings, the resistance of the
armature windings, ra, and the generated back emf, v. The circuit is described by a
first-order differential equation:
iota +
Va — keOin.
(9.65)
It is generally desirable to control the torque generated by the motor (rather than
the velocity) with electronic motor driver circuitry. These drive circuits sense the
current through the armature and continuously adjust the voltage source Va 50 that
a desired current flows through the armature. Such a circuit is called a
amplifier motor driver [7]. In these current-drive systems, the rate at which the
armature current can be commanded to change is limited by the motor inductance
1a and by an upper liniit on the voltage capability of the voltage source
The net
effect is that of a low-pass filter between the requested current and output torque.
Our first simplifying assumption is that the inductance of the motor can be
neglected. This is a reasonable assumption when the natural frequency of the closedloop control system is quite low compared to the cut-off frequency of the implicit
low-pass ifiter in the current-drive circuitry due to the inductance. This assumption,
along with the assumption that torque ripple is a negligible effect, means that we can
essentially command torque directly. Although there might be a scale factor (such
to contend with, we wifi assume that the actuator acts as a pure torque source
that we can command directly.
9.11: The armature circuit of a DC torque motor.
3"emf" stands for electromotive force.
280
a/fl
Mechanical model of a DC torque motor connected through gearing to
an inertial load.
FIGURE 9.12:
Effective inertia
Figure 9.12 shows the mechanical model of the rotor of a DC torque motor connected
through a gear reduction to an inertial load. The torque applied to the rotor, tm, is
given by (9.63) as a function of the current flowing in the armature circuit. The
gear ratio (11) causes an increase in the torque seen at the load and a reduction in
the speed of the load, given by
(9.66)
yields
> 1. Writing a torque balance for this system in terms of torque at the rotor
+ (1/17) (Jo + be),
(9.67)
where and I are the inertias of the motor rotor and of the load, respectively, and
and b are viscous friction coefficients for the rotor and load bearings, respectively.
Using the relations (9.66), we can write (9.67) in terms of motor variables as
(9.68)
or in terms of load variables as
= (I +
+ (b +
(9.69)
The term I + 172 is sometimes called the effective inertia "seen" at the output
can be called the effective
(link side) of the gearing. Likewise, the term b +
damping. Note that, in a highly geared joint (i.e., 17 >> 1), the inertia of the motor
rotor can be a significant portion of the combined effective inertia. It is this effect that
allows us to make the assumption that the effective inertia is a constant. We know
Modeling and control of a single joint
Section 9.9
from Chapter 6 that the inertia, I, of a joint of the mechanism actually varies with
configuration and load. However, in highly geared robots, the variations represent
a smaller percentage than they would in a direct-drive manipulator (i.e., = 1). To
ensure that the motion of the robot link is never underdamped, the value used for I
should be the maximum of the range of values that I takes on; we'll call this value
This choice results in a system that is critically damped or overdamped in all
situations. In Chapter 10, we will deal with varying inertia directly and will not have
to make this assumption.
EXAMPLE 9.6
If the apparent link inertia, I, varies between 2 and 6 Kg-m2, the rotor inertia is
= 0.01, and the gear ratio is = 30, what are the minimum and maximum of the
effective inertia?
The minimum effective inertia is
= 2.0 + (900)(0.01) = 11.0;
(9.70)
'max +
(9.71)
the maximum is
6.0 + (900) (0.01) = 15.0.
Hence, we see that, as a percentage of the total effective inertia, the variation of
inertia is reduced by the gearing.
Unmodeled flexibility
The other major assumption we have made in our model is that the gearing, the
shafts, the bearings, and the driven link are not flexible. In reality, all of these
elements have finite stiffness, and their flexibility, if modeled, would increase the
order of the system. The argument for ignoring flexibility effects is that, if the system
is sufficiently stiff, the natural frequencies of these unmodeled resonances are very
high and can be neglected compared to the influence of the dominant second-order
poles that we have modeled.4 The term "unmodeled" refers to the fact that, for
purposes of control-system analysis and design, we neglect these effects and use a
simpler dynamic model, such as (9.69).
Because we have chosen not to model structural flexibiities in the system,
we must be careful not to excite these resonances. A rule of thumb [8] is that, if
the lowest structural resonance is cores, then we must limit our closed-loop natural
frequency according to
(9.72)
This provides some guidance on how to choose gains in our controller. We have seen
that increasing gains leads to faster response and lower steady-state error, but we
now see that unmodeled structural resonances limit the magnitude of gains. Typical
industrial manipulators have structural resonances in the range from 5 Hz to 25 Hz
[8]. Recent designs using direct-drive arrangements that do not contain flexibility
4This is basically the same argument we used to neglect the pole due to the motor inductance.
Including it would also have raised the order of the overall system.
282
introduced by reduction and transmission systems have their lowest structural
resonances as high as 70 Hz [9].
EXAMPLE 9.7
Consider the system of Fig. 9.7 with the parameter values in = 1,
b = 1, and k = 1.
Additionally, it is known that the lowest unmodeled resonance of the system is at
8 radians/second. Find a, and gains
for a position-control law so the
system is critically damped, doesn't excite unmodeled dynamics, and has as high a
closed-loop stiffness as possible.
(9.73)
that the system appears as a unit mass from the fictitious f' input. Using
our rule of thumb (9.72), we choose the closed-loop natural frequency to be
= 4 radians/second. From (9.18) and (9.46), we have = co2, so
= 16.0,
(9.74)
Estimating resonant frequency
The same sources of structural flexibility discussed in Chapter 8 give rise to reso-
nances. In each case where a structural flexibility can be identified, an approximate
analysis of the resulting vibration is possible if we can describe the effective mass
or inertia of the flexible member. This is done by approximating the situation by a
simple spring—mass system, which, as given in (9.20), exhibits the natural frequency
(9.75)
where k is the stiffness of the flexible member and in is the equivalent mass displaced
in vibrations.
EXAMPLE 9.8
A shaft (assumed massless) with a stiffness of 400 Nt-rn/radian drives a rotational
inertia of 1 Kg-m2. If the shaft stiffness was neglected in the modeling of the
dynamics, what is the frequency of this unmodeled resonance?
Using (9.75), we have
= \/400/1 = 20 rad/second = 20/(27r)Hz
3.2 Hz.
(9.76)
For the purposes of a rough estimate of the lowest resonant frequency of
beams and shafts, [10] suggests using a lumped model of the mass. We already
0.23 in
0.33
FIGURE 9.13:
Lumped models of beams for estimation of lowest lateral and torsional
resonance.
have formulas for estimating stiffness at the ends of beams and shafts; these lumped
models provide the effective mass or inertia needed for our estimation of resonant
frequency. Figure 9.13 shows the results of an energy analysis [10] which suggests
that a beam of mass rn be replaced by a point mass at the end of 0.23 in and, likewise,
that a distributed inertia of I be replaced by a lumped 0.33 I at the end of the shaft.
EXAMPLE 9.9
A link of mass 4.347 Kg has an end-point lateral stiffness of 3600 Nt/m. Assuming
the drive system is completely rigid, the resonance due to the flexibility of the link
wifi limit control gains. What is Wres?
The 4.347 Kg mass is distributed along the link. Using the method of Fig. 9.13,
the effective mass is (0.23) (4.347) 1.0 Kg. Hence, the vibration frequency is
Wres =
= 60 radians/second = 60/(27r)Hz
9.6 Hz.
(9.77)
The inclusion of structural flexibilities in the model of the system used for
control-law synthesis is required if we wish to achieve closed-loop bandwidths higher
than that given by (9.75). The resulting system models are of high order, and the
control techniques applicable to this situation become quite sophisticated. Such
control schemes are currently beyond the state of the art of industrial practice but
are an active area of research [11, 12].
Control of a single joint
In summary, we make the following three major assumptions:
1. The motor inductance 1a can be neglected.
2. Taking into account high gearing, we model the effective inertia as a constant
equal to 'max +
3. Structural flexibilities are neglected, except that the lowest structural resonance
is used in setting the servo gains.
284
With these assumptions, a single joint of a manipulator can be controlled with
the partitioned controller given by
a = 'max +
= (b +
(9.78)
r=8d+kVe+kPe.
(9.79)
The resulting system closed-loop dynamics are
(9.80)
where the gains are chosen as
9.10
Wres.
(9.81)
ARCHITECTURE OF AN INDUSTRIAL-ROBOT CONTROLLER
In this section, we briefly look at the architecture of the control system of the
Unimation PUMA 560 industrial robot. As shown in Fig. 9.14, the hardware archi-
tecture is that of a two-level hierarchy, with a DEC LSI-11 computer serving as
the top-level "master" control computer passing cormnands to six Rockwell 6503
microprocessors.5 Each of these microprocessors controls an individual joint with
a PID control law not unlike that presented in this chapter. Each joint of the
PUMA 560 is instrumented with an incremental optical encoder. The encoders are
interfaced to an up/down counter, which the microprocessor can read to obtain the
current joint position. There are no tachometers in the PUMA 560; rather, joint
positions are differenced on subsequent servo cycles to obtain an estimate of joint
velocity. In order to command torques to the DC torque motors, the microprocessor
FIG U RE 9.14: Hierarchical computer architecture of the PUMA 560 robot-control
5These simple 8-bit computers are already old technology. It is common these days for robot
controllers to be based on 32-bit microprocessors.
FIG U RE 9.15:
Functional blocks of the joint-control system of the PUMA 560.
interfaced to a digital-to-analog converter (DAC) so that motor currents can be
commanded to the current-driver circuits. The current flowing through the motor is
controlled in analog circuitry by adjusting the voltage across the armature as needed
to maintain the desired armature current. A block diagram is shown in Fig. 9.15.
Each 28 milliseconds, the LSI-11 computer sends a new position command
(set-point) to the joint microprocessors. The joint microprocessors are running on a
0.875 millisecond cycle. In this time, they interpolate the desired position set-point,
compute the servo error, compute the PID control law, and command a new value
of torque to the motors.
The LSI-11 computer carries out all the "high-level" operations of the overall
control system. First of all, it takes care of interpreting the VAL (Uriimation's
robot programming language) program commands one by one. When a motion
command is interpreted, the LSI-11 must perform any needed inverse kinematic
computations, plan a desired trajectory, and begin generating trajectory via points
every 28 miffiseconds for the joint controllers.
The LSI-11 is also interfaced to such standard peripherals as the terminal and
a floppy disk drive. In addition, it is interfaced to a teach pendant. A teach pendant
is a handheld button box that allows the operator to move the robot around in a
variety of modes. For example, the PUMA 560 system allows the user to move the
robot incrementally in joint coordinates or in Cartesian coordinates from the teach
pendant. In this mode, teach-pendant buttons cause a trajectory to be computed
"on the fly" and passed down to the joint-control microprocessors.
[1] W. Boyce and R. DiPrima, Elenwntary Differential Equations, 3rd edition, John Wiley
and Sons, New York, 1977.
[2] E. Purcell, Calculus with Analytic Geometry, Meredith Corporation, New York, 1972.
[3] G. Franklin and J.D. Powell, Digital Control of Dynamic Systems, Addison-Wesley,
Reading, MA, 1980.
[4] G. Franklin, J.D. Powell, and A. Emami-Naeini, Feedback Control of Dynamic Systems, Addison-Wesley, Reading, MA, 1986.
J. Luh, "Conventional Controller Design for Industrial Robots—a Tutorial," IEEE
Transactions on Systems, Man, and Cybernetics, Vol. SMC-13, No. 3, June 1983.
[6] D. Haffiday and R. Resnik, Fundamentals of Physics, Wiley, New York 1970.
286
[7] Y. Koren and A. Ulsoy, "Control of DC Servo-Motor Driven Robots," Proceedings
of Robots 6 Conference, SIvifi, Detroit, March 1982.
[8] R.P. Paul, Robot Manipulators, MIT Press, Cambridge, MA, 1981.
[9] H. Asada and K. Youcef-Toumj, Direct-Drive Robots—Theory and Practice, MIT
Press, Cambridge, MA, 1987.
[10] J. Shigley, Mechanical Engineering Design, 3rd edition, McGraw-Hill, New York, 1977.
[11] W. Book, "Recursive Lagrangian Dynamics of Flexible Manipulator Arms," The
International Journal of Robotics Research, Vol. 3, No. 3, 1984.
[12] R. Cannon and E. Sclmiitz, "Initial Experiments on the End-Point Control of a
Flexible One Link Robot," The International Journal of Robotics Research, Vol. 3,
No. 3, 1984.
[13] R.J. Nyzen, "Analysis and Control of an Eight-Degree-of-Freedom Manipulator,"
Ohio University Master's Thesis, Mechanical Engineering, Dr. Robert L. Wffliams II,
Advisor, August 1999.
[14] R.L. Williams II, "Local Performance Optimization for a Class of Redundant EightDegree-of-Freedom Manipulators," NASA Technical Paper 3417, NASA Langley
Research Center, Hampton, VA, March 1994.
[20] For a second-order differential equation with complex roots
show that the general solution
+ c9eS2t,
can be written
c1eAt
cos(jst) + c2eAt
9.2 [13] Compute the motion of the system in Fig. 9.2 if parameter values are in = 2,
b = 6, and k = 4 and the block (initially at rest) is released from the position
x =1.
9.3 [13] Compute the motion of the system in Fig. 9.2 if parameter values are in = 1,
b = 2, and k = 1 and the block (initially at rest) is released from the position
x =4.
9.4 [13] Compute the motion of the system in Fig. 9.2 if parameter values are in = 1,
b = 4, and k = 5 and the block (initially at rest) is released from the position
x =2.
9.5 [15] Compute the motion of the system in Fig. 9.2 if parameter values are in = 1,
b = 7, and k = 10 and the block is released from the position x = 1 with an initial
velocity of x = 2.
9.6 [15] Use the (1, 1) element of (6.60) to compute the variation (as a percentage
of the maximum) of the inertia "seen" by joint 1 of this robot as it changes
configuration. Use the numerical values
0.5 m,
in1 = 4.0 Kg,
ifl2 =2.0Kg.
Programming exercise (Part 9)
Consider that the robot is direct drive and that the rotor inertia is negligible.
9.7 [17] Repeat Exercise 9.6 for the case of a geared robot (use = 20) and a rotor
inertia of = 0.01 Kg m2.
9.8 [18] Consider the system of Fig. 9.6 with the parameter values in = 1, b = 4,
and k = 5. The system is also known to possess an unmodeled resonance at
that will critically damp
Wres = 6.0 radians/second. Determine the gains
the system with as high a stiffness as is reasonable.
9.9 [25] In a system like that of Fig. 9.12, the inertial load, I, varies between 4 and
5 Kg-rn2. The rotor inertia is
= 0.01 Kg-rn2, and the gear ratio is = 10.
The system possesses uninodeled resonances at 8.0, 12.0, and 20.0 radians/second.
and such
Design a and fi of the partitioned controller and give the values of
that the system is never underdamped and never excites resonances, but is as stiff
9.10 [18] A designer of a direct-drive robot suspects that the resonance due to beam
flexibility of the link itself will be the cause of the lowest unmodeled resonance. If
the link is approximately a square-cross-section beam of dimensions 5 x 5 x 50 cm
with a 1-cm wall thickness and a total mass of 5 Kg, estimate cores.
9.11 [15] A direct-drive robot link is driven through a shaft of stiffness 1000 Nt-rn/radian.
The link inertia is 1 Kg-m2. Assuming the shaft is massless, what is Wres?
9.12 [18] A shaft of stiffness 500 Nt-mlradian drives the input of a rigid gear pair with
1) = 8. The output of the gears drives a rigid link of inertia 1 Kg-rn2. What is the
C0res caused by flexibility of the shaft?
9.13 [25] A shaft of stiffness 500 Nt-rn/radian drives the input of a rigid gear pair with
= 8. The shaft has an inertia of 0.1 Kg-rn2. The output of the gears drives a rigid
link of inertia 1 Kg-rn2. What is the Wres caused by flexibility of the shaft?
9.14 [28] In a system like that of Fig. 9.12, the inertial load, I, varies between 4 and
= 0.01 Kg-rn2, and the gear ratio is = 10. The
system possesses an unmodeled resonance due to an end-point stiffness of the
link of 2400 Nt-rn/radian. Design a and fi of the partitioned controller, and give
and k0 such that the system is never underdamped and never
the values of
excites resonances, but is as stiff as possible.
9.15 [25] A steel shaft of length 30 cm and diarneter 0.2 cm drives the input gear of a
reduction of 17 = 8. The rigid output gear drives a steel shaft of length 30 cm and
diameter 0.3 cm. What is the range of resonant frequencies observed if the load
inertia varies between 1 and 4 Kg-rn2?
PROGRAMMING EXERCISE (PART 9)
We wish to simulate a simple trajectory-following control systern for the three-link planar
arrn. This control system will be implemented as an independent-joint PD (proportional
plus derivative) control law. Set the servo gains to achieve closed-loop stiffnesses of
175.0, 110.0, and 20.0 for joints 1 through 3 respectively. Try to achieve approximate
critical damping.
Use the simulation routine UPDATE to simulate a discrete-time servo running
at 100 Hz—that is, calculate the control law at 100 Hz, not at the frequency of the
numerical integration process. Test the control scheme on the following tests:
1. Start the arm at 0 = (60, —110, 20) and command it to stay there until time = 3.0,
when the set-points should instantly change to 0 = (60, —50, 20). That is, give a
step input of 60 degrees to joint 2. Record the error—time history for each joint.
2. Control the arm to follow the cubic-spline trajectory from Programming Exercise
Part 7. Record the error—time history for each joint.
288
MATLAB EXERCISE 9
This exercise focuses on linearized independent joint-control simulation for the shoulder
joint (joint 2) of the NASA eight-axis AAI ARJVIII (Advanced Research Manipulator II)
manipulator arm—see [14]. Familiarity with linear classical feedback-control systems,
including block diagrams and Laplace transforms, is assumed. We will use Simulink, the
graphical user interface of MATLAB.
Figure 9.16 shows a linearized open-loop system-dynamics model for the ARMII
electromechanical shoulder joint/link, actuated by an armature-controller DC servomotor. The open-loop input is reference voltage
(boosted to armature voltage via an
amplifier), and the output of interest is the load shaft angle ThetaL. The figure also
shows the feedback-control diagram, where the load-shaft angle is sensed via an optical
encoder and provided as feedback to the PTD controller. The table describes all system
parameters and variables.
If we reflect the load shaft inertia and damping to the motor shaft, the effective
polar inertia and damping coefficient are J =
+ JL(t)/n2 and C = CM + CL/n2.
By virtue of the large gear ratio n, these effective values are not much different
from the motor-shaft values. Thus, the gear ratio allows us to ignore variations in the
configuration-dependent load-shaft inertia (t) and just set a reasonable average value.
The ARJVHI shoulder joint constant parameters are given in the accompanying
table [13]. Note that we can use the English units directly, because their effect cancels out
inside the control diagram. Also, we can directly use deg units for the angle. Develop a
Simulink model to simulate the single-joint control model from the model and feedbackcontrol diagram shown; use the specific parameters from the table. For the nominal case,
determine the PID gains by trial and error for "good" performance (reasonable percent
overshoot, rise time, peak time, and settling time). Simulate the resulting motion for
moving this shoulder joint for a step input of 0 to 60 deg. Plot the simulated load-angle
value over time, plus the load-shaft angular velocity over time. In addition, plot the
Door rotio
Integrator
Open-Loop Electromechanieal System Diagrom
Commanded
metaL
Encoder
Closed-Loop Feedback Control Diagram
FIGURE 9.16: Linearized open-loop system-dynamics model for the ARMII electromechanical shoulder joint/link, actuated by an armature-controller DC servomotor.
MATLAB Exercise 9
TABLE 9.1: ARMII shoulder loirit constant parameters.
armature -rM(t)
voltage
Va(t)
L = 0.0006H armature 9M(t)
1.40Q
armature
coM(t)
resistance
Vb (t)
TL(t)
load torque
motor shaft
OL(t)
load shaft
angle
WL(t)
velocity
inductance
generated
torque
(t) = 1 lumped load
= 0.00844 lumped
current
motor polar lbf -in-s2 polar inertia
lbf -in-s2
inertia
back emf CM = 0.00013 motor shaft
lbf-in/deg/s
viscous
damping
lbfin/deg/s
coefficient
= 12
amplifier
n = 200
Kb = 0.00867 back emf KM = 4.375
V/deg/s
constant lbf -in/A
gear ratio
stant
gravity
(ignore
gravity at
first)
encoder
transfer
function
in/s2
torque con-
control effort—that is, the armature voltage Va over time. (On the same graph, also give
the back emf Vb.)
Now, try some changes—Simulink is so easy and enjoyable to change:
1) The step input is frustrating for controller design, so try a ramped step input
instead: Ramp from 0 to 60 deg in 1.5 sec, then hold the 60-deg command for all
time greater than 1.5 sec. Redesign PID gains and restimulate.
2) Investigate whether the inductor L is significant in this system. (The electrical system rises much faster than the mechanical system—this effect can be represented
by time constants.)
and CL). With
3) We don't have a good estimate for the load inertia and damping
your best PID gains from before, investigate how big these values can grow (scale
the nominal parameters up equally) before they affect the system.
4) Now, include the effect of gravity as a disturbance to the motor torque TM. Assume
that the moving robot mass is 200 lb and the moving length beyond joint 2 is 6.4
feet. Test for the nominal "good" PID gains you found; redesign if necessary. The
shoulder load angle 87 zero configuration is straight up.
Nonlinear control
of manipulators
10.1 INTRODUCTION
10.2 NONLINEAR AND TIME-VARYING SYSTEMS
10.3 MULTI-INPUT, MULTI-OUTPUT CONTROL SYSTEMS
10.4 THE CONTROL PROBLEM FOR MANIPULATORS
10.5 PRACTICAL CONSIDERATIONS
10.6 CURRENT INDUSTRIAL-ROBOT CONTROL SYSTEMS
10.7 LYAPUNOV STABILITY ANALYSIS
10.8 CARTESIAN-BASED CONTROL SYSTEMS
10.9 ADAPTIVE CONTROL
10.1
In the previous chapter, we made several approximations to allow a linear analysis of
the manipulator-control problem. Most important among these approximations was
that each joint could be considered independent and that the inertia "seen" by each
joint actuator was constant. In implementations of linear controllers as introduced in
the previous chapter, this approximation results in nonuniform damping throughout
the workspace and other undesirable effects. In this chapter, we wifi introduce a
more advanced control technique for which this assumption wifi not have to be
made.
In Chapter 9, we modeled the manipulator by n independent second-order
differential equations and based our controller on that model. In this chapter, we
will base our controller design directly on the n x 1-nonlinear vector differential
equation of motion, derived in Chapter 6 for a general manipulator.
The field of nonlinear control theory is large; we must therefore restrict our
attention to one or two methods that seem well suited to mechanical manipulators.
Consequently, the major focus of the chapter wifi be one particular method,
apparently first proposed in [1] and named the computed-torque method in [2, 3].
We wifi also introduce one method of stability analysis of nonlinear systems, known
as Lyapimov's method [4].
To begin our discussion of nonlinear techniques for controlling a manipulator,
we return again to a very simple single-degree-of-freedom mass—spring friction
Section 10.2
10.2
Nonlinear and time-varying systems
NONLINEAR AND TIME-VARYING SYSTEMS
In the preceding development, we dealt with a linear constant-coefficient differential
equation. This mathematical form arose because the mass—spring friction system
of Fig. 9.6 was modeled as a linear time-invariant system. For systems whose
parameters vary in time or systems that by nature are nonlinear, solutions are more
difficult.
When non]inearities are not severe, local linearization can be used to derive
linear models that are approximations of the nonlinear equations in the neighborhood of an operating point. Unfortunately, the manipulator-control problem is not
well suited to this approach, because manipulators constantly move among regions
of their workspaces so widely separated that no linearization valid for all regions
can be found.
Another approach is to move the operating point with the manipulator as it
moves, always linearizing about the desired position of the manipulator. The result
of this sort of moving linearization is a linear, but time-varying, system. Although
this quasi-static linearization of the original system is useful in some analysis and
design techniques, we will not make use of it in our control-law synthesis procedure.
Rather, we will deal with the nonlinear equations of motion directly and will not
resort to linearizations in deriving a controller.
If the spring in Fig. 9.6 were not linear but instead contained a nonlinear
element, we could consider the system quasi-statically and, at each instant, figure
out where the poles of the system are located. We would find that the poles "move"
around in the real—imaginary plane as a function of the position of the block. Hence,
we could not select fixed gains that would keep the poles in a desirable location (for
example, at critical damping). So we may be tempted to consider a more complicated
control law, in which the gains are time-varying (actually, varying as a function of
the block's position) in such a manner that the system is always critically damped.
such that the combination of the
Essentially, this would be done by computing
nonlinear effect of the spring would be exactly cancelled by a nonlinear term in
the control law so that the overall stiffness would stay a constant at all times. Such a
control scheme might be called a linearizing control law, because it uses a nonlinear
control term to "cancel" a nonlinearity in the controlled system, so that the overall
closed ioop system is linear.
We wifi now return to our partitioned control law and see that it can perform
this linearizing function. In our partitioned control-law scheme, the servo law remains
the same as always, but the model-based portion now wifi contain a model of the
nonlinearity. Thus, the model-based portion of the control performs a linearization
function. This is best shown in an example.
EXAMPLE 10.1
Consider the nonlinear spring characteristic shown in Fig. 10.1. Rather than the
usual linear spring relationship, f = kx, this spring is described by f = qx3. If this
spring is part of the physical system shown in Fig. 9.6, construct a control law to
keep the system critically damped with a stiffness of kcL.
The open-loop equation is
+ qx3 = f.
(10.1)
292
Chapter 10
Nonlinear control of manipulators
f = qx3
FIG URE 10.1:
The force-vs.-distance characteristic of a nonlinear spring.
The model-based portion of the control is f = af' +
where now we use
+ qx3;
(10.2)
the servo portion is, as always
f' =xd+kVe+kPe,
where the
values
(10.3)
of the gains are calculated from some desired performance
specification. Figure 10.2 shows a block diagram of this control system. The resulting
closed-loop system maintains poles in fixed locations.
System
FIGURE 10.2:
A nonlinear control system for a system with a nonlinear spring.
Nonlinear and time-varying systems
Section 10.2
FIGURE 10.3:
The force-vs.-velocity characteristic of Coulomb friction.
EXAMPLE 10.2
Consider the nonlinear friction characteristic shown in Fig. 10.3. Whereas linear
this Coulomb friction is described by f =
friction is described by f =
For most of today's manipulators, the friction of the joint in its bearing (be it
rotational or linear) is modeled more accurately by this nonlinear characteristic
than by the simpler, linear model. If this type of friction is present in the system of
Fig. 9.6, design a control system that uses a nonlinear model-based portion to damp
the system critically at all times.
The partitioned control law is f = af' +
(10.4)
(10.5)
where the values of the gains are calculated from some desired performance
specification.
EXAMPLE 10.3
Consider the single-link manipulator shown in Fig. 10.4. It has one rotational joint.
The mass is considered to be located at a point at the distal end of the link, and so
the moment of inertia is mi2. There is Coulomb and viscous friction acting at the
joint, and there is a load due to gravity.
294
FIGURE 10.4:
An inverted pendulum or a one-link manipulator.
The model of the manipulator is
+ v9 + csgn(9) + inlgcos(9).
(10.6)
As always, the control system has two parts, the linearizing model-based portion
and the servo-law portion.
mi2,
+ csgn(9) + mnigcos(O);
(10.7)
the servo portion is, as always,
(10.8)
We have seen that, in certain simple cases, it is not difficult to design a nonlinear
controller. The general method used in the foregoing simple examples is the same
method we wifi use for the problem of manipulator control:
1. Compute a nonlinear model-based control law that "cancels" the nonlinearities
of the system to be controlled.
2. Reduce the system to a linear system that can be controlled with the simple
linear servo law developed for the unit mass.
In some sense, the linearizing control law implements an inverse model of the
system being controlled. The nonlinearities in the system cancel those in the inverse
model; this, together with the servo law, results in a linear closed-loop system.
Obviously, to do this cancelling, we must know the parameters and the structure of
the nonlinear system. This is often a problem in practical application of this method.
The control problem for manipulators
Section 10.4
10.3
MULTI-INPUT, MULTI-OUTPUT CONTROL SYSTEMS
Unlike the simple examples we have discussed in this chapter so far, the problem
of controlling a manipulator is a multi-input, multi-output (MIMO) problem. That
is, we have a vector of desired joint positions, velocities, and accelerations, and
the control law must compute a vector of joint-actuator signals. Our basic scheme,
partitioning the control law into a model-based portion and a servo portion, is stifi
applicable, but it now appears in a matrix—vector form. The control law takes the
F = aF' +
(10.9)
where, for a system of n degrees of freedom, F, F', and are n xl vectors anda is an
n x ii matrix. Note that the matrix a is not necessarily diagonal, but rather is chosen
to decouple the ii equations of motion. If a and are correctly chosen, then, from
the F' input, the system appears to be n independent unit masses. For this reason,
in the multidimensional case, the model-based portion of the control law is called a
lineaTizing and decoupling control law. The servo law for a multidimensional system
becomes
(10.10)
are now n x n matrices, which are generally chosen to be diagonal
with constant gains on the diagonal. E and E
n x 1 vectors of the errors in
position and velocity, respectively.
In the case of manipulator control, we developed a model and the corresponding
equations of motion in Chapter 6. As we saw, these equations are quite complicated.
The rigid-body dynamics have the form
= M(e)e + V(O, 0) + G(e),
(10.11)
is an n x 1
where M(O) is the ii x n inertia matrix of the manipulator, V(O,
vector of centrifugal and Coriolis terms, and G(O) is an ii x 1 vector of gravity
terms. Each element of M(®) and G(O) is a complicated function that depends on
0, the position of all the joints of the manipulator. Each element of V(0, 0) is a
complicated function of both 0 and 0.
Additionally, we could incorporate a model of friction (or other non-rigidbody effects). Assuming that our model of friction is a function of joint positions
and velocities, we add the term F(0, 0) to (10.11), to yield the model
= M(0)e + v(e, 0) + G(0) + F(0, 0).
(10.12)
The problem of controlling a complicated system like (10.12) can be handled
by the partitioned controller scheme we have introduced in this chapter. In this case,
= at' +
where t
(10.13)
the ii x 1 vector of joint torques. We choose
a = M(0),
= V(0, 0) + G(0) + F(0, 0),
(10.14)
296
FIGURE 10.5: A model-based manipulator-control system.
with the servo law
(10.15)
E = ed — 0.
(10.16)
The resulting control system is shown in Fig. 10.5.
Using (10.12) through (10.15), it is quite easy to show that the closed-loop
system is characterized by the error equation
(10.17)
Note that this vector equation is decoupled: The matrices
are diagonal,
so that (10.17) could just as well be written on a joint-by-joint basis as
(10.18)
The ideal performance represented by (10.17) is unattainable in practice, for many
reasons, the most important two being
1. The discrete nature of a digital-computer implementation, as opposed to the
ideal continuous-time control law implied by (10.14) and (10.15).
2. Inaccuracy in the manipulator model (needed to compute (10.14)).
In the next section, we will (at least partially) address these two issues.
10.5
PRACTICAL CONSIDERATIONS
In developing the decoupling and linearizing control in the last few sections, we
have implicitly made a few assumptions that rarely are true in practice.
Time required to compute the model
In all our considerations of the partitioned-control-law strategy, we have implicitly
assumed that the entire system was running in continuous time and that the computations in the control law require zero time for their computation. Given any amount of
computation, with a large enough computer we can do the computations sufficiently
Section 10.5
Practical considerations
fast that this is a reasonable approximation; however, the expense of the computer
could make the scheme economically unfeasible. In the manipulator-control case,
the entire dynamic equation of the manipulator, (10.14), must be computed in the
control law. These computations are quite involved; consequently, as was discussed
in Chapter 6, there has been a great deal of interest in developing fast computational
schemes to compute them in an efficient way. As computer power becomes more and
more affordable, control laws that require a great deal of computation will become
more practical. Several experimental implementations of nonlinear-model-based
control laws have been reported [5—9], and partial implementations are begirming
to appear in industrial controllers.
As was discussed in Chapter 9, almost all manipulator-control systems are
now performed in digital circuitry and are run at a certain sampling rate. This
means that the position (and possibly other) sensors are read at discrete points
in time. From the values read, an actuator command is computed and sent to
the actuator. Thus, reading sensors and sending actuator commands are not done
continuously, but rather at a finite sampling rate. To analyze the effect of delay
due to computation and finite sample rate, we must use tools from the field of
discrete-time control. In discrete time, differential equations turn into difference
equations, and a complete set of tools has been developed to answer questions
about stability and pole placement for these systems. Discrete-time control theory
is beyond the scope of this book, although, for researchers working in the area of
manipulator control, many of the concepts from discrete-time systems are essential.
(See [10].)
Although important, ideas and methods from discrete-time control theory
are often difficult to apply to the case of nonlinear systems. Whereas we have
managed to write a complicated differential equation of motion for the manipulator
dynamic equation, a discrete-time equivalent is impossible to obtain in general
because, for a general manipulator, the only way to solve for the motion of the
manipulator for a given set of initial conditions, an input, and a finite interval is by
numerical integration (as we saw in Chapter 6). Discrete-time models are possible
if we are willing to use series solutions to the differential equations, or if we make
approximations. However, if we need to make approximations to develop a discrete
model, then it is not clear whether we have a better model than we have when just
using the continuous model and making the continuous-time approximation. Suffice
it to say that analysis of the discrete-time manipulator-control problem is difficult,
and usually simulation is resorted to in order to judge the effect that a certain sample
rate wifi have on performance.
We wifi generally assume that the computations can be performed quickly
enough and often enough that the continuous-time approximation is valid.
Feedforward nonlinear control
The use of feedforward control has been proposed as a method of using a nonlinear
dynamic model in a control law without the need for complex and time-consuming
computations to be performed at servo rates [11]. In Fig. 10.5, the model-based
control portion of the control law is "in the servo loop" in that signals "flow"
through that black box with each tick of the servo clock. If we wish to select a sample
298
FIGURE 10.6: Control scheme with the model-based portion "outside" the servo
rate of 200 Hz, then the dynamic model of the manipulator must be computed at this
rate. Another possible control system is shown in Fig. 10.6. Here, the model-based
control is "outside" the servo loop. Hence, it is possible to have a fast inner servo
loop, consisting simply of multiplying errors by gains, with the model-based torques
added at a slower rate.
Unfortunately, the feedforward scheme of Fig. 10.6 does not provide complete
decoupling. If we write the system equations,' we wifi ftnd that the error equation
of this system is
(10.19)
Clearly, as the configuration of the arm changes, the effective closed-loop gain
changes, and the quasi-static poles move around in the real—imaginary plane.
However, equation (10.19) could be used as a starting point for designing a robust
controller—one that finds a good set of constant gains such that, despite the
"motion" of the poles, they are guaranteed to remain in reasonably favorable
locations. Alternatively, one might consider schemes in which variable gains are
precomputed which change with configuration of the robot, so that the system's
quasi-static poles remain in fixed positions.
Note that, in the system of Fig. 10.6, the dynamic model is computed as a
function of the desired path only, so when the desired path is known in advance,
values could be computed "off-line" before motion begins. At run time, the
precomputed torque histories would then be read out of memory. Likewise, if timevarying gains are computed, they too could be computed beforehand and stored.
Hence, such a scheme could be quite inexpensive computationally at run time and
thus achieve a high servo rate.
Dual-rate computed-torque implementation
Figure 10.7 shows the block diagram of a possible practical implementation of the
decoupling and linearizing position-control system. The dynamic model is expressed
in its configuration space form so that the dynamic parameters of the manipulator
will appear as functions of manipulator position only. These functions might then
1We have used the simplifying assumptions M(Od)
and F(Od, ed)
F(e, 0).
M(O), V(Od, ed)
(V(O, e), G(ed)
G(O),
FIGURE 10.7: An implementation of the model-based manipulator-control system.
computed by a background process or by a second control computer [8] or be
looked up in a precomputed table [12]. In this architecture, the dynamic parameters
can be updated at a rate slower than the rate of the closed-loop servo. For example,
the background computation might proceed at 60 Hz while the closed-loop servo
was running at 250 Hz.
Lack of knowledge of parameters
The second potential difficulty encountered in employing the computed-torque
control algorithm is that the manipulator dynamic model is often not known
accurately. This is particularly true of certain components of the dynamics, such
as friction effects. In fact, it is usually extremely difficult to know the structure of
the friction model, let alone the parameter values [13]. Finally, if the manipulator
has some portion of its dynamics that is not repeatable—because, for example, it
changes as the robot ages—it is difficult to have good parameter values in the model
at all times.
By nature, most robots wifi be picking up various parts and tools. When a
robot is holding a tool, the inertia and the weight of the tool change the dynamics
of the manipulator. In an industrial situation, the mass properties of the tools might
be known—in this case, they can be accounted for in the modeled portion of the
control law. When a tool is grasped, the inertia matrix, total mass, and center of
mass of the last link of the manipulator can be updated to new values that represent
the combined effect of the last link plus tool. However, in many applications, the
mass properties of objects that the manipulator picks up are not generally known,
so maintenance of an accurate dynamic model is difficult.
The simplest possible nonideal situation is one in which we stifi assume a
perfect model implemented in continuous time, but with external noise acting to
disturb the system. In Fig. 10.8, we indicate a vector of disturbance torques acting
at the joints. Writing the system error equation With inclusion of these unknown
disturbances, we arrive at
= M1(O)rd,
(10.20)
300
FIG U RE 10.8:
The model-based controller with an external disturbance acting.
where rd is the vector of disturbance torques at the joints. The left-hand side of
(10.20) is uncoupled, but, from the right-hand side, we see that a disturbance on any
particular joint will introduce errors at all the other joints, because M (0) is not, in
general, diagonal.
Some simple analyses might be performed on the basis of (10.20). For example,
it is easy to compute the steady-state servo error due to a constant disturbance as
E = K1M1(0)rd.
(10.21)
When our model of the manipulator dynamics is not perfect, analysis of
the resulting closed-loop system becomes more difficult. We define the following
notation: M(0) is our model of the manipulator inertia matrix, M (0). Likewise,
V(0, 0), G(0), and F(0,
are our models of the velocity terms, gravity terms,
and friction terms of the actual mechanism. Perfect knowledge of the model
would mean that
V(0, e) = V(0,
(10.22)
G(0) = G(0),
F(o,e)=F(o,e).
Therefore,
although the manipulator dynamics are given by
= M(0)ë + V(0, e) + G(0) + F(0, e),
(10.23)
our control law computes
18=v(0,e)+O(o)+fr(o,è).
(10.24)
Section 10.6
Current industrial-robot control systems
Decoupling and linearizing wifi not, therefore, be perfectly accomplished when
parameters are not known exactly. Writing the closed-loop equation for the system,
E+KUE+KPE
= M1[(M — M)e + (V
V) + (G — G) + (F — P)],
(10.25)
where the arguments of the dynamic functions are not shown for brevity. Note that,
if the model were exact, so that (10.22) were true, then the right-hand side of (10.25)
would be zero and the errors would disappear. When the parameters are not known
exactly, the mismatch between actual and modeled parameters wifi cause servo
errors to be excited (possibly even resulting in an unstable system [21]) according to
the rather complicated equation (10.25).
Discussion of stability analysis of a nonlinear closed-loop system is deferred
until Section 10.7.
10.6
CURRENT INDUSTRIAL-ROBOT CONTROL SYSTEMS
Because of the problems with having good knowledge of parameters, it is not clear
whether it makes sense to go to the trouble of computing a complicated model-based
control law for manipulator control. The expense of the computer power needed to
compute the model of the manipulator at a sufficient rate might not be worthwhile,
especially when lack of knowledge of parameters could nullify the benefits of such an
approach. Manufacturers of industrial robots have decided, probably for economic
reasons, that attempting to use a complete manipulator model in the controller is
not worthwhile. Instead, present-day manipulators are controlled with very simple
control laws that generally are completely error driven and are implemented in
architectures such as those studied in Section 9.10. An industrial robot with a
high-performance servo system is shown in Fig. 10.9.
Individual-joint PID control
Most industrial robots nowadays have a control scheme that, in our notation, would
be described by
a = I,
(10.26)
where I is the n x n identity matrix. The servo portion is
f Edt,
(10.27)
are constant diagonal matrices. In many cases, ed is not
available, and this term is simply set to zero. That is, most simple robot controllers
do not use a model-based component at all in their control law. This type of PID
control scheme is simple because each joint is controlled as a separate control
system. Often, one microprocessor per joint is used to implement (10.27), as was
discussed in Section 9.10.
302
FIGURE 10.9:
The Adept One, a direct-drive robot by Adept Technology, Inc.
The performance of a manipulator controlled in this way is not simple to
describe. No decoupling is being done, so the motion of each joint affects the other
joints. These interactions cause errors, which are suppressed by the error-driven
control law. It is impossible to select fixed gains that wifi critically damp the response
to disturbances for all configurations. Therefore, "average" gains are chosen, which
approximate critical damping in the center of the robot's workspace. In various
extreme configurations of the arm, the system becomes either underdamped or
overdamped. Depending on the details of the mechanical design of the robot, these
effects could be fairly small; then control would be good. In such systems, it is
important to keep the gains as high as possible, so that the inevitable disturbances
wifi be suppressed quickly.
Addition of gravity compensation
The gravity terms will tend to cause static positioning errors, so some robot
manufacturers include a gravity model, G(8), in the control law (that is, fi =
in our notation). The complete control law takes the form
(10.28)
Lyapunovstabilityanalysis
Section 10.7
Such a control law is perhaps the simplest example of a model-based controller.
Because (10.28) can no longer be implemented on a strict joint-by-joint basis, the
controller architecture must allow communication between the joint controllers or
must make use of a central processor rather than individual-joint processors.
Various approximations of decoupling control
There are various ways to simplify the dynamic equations of a particular manipulator
[3,14]. After the simplification, an approximate decoupling and linearizing law can
be derived. A usual simplification might be to disregard components of torque
due to the velocity terms—that is, to model only the inertial and gravity terms.
Often, friction models are not included in the controller, because friction is so hard
to model correctly. Sometimes, the inertia matrix is simplified so that it accounts
for the major coupling between axes but not for minor cross-coupling effects. For
example, [14] presents a simplified version of the PUMA 560's mass matrix that
requires only about 10% of the calculations needed to compute the complete mass
matrix, yet is accurate to within 1 %.
10.7
LYAPU NOV STABILITY ANALYSIS
In Chapter 9, we examined linear control systems analytically to evaluate stability
and also performance of the dynamic response in terms of damping and closedloop bandwidth. The same analyses are valid for a nonlinear system that has been
decoupled and linearized by means of a perfect model-based nonlinear controller,
because the overall resulting system is again linear. However, when decoupling and
linearizing are not performed by the controller, or are incomplete or inaccurate,
the overall closed-loop system remains nonlinear. For nonlinear systems, stability
and performance analysis is much more difficult. In this section, we introduce one
method of stability analysis that is applicable to both linear and nonlinear systems.
Consider the simple mass—spring friction system originally introduced in
Chapter 9, whose equation of motion is
jul + hi + kx =
(10.29)
The total energy of the system is given by
(10.30)
where the first term gives the kinetic energy of the mass and the second term gives
the potential energy stored in the spring. Note that the value, v, of the system energy
is always nonnegative (i.e., it is positive or zero). Let's find out the rate of change of
the total energy by differentiating (10.30) with respect to time, to obtain
= mil + kxi.
(10.31)
Substituting (10.29) for ml in (10.31) yields
—hi2,
(10.32)
which we note is always nonpositive (because b> 0). Thus, energy is always leaving
the system, unless i = 0. This implies that, however initially perturbed, the system
304
will lose energy until it comes to rest. Investigating possible resting positions by
means of a steady-state analysis of (10.29) yields
(10.33)
(10.34)
Hence, by means of an energy analysis, we have shown that the system of (10.29)
with any initial conditions (i.e., any initial energy) wifi eventually come to rest
at the equilibrium point. This stability proof by means of an energy analysis is a
simple example of a more general technique called Lyapunov stability analysis or
Lyapunov's second (or direct) method, after a Russian mathematician of the 19th
century [15].
An interesting feature of this method of stability analysis is that we can conclude
stability without solving for the solution of the differential equation governing
the system. However, while Lyapunov's method is useful for examining stability,
it generally does not provide any information about the transient response or
performance of the system. Note that our energy analysis yielded no information on
whether the system was overdamped or underdamped or on how long it would take
the system to suppress a disturbance. It is important to distinguish between stability
and performance: A stable system might nonetheless exhibit control performance
unsatisfactory for its intended use.
Lyapunov's method is somewhat more general than our example indicated.
It is one of the few techniques that can be applied directly to nonlinear systems
to investigate their stability. As a means of quickly getting an idea of Lyapunov's
method (in sufficient detail for our needs), we wifi look at an extremely brief
introduction to the theory and then proceed directly to several examples. A more
complete treatment of Lyapunov theory can be found in [16, 17].
Lyapunov's method is concerned with determining the stability of a differential
X = f(X),
(10.35)
where X is in x 1 and f(.) could be nonlinear. Note that higher order differential
equations can always be written as a set of first-order equations in the form (10.35).
To prove a system stable by Lyapunov's method, one is required to propose a
generalized energy function u(X) that has the following properties:
1. v (X) has continuous first partial derivatives, and u (X) > 0 for all X except
u(0) = 0.
(X) <0. Here, (X) means the change in v (X) along all system trajectories.
These properties might hold only in a certain region, or they might be global,
with correspondingly weaker or stronger stability results. The intuitive idea is that
a positive definite "energy-like" function of state is shown to always decrease or
remain constant—hence, the system is stable in the sense that the size of the state
vector is bounded.
When (X) is strictly less than zero, asymptotic convergence of the state to
the zero vector can be concluded. Lyapunov's original work was extended in an
Section 10.7
Lyapunov stability analysis
important way by LaSalle and Lefschetz [4], who showed that, in certain situations,
even when O(X)
0 (note equality included), asymptotic stability can be shown.
For our purposes, we can deal with the case
= 0 by performing a steady-state
analysis in order to learn whether the stability is asymptotic or the system under
study can "get stuck" somewhere other than v (X) = 0.
A system described by (10.35) is said to be autonomous because the function f(.) is not an explicit function of time. Lyapunov's method also extends to
nonautonomous systems, in which time is an argument of the nonlinear function.
See [4, 17] for details.
EXAMPLE 10.4
Consider the linear system
—AX,
(10.36)
where A is in x in and positive definite. Propose the candidate Lyapunov function
u(X) =
(10.37)
which is continuous and everywhere nonnegative. Differentiating yields
ii(X)=XTX
= XT(_AX)
= _XTAX,
(10.38)
which is everywhere nonpositive because A is a positive definite matrix. Hence,
(10.37) is indeed a Lyapunov function for the system of (10.36). The system is
asymptotically stable because i)(X) can be zero only at X = 0; everywhere else, X
must decrease.
EXAMPLE 10.5
Consider a mechanical spring—damper system in which both the spring and damper
are nonlinear:
(10.39)
The functions b(.) and k(.) are first- and third-quadrant continuous functions
such that
xk(x) > 0 for x
(10.40)
k(X)dA,
(10.41)
Once having proposed the Lyapunov function
v(x,
306
we are led to
+ k(x)i,
(10.42)
Hence, (.) is nonpositive but is only semidefinite, because it is not a function of x
but only of In order to conclude asymptotic stability, we have to ensure that it is
not possible for the system to "get stuck" with nonzero x. To study all trajectories
for which = 0, we must consider
for which x =
(10.43)
—k(x),
is the only solution. Hence, the system will come to rest only if
x = =1 =0.
EXAMPLE 10.6
Consider a manipulator with dynamics given by
r=M(e)e+v(o,e)+G(o)
(10.44)
and controlled with the control law
+ G(e),
(10.45)
and Kd are diagonal gain matrices. Note that this controller does not force
the manipulator to follow a trajectory, but moves the manipulator to a goal point
along a path specified by the manipulator dynamics and then regulates the position
there. The resulting closed-loop system obtained by equating (10.44) and (10.45) is
M(e)e + V(O, e) + Kde +
(10.46)
it can be proven globally asymptotically stable by Lyapunov's method [18, 19].
Consider the candidate Lyapunov function
(10.47)
The function (10.47) is always positive or zero, because the manipulator mass
are positive definite matrices.
matrix, M(O), and the position gain matrix,
Differentiating (10.47) yields
+ éTM(9)e —
éTv(e
(10.48)
Section 10.8
Cartesian-based control systems
which is nonpositive as long as Kd is positive definite. In taking the last step in
(10.48), we have made use of the interesting identity
= OTV(O, é),
(10.49)
which can be shown by investigation of the structure of Lagrange's equations of
motion [18—20]. (See also Exercise 6.17.)
Next, we investigate whether the system can get "stuck" with nonzero error.
Because i) can remain zero only along trajectories that have 0 = 0 and 0 = 0, we
see from (10.46) that, in this case,
and because
(10.50)
is nonsingular, we have
E = 0.
(10.51)
Hence, control law (10.45) applied to the system (10.44) achieves global asymptotic
stability.
This proof is important in that it explains, to some extent, why today's industrial
robots work. Most industrial robots use a simple error-driven servo, occasionally
with gravity models, and so are quite similar to (10.45).
See Exercises 10.11 through 10.16 for more examples of nonlinear manipulatorcontrol laws that can be proven stable by Lyapunov's method. Recently, Lyapunov
theory has become increasingly prevalent in robotics research publications [18—25].
10.8
CARTESIAN-BASED CONTROL SYSTEMS
In this section, we introduce the notion of Cartesian-based control. Although such
approaches are not currently used in industrial robots, there is activity at several
research institutions on such schemes.
Comparison with joint-based schemes
In all the control schemes for manipulators we have discussed so far, we assumed
that the desired trajectory was available in terms of time histories of joint position,
velocity, and acceleration. Given that these desired inputs were available, we
designedjoint-based control schemes, that is, schemes in which we develop trajectory
errors by finding the difference between desired and actual quantities expressed in
joint space. Very often, we wish the manipulator end-effector to follow straight lines
or other path shapes described in Cartesian coordinates. As we saw in Chapter 7, it
is possible to compute the time histories of the joint-space trajectory that correspond
to Cartesian straight-line paths. Figure 10.10 shows this approach to manipulatortrajectory control. A basic feature of the approach is the trajectory-conversion
process, which is used to compute the joint trajectories. This is then followed by
some kind of joint-based servo scheme such as we have been studying.
308
FIGURE 10.10: A joint-based control scheme with Cartesian-path input.
The trajectory-conversion process is quite difficult (in terms of computational
expense) if it is to be done analytically. The computations that would be required are
= INVKIN(xd),
(10.52)
+ J-'(e)5?d.
To the extent that such a computation is done at all in present-day systems, usually
just the solution for 0d is performed, by using the inverse kinematics, and then
the joint velocities and accelerations are computed numerically by first and second
differences. However, such numerical differentiation tends to amplify noise and
introduces a lag unless it can be done with a noncausal fflter.2 Therefore, we are
interested in either finding a less computationally expensive way of computing
(10.52) or suggesting a control scheme in which this informatiOn is not needed.
An alternative approach is shown in Fig. 10.11. Here, the sensed position of
the manipulator is immediately transformed by means of the kinematic equations
into a Cartesian description of position. This Cartesian description is then compared
to the desired Cartesian position in order to form errors in Cartesian space. Control
schemes based on forming errors in Cartesian space are called Cartesian-based
control schemes. For simplicity, velocity feedback is not shown in Fig. 10.11, but it
would be present in any implementation.
The trajectory-conversion process is replaced by some kind of coordinate
conversion inside the servo loop. Note that Cartesian-based controllers must perform
many computations in the loop; the kinematics and other transformations are now
"inside the loop." This can be a drawback of the Cartesian-based methods; the
resulting system could run at a lower sampling frequency compared to joint-based
FIGURE 10.11: The concept of a Cartesian-based control scheme.
2Numerical differentiation introduces a lag unless it can be based on past, present, and future values.
When the entire path is preplanned, this kind of noncausal numerical differentiation can be done.
systems
(given the same size of computer). This would, in general, degrade the
stability and disturbance-rejection capabilities of the system.
Intuitive schemes of Cartesian control
possible control scheme that comes to mind rather intuitively is shown in
Fig. 10.12. Here, Cartesian position is compared to the desired position to form
an error, 8X, in Cartesian space. This error, which may be presumed small if the
control system is doing its job, may be mapped into a small displacement in joint
space by means of the inverse Jacobian. The resulting errors in joint space, 88, are
then multiplied by gains to compute torques that will tend to reduce these errors.
Note that Fig. 10.12 shows a simplified controller in which, for clarity, the velocity
feedback has not been shown. It could be added in a straightforward manner. We
will call this scheme the inverse-Jacobian controller.
Another scheme which could come to mind is shown in Fig. 10.13. Here, the
Cartesian error vector is multiplied by a gain to compute a Cartesian force vector.
This can be thought of as a Cartesian force which, if applied to the end-effector
of the robot, would push the end-effector in a direction that would tend to reduce
the Cartesian error. This Cartesian force vector (actually a force—moment vector)
is then mapped through the Jacobian transpose in order to compute the equivalent
joint torques that would tend to reduce the observed errors. We wifi call this scheme
the transpose-Jacobian controller.
The inverse-Jacobian controller and the transpose-Jacobian controller have
both been arrived at intuitively. We cannot be sure that such arrangements would
be stable, let alone perform well. It is also curious that the schemes are extremely
similar, except that the one contains the Jacobian's inverse, the other its transpose.
Remember, the inverse is not equal to the transpose in general (only in the case of
a strictly Cartesian manipulator does jT = J1). The exact dynamic performance
FIGURE 10.12:
The inverse-Jacobian Cartesian-control scheme.
FIGURE 10.13:
The transpose-Jacobian Cartesian-control scheme.
310
of such systems (if expressed in a second-order error-space equation, for example)
is very complicated. It turns out that both schemes will work (i.e., can be made
stable), but not well (i.e., performance is not good over the entire workspace). Both
can be made stable by appropriate gain selection, including some form of velocity
feedback (which was not shown in Figs. 10.12 and 10.13). While both wifi work,
neither is correct, in the sense that we cannot choose fixed gains that wifi result in
fixed closed-loop poles. The dynamic response of such controllers will vary with arm
Cartesian decoupling scheme
For Cartesian-based controllers, like joint-based controllers, good performance
would be characterized by constant error dynamics over all configurations of the
manipulator. Errors are expressed in Cartesian space in Cartesian-based schemes,
so this means that we would like to design a system which, over all possible
configurations, would suppress Cartesian errors in a critically damped fashion.
Just as we achieved good control with a joint-based controller that was based
on a linearizing and decoupling model of the arm, we can do the same for the
Cartesian case. However, we must now write the dynamic equations of motion of
the manipulator in terms of Cartesian variables. This can be done, as was discussed
in Chapter 6. The resulting form of the equations of motion is quite analogous to
the joint-space version. The rigid-body dynamics can be written as
e) +
(10.53)
where F is a fictitious force—moment vector acting on the end-effector of the robot
and x is an appropriate Cartesian vector representing position and orientation of
(0) is the mass
Analogous to the joint-space quantities,
the end-effector
(0, 0) is a vector of velocity terms in Cartesian space,
matrix in Cartesian space,
is a vector of gravity terms in Cartesian space.
Just as we did in the joint-based case, we can use the dynamic equations in
a decoupling and linearizing controller. Because (10.53) computes F, a fictitious
Cartesian force vector which should be applied to the hand, we will also need to use
the transpose of the Jacobian in order to implement the control—that is, after F is
calculated by (10.53), we cannot actually cause a Cartesian force to be applied to
the end-effector; we instead compute the joint torques needed to effectively balance
the system if we were to apply this force:
= JT(O)F
(10.54)
Figure 10.14 shows a Cartesian arm-control system using complete dynamic
decoupling. Note that the arm is preceded by the Jacobian transpose. Notice that
the controller of Fig. 10.14 allows Cartesian paths to be described directly, with no
need for trajectory conversion.
As in the joint-space case, a practical implementation might best be achieved
through use of a dual-rate control system. Figure 10.15 shows a block diagram
of a Cartesian-based decoupling and linearizing controller in which the dynamic
parameters are written as functions of manipulator position only. These dynamic
parameters are updated at a rate slower than the servo rate by a background
Section 10.9
FIGURE 10.14:
FIGURE 10.15:
Adaptive control
The Cartesian model-based control scheme.
An implementation of the Cartesian model-based control scheme.
process or a second control computer. This is appropriate, because we desire a fast
servo (perhaps running at 500 Hz or even higher) to maximize disturbance rejection
and stability. The dynamic parameters are functions of manipulator position only,
so they need be updated at a rate related only to how fast the manipulator is
changing configuration. The parameter-update rate probably need not be higher
than 100 Hz [8].
10.9
ADAPTIVE CONTROL
In the discussion of model-based control, it was noted that, often, parameters of
the manipulator are not known exactly. When the parameters in the model do not
Chapter 10
FIGURE 10.16:
The concept of an adaptive manipulator controller.
match the parameters of the real device, servo errors wifi result, as is made explicit
in (10.25). These servo errors could be used to drive some adaptation scheme that
attempts to update the values of the model parameters until the errors disappear.
Several such adaptive schemes have been proposed.
An ideal adaptive scheme might be like the one in Fig. 10.16. Here, we are
using a model-based control law as developed in this chapter. There is an adaptation
process that, given observations of manipulator state and servo errors, readjusts the
parameters in the nonlinear model until the errors disappear. Such a system would
learn its own dynamic properties. The design and analysis of adaptive schemes are
beyond the scope of this book. A method that possesses exactly the structure shown
in Fig. 10.16 and has been proven globally stable is presented in [20, 21]. A related
technique is that of [221.
[1] R.P. Paul, "Modeling, Trajectory Calculation, and Servoing of a Computer Con-
trolled Ann," Technical Report AIM-177, Stanford University Artificial Inteffigence
Laboratory, 1972.
[2] B. Markiewicz, "Analysis of the Computed Torque Drive Method and Comparison
with Conventional Position Servo for a Computer-Controlled Manipulator," Jet
Propulsion Laboratory Technical Memo 33—601, March 1973.
[3] A. Bejczy, "Robot Arm Dynamics and Control," Jet Propulsion Laboratory Technical
Memo 33—669, February 1974.
LaSalle and S. Lefschetz, Stability by Liapunov's Direct Method with Applications,
Academic Press, New York, 1961.
[5] P.K. Khosla, "Some Experimental Results on Model-Based Control Schemes," IEEE
Conference on Robotics and Automation, Philadelphia, April 1988.
[6] M. Leahy, K. Valavanis, and G. Saridis, "The Effects of Dynamic Models on Robot
Control," IEEE Conference on Robotics and Automation, San Francisco, April 1986.
[7] L. Sciavicco and B. Siciliano, Modelling and Control of Robot Manipulators, 2nd
[8] 0. Khatib, "A Unified Approach for Motion and Force Control of Robot Manipulators: The Operational Space Formulation," IEEE Journal ofRobotics andAutomation,
Vol. RA-3, No. 1, 1987.
[9] C. An, C. Atkeson, and J. Hollerbach, "Model-Based Control of a Direct Drive Arm,
Part II: Control," IEEE Conference on Robotics and Automation, Philadelphia, April
1988.
[10] G. Franklin, J. Powell, and M. Workman, Digital Control of Dynamic Systems, 2nd
edition, Addison-Wesley, Reading, MA, 1989.
[11] A. Liegeois, A. Fournier, and M. Aldon, "Model Reference Control of High Velocity
Industrial Robots," Proceedings of the Joint Automatic Control Conference, San
Francisco, 1980.
[12] M. Raibert, "Mechanical Arm Control Using a State Space Memory," SME paper
[13] B. Armstrong, "Friction: Experimental Determination, Modeling and Compensation," IEEE Conference on Robotics and Automation, Philadelphia, April 1988.
[14] B. Armstrong, 0. Khatib, and J. Burdick, "The Explicit Dynamic Model and Inertial
Parameters of the PUMA 560 Arm," IEEE Conference on Robotics and Automation,
San Francisco, April 1986.
[15] A.M. Lyapunov, "On the General Problem of Stability of Motion," (in Russian),
Kharkov Mathematical Society, Soviet Union, 1892.
[16] C. Desoer and M. Vidyasagar, Feedback Systems: Input— Output Properties, Academic
Press, New York, 1975.
[171 M. Vidyasagar, Nonlinear Systems Analysis, Prentice-Hail, Englewood Cliffs, NJ, 1978.
[18] 5. Arimoto and F. Miyazaki, "Stability and Robustness of PID Feedback Control
for Robot Manipulators of Sensory Capability," Third International Symposium of
Robotics Research, Gouvieux, France, July 1985.
[19] D. Koditschek, "Adaptive Strategies for the Control of Natural Motion," Proceedings
of the 24th Conference on Decision and Control, Ft. Lauderdale, FL, December 1985.
[201 J. Craig, P. Hsu, and S. Sastry, "Adaptive Control of Mechanical Manipulators," IEEE
Conference on Robotics and Automation, San Francisco, April 1986.
[21] J. Craig, Adaptive Control of Mechanical Manipulators, Addison-Wesley, Reading,
MA, 1988.
[22] J.J. Slotine and W. Li, "On the Adaptive Control of Mechanical Manipulators," The
International Journal of Robotics Research, Vol. 6, No. 3, 1987.
[23] R. Kelly and R. Ortega, "Adaptive Control of Robot Manipulators: An Input—Output
Approach," IEEE Conference on Robotics and Automation, Philadelphia, 1988.
[24] H. Das, J.J. Slotine, and T. Sheridan, "Inverse Kinematic Algorithms for Redundant
Systems," IEEE Conference on Robotics and Automation, Philadelphia, 1988.
[25] T. Yabuta, A. Chona, and G. Beni, "On the Asymptotic Stability of the Hybrid
PositionfForce Control Scheme for Robot Manipulators," IEEE Conference on
Robotics and Automation, Philadelphia, 1988.
10.1 [15] Give the nonlinear control equations for an
controller for
the system
Choose gains so that this system is always critically damped with kcL = 10.
10.2 [15] Give the nonlinear control equations for an
10.4
[1911 Draw a block diagram showing a joint-space controller for the two-link arm
from Section 6.7, such that the arm is critically damped over its entire workspace.
Show the equations inside the blocks of a block diagram.
[2011 Draw a block diagram showing a Cartesian-space controller for the twolink arm from Section 6.7, such that the arm is critically damped over its entire
workspace. (See Example 6.6.) Show the equations inside the blocks of a block
diagram.
10.5 [18] Design a trajectory-following control system for the system whose dynamics
are given by
+ in111129197,
v202.
Do you think these equations could represent a real system?
10.6 [17] For the control system designed for the one-link manipulator in Example
10.3, give an expression for the steady-state position error as a function of error
The result should be a function of
= in —
in the mass parameter. Let
For what position of the manipulator is this at a maximum?
1, g, 9,
10.7 [26] For the two-degree-of-freedom mechanical system of Fig. 10.17, design a
controller that can cause x1 and x2 to follow trajectories and suppress disturbances
in a critically damped fashion.
10.8 [30] Consider the dynamic equations of the two-link manipulator from Section 6.7
in configuration-space form. Derive expressions for the sensitivity of the computed
A X1
X XXX XXXXXXXXb1
FIGURE 10.17:
Mechanical system with two degrees of freedom.
torque value versus small deviations in CE). Can you say something about how
often the dynamics should be recomputed in a controller like that of Fig. 10.7 as
a function of average joint velocities expected during normal operations?
10.9 [32] Consider the dynamic equations of the two-liuk manipulator from Example
6.6 in Cartesian configuration-space form. Derive expressions for the sensitivity of
the computed torque value versus small deviations in 0. Can you say something
about how often the dynamics should be recomputed in a controller like that
of Fig. 10.15 as a function of average joint velocities expected during normal
operations?
10.10 [15] Design a control system for the system
Choose gains so that this system is always critically damped with a closed-loop
stiffness of 20.
10.11 [20] Consider a position-regulation system that (without loss of generality)
attempts to maintain °d = 0. Prove that the control law
+ G(0)
yields an asymptotically stable nonlinear system. You may take
to be of the
where is a scalar and is the n x ii identity matrix. Hint: This
is similar to example 10.6.
10.12 [20] Consider a position-regulation system that (without loss of generality)
attempts to maintain 0d = 0. Prove that the control law
where is a scalar and is the 11 x n identity matrix. The matrix
is a positive definite estimate of the manipulator mass matrix. Hint: This is
similar to example 10.6.
10.13 [25] Consider a position-regulation system that (without loss of generality)
= k0 j/I where is a scalar and is the ii x n identity matrix. Hint: This
10.14 [25] Consider a position-regulation system that (without loss of generality)
is a scalar and is the n x ii identity matrix. The
is a positive definite estimate of the manipulator mass matrix. Hint:
This is similar to example 10.6.
10.15 [28] Consider a position-regulation system that (without loss of generality)
316
yields a stable nonlinear system. Show that stability is not asymptotic and give an
expression for the steady-state error. Hint: This is similar to Example 10.6.
10.16 [30] Prove the global stability of the Jacobian-transpose Cartesian controller
introduced in Section 10.8. Use an appropriate form of velocity feedback to
stabilize the system. Hint: See [18].
10.17 [15] Design a trajectory-following controller for a system with dynamics given by
f = ax2
+ csin(x),
such that errors are suppressed in a critically damped fashion over all configurations.
10.18 [15] A system with open-loop dynamics given by
r =,nG+b82+c9
is controlled with the control law
+ sin(O).
Give the differential equation that characterizes the closed-loop action of the
PROGRAMMING EXERCISE (PART 10)
Repeat Programming Exercise Part 9, and use the same tests, but with a new controller
that uses a complete dynamic model of the 3-link to decouple and linearize the system.
For this case, use
[100.0
0.0 100.0
that guarantees critical damping over all conñgurations of the
Choose a diagonal
arm. Compare the results with those obtained with the simpler controller used in
Programming Exercise Part 9.
Force control of manipulators
11.1 INTRODUCTION
11.2 APPLICATION OF INDUSTRIAL ROBOTS TO ASSEMBLY TASKS
11.3 A FRAMEWORK FOR CONTROL IN PARTIALLY CONSTRAINED TASKS
11.4 THE HYBRID POSITION/FORCE CONTROL PROBLEM
11.5 FORCE CONTROL OFA MASS—SPRING SYSTEM
11.6 THE HYBRID POSITION/FORCE CONTROL SCHEME
11.7 CURRENT INDUSTRIAL-ROBOT CONTROL SCHEMES
11.1
Position control is appropriate when a manipulator is following a trajectory through
space, but when any contact is made between the end-effector and the manipulator's
environment, mere position control might not suffice. Consider a manipulator
washing a window with a sponge. The compliance of the sponge might make it
possible to regulate the force applied to the window by controlling the position of
the end-effector relative to the glass. If the sponge is very compliant or the position
of the glass is known very accurately, this technique could work quite well.
If, however, the stiffness of the end-effector, tool, or environment is high,
it becomes increasingly difficult to perform operations in which the manipulator
presses against a surface. Instead of washing with a sponge, imagine that the
manipulator is scraping paint off a glass surface, using a rigid scraping tool. If there
is any uncertainty in the position of the glass surface or any error in the position
of the manipulator, this task would become impossible. Either the glass would be
broken, or the manipulator would wave the scraping tool over the glass with no
contact taking place.
In both the washing and scraping tasks, it would be more reasonable not to
specify the position of the plane of the glass, but rather to specify a force that is to be
maintained normal to the surface.
More so than in previous chapters, in this chapter we present methods that are
not yet employed by industrial robots, except in an extremely simplified way. The
major thrust of the chapter is to introduce the hybrid position/force controller, which
is one formalism through which industrial robots might someday be controlled in
order to perform tasks requiring force control. However, regardless of which
method(s) emerge as practical for industrial application, many of the concepts
introduced in this chapter wifi certainly remain valid.
318
11.2
Chapter 11
APPLICATION OF INDUSTRIAL ROBOTS TO ASSEMBLY TASKS
The majority of the industrial robot population is employed in relatively simple
applications, such as spot welding, spray painting, and pick-and-place operations.
Force control has already appeared in a few applications; for example, some robots
are already capable of simple force control that allows them to do such tasks as
grinding and deburring. Apparently, the next big area of application wifi be to
assembly-line tasks in which one or more parts are mated. In such parts-mating
tasks, monitoring and control of the forces of contact are extremely important.
Precise control of manipulators in the face of uncertainties and variations in
their work environments is a prerequisite to application of robot manipulators to
assembly operations in industry. It seems that, by providing manipulator hands with
sensors that can give information about the state of manipulation tasks, important
progress can be made toward using robots for assembly tasks. Currently, the
dexterity of manipulators remains quite low and continues to limit their application
in the automated assembly area.
The use of manipulators for assembly tasks requires that the precision with
which parts are positioned with respect to one another be quite high. Current
industrial robots are often not accurate enough for these tasks, and building robots
that are might not make sense. Manipulators of greater precision can be achieved
only at the expense of size, weight, and cost. The ability to measure and control
contact forces generated at the hand, however, offers a possible alternative for
extending the effective precision of a manipulation. Because relative measurements
are used, absolute errors in the position of the manipulator and the manipulated
objects are not as important as they would be in a purely position-controlled system.
Small variations in relative position generate large contact forces when parts of
moderate stiffness interact, so knowledge and control of these forces can lead to a
tremendous increase in effective positional accuracy.
11.3
A FRAMEWORK FOR CONTROL IN PARTIALLY CONSTRAINED TASKS
approach presented in this chapter is based on a framework for control in
situations in which motion of the manipulator is partially constrained by contact with
one or more surfaces [1—3]. This framework for understanding partially constrained
tasks is based on a simplified model of interaction between the manipulator's endeffector and the environment: We are interested in describing contact and freedoms,
so we consider only the forces due to contact. This is equivalent to doing a quasi-static
analysis and ignoring other static forces, such as certain friction components and
gravity. The analysis is reasonable where forces due to contact between relatively
stiff objects are the dominant source of forces acting on the system. Note that the
methodology presented here is somewhat simplistic and has some limitations, but
it is a good way to introduce the basic concepts involved and do so at a level
appropriate for this text. For a related, but more general and rigorous methodology,
see [19].
Every manipulation task can be broken down into subtasks that are defined
by a particular contact situation occurring between the manipulator end-effector
(or tool) and the work environment. With each such subtask, we can associate
a set of constraints, called the natural constraints, that result from the particular
Section 11.3
A framework for control in partially constrained tasks
mechanical and geometric characteristics of the task configuration. For instance, a
hand in contact with a stationary, rigid surface is not free to move through that
surface; hence, a natural position constraint exists. If the surface is frictionless, the
hand is not free to apply arbitrary forces tangent to the surface; thus, a natural force
constraint exists.
In our model of contact with the environment, for each subtask configuration,
a generalized surface can be defined with position constraints along the normals to
this surface and force constraints along the tangents. These two types of constraint,
force and position, partition the degrees of freedom of possible end-effector motions
into two orthogonal sets that must be controlled according to different criteria. Note
that this model of contact does not include all possible contacting situations. (See
[19] for a more general scheme.)
Figure 11.1 shows two representative tasks along with their associated natural
constraints. Notice that, in each case, the task is described in terms of a frame {C}, the
so-called constraint frame, which is located in a task-relevant location. According to
the task, {C} could be fixed in the environment or could move with the end-effector
of the manipulator. In Fig. 11.1(a), the constraint frame is attached to the crank as
shown and moves with the crank, with the direction always directed toward the
pivot point of the crank. Friction acting at the fingertips ensures a secure grip on
the handle, which is on a spindle so that it can rotate relative to the crank arm. In
Fig. 11.1(b), the constraint frame is attached to the tip of the screwdriver and moves
with it as the task proceeds. Notice that, in the Y direction, the force is constrained
to be zero, because the slot of the screw would allow the screwdriver to slip out in
that direction. In these examples, a given set of constraints remains true throughout
the task. In more complex situations, the task is broken into subtasks for which a
constant set of natural constraints can be identified.
Natural constraints
f3=O
v1=O
(a) Turning crank
vr=0
vz = 0
(b) Turning screwdriver
11.1: The natural constraints for two different tasks.
320
In Fig. 11.1, position constraints have been indicated by giving values for
components of velocity of the end-effector, V, described in frame {C}. We could
just as well have indicated position constraints by giving expressions for position,
rather than velocities; however, in many cases, it is simpler to specify a position
constraint as a "velocity equals zero" constraint. Likewise, force constraints have
been specified by giving values to components of the force-moment vector, 1,
acting on the end-effector described in frame {C}. Note that when we say position
constraints, we mean position or orientation constraints, and when we say force
constraints, we mean force or moment constraints. The term natural constraints is
used to indicate that these constraints arise naturally from the particular contacting
situation. They have nothing to do with the desired or intended motion of the
Additional constraints, called artificial constraints, are introduced in accordance with the natural constraints to specify desired motions or force application.
That is, each time the user specifies a desired trajectory in either position or force,
an artificial constraint is defined. These constraints also occur along the tangents
and normals of the generalized constraint surface, but, unlike natural constraints,
artificial force constraints are specified along surface normals, and artificial position constraints along tangents—hence, consistency with the natural constraints is
preserved.
Figure 11.2 shows the natural and artificial constraints for two tasks. Note that
when a natural position constraint is given for a particular degree of freedom in {C},
(a) Thrning crank
constraints
FIGURE 11.2:
The natural and artificial constraints for two tasks.
an artificial force constraint should be specified, and vice versa. At any instant,
any given degree of freedom in the constraint frame is controlled to meet either a
position or a force constraint.
Assembly strategy is a term that refers to a sequence of planned artificial
constraints that will cause the task to proceed in a desirable manner. Such strategies
must include methods by which the system can detect a change in the contacting
situation so that transitions in the natural constraints can be tracked. With each
such change in natural constraints, a new set of artificial constraints is recalled
from the set of assembly strategies and enforced by the control system. Methods
for automatically choosing the constraints for a given assembly task await further
research. In this chapter, we wifi assume that a task has been analyzed in order
to determine the natural constraints and that a human planner has determined an
assembly strategy with which to control the manipulator.
Note that we will usually ignore friction forces between contacting surfaces in
our analysis of tasks. This wifi suffice for our introduction to the problem and in fact
wifi yield strategies that work in many cases. Usually friction forces of sliding are
acting in directions chosen to be position controlled, and so these forces appear as
disturbances to the position servo and are overcome by the control system.
EXAMPLE 11.1
Figure 11.3(a)—(d) shows an assembly sequence used to put a round peg into a round
hole. The peg is brought down onto the surface to the left of the hole and then slid
along the surface until it drops into the hole. It is then inserted until the peg reaches
the bottom of the hole, at which time the assembly is complete. Each of the four
indicated contacting situations defines a subtask. For each of the subtasks shown,
give the natural and artificial constraints. AJso, indicate how the system senses the
change in the natural constraints as the operation proceeds.
First, we wifi attach the constraint frame to the peg as shown in Fig. 11.3(a). In
Fig. 11.3(a), the peg is in free space, and so the natural constraints are
(11.1)
FIGURE 11.3: The sequence of four contacting situations for peg insertion.
Chapter 11
Therefore, the artificial constraints in this case constitute an entire position trajectory, which moves the peg in the C Z direction toward the surface. For example,
(11.2)
is the speed with which to approach the surface.
In Fig. 11.3(b), the peg has reached the surface. To detect that this has
happened, we observe the force in the C z direction. When this sensed force exceeds
a threshold, we sense contact, which implies a new contacting situation with a new
set of natural constraints. Assuming that the contacting situation is as shown in
Fig. 11.3(b), the peg is not free to move in CZ, or to rotate about Cf( or
the other three degrees of freedom, it is not free to apply forces; hence, the natural
constraints are
Cv = 0,
(11.3)
Cf =0,
Cf = 0,
The artificial constraints describe the strategy of sliding along the surface in the
direction while applying small forces to ensure that contact is maintained. Thus, we
have
— Uslide,
= fcontact'
(11.4)
where fcontact is the force applied normal to the surface as the peg is slid, and VSljde
is the velocity with which to slide across the surface.
In Fig. 11.3(c), the peg has fallen slightly into the hole. This situation is sensed
by observing the velocity in the C z direction and waiting for it to cross a threshold
(to become nonzero, in the ideal case). When this is observed, it signals that once
again the natural constraints have changed, and thus our strategy (as embodied in
Section 11.4
The hybrid position/force control problem
the artificial constraints) must change. The new natural constraints are
(11.5)
Cnz = 0.
We choose the artificial constraints to be
Vinsert,
Cf =0
(11.6)
C11_0
is the velocity at which the peg is inserted into the hole. Finally,
the situation shown in Fig. 11.3(d) is detected when the force in the C2 directiorr
increases above a threshold.
It is interesting to note that changes in the natural constraints are always
detected by observing the position or force variable that is not being controlled. For
example, to detect the transition from Fig. 11.3(b) to Fig. 11.3(c), we monitor the
velocity C Z while we are controlling force C To discover when the peg has
hit the bottom of the hole, we monitor C although we are controlling C1J•
The framework we have introduced is somewhat simplistic. A more general and
rigorous method of "splitting" tasks into position-controlled and force-controlled
components can be found in [19].
Determining assembly strategies for fitting more complicated parts together
is quite complex. We have also neglected the effects of uncertainty in our simple
analysis of this task. The development of automatic planning systems that include
the effects of uncertainty and can be applied to practical situations has been a
research topic [4—8]. For a good review of these methods, see [9].
Figure 11.4 shows two extreme examples of contacting situations. In Fig. 11.4(a), the
manipulator is moving through free space. In this case, the natural constraints are
all force constraints—there is nothing to react against, so all forces are constrained
324
11.4: The two extremes of contacting situations. The manipulator on the left
is moving in free space where no reaction surface exits. The manipulator on the
right is glued to the wall so that no free motion is possible.
to be zero.1 With an arm having six degrees of freedom, we are free to move in six
degrees of freedom in position, but we are unable to exert forces in any direction.
Figure 11.4(b) shows the extreme situation of a manipulator with its end-effector
glued to a wall. In this case, the manipulator is subject to six natural position
constraints, because it is not free to be repositioned. However, the manipulator is
free to exert forces and torques to the object with six degrees of freedom.
In Chapters 9 and 10, we studied the position-control problem that applies
to the situation of Fig. 11.4(a). The situation of Fig. 11.4(b) does not occur very
often in practice; we usually must consider force control in the context of partially
constrained tasks, in which some degrees of freedom of the system are subject to
position control and others are subject to force control. Thus, in this chapter, we are
interested in considering hybrid positioli/force control schemes.
The hybrid position/force controller must solve three problems:
1. Position control of a manipulator along directions in which a natural force
2. Force control of a manipulator along directions in which a natural position
3. A scheme to implement the arbitrary mixing of these modes along orthogonal
degrees of freedom of an arbitrary frame, {C}.
11.5
FORCE CONTROL OF A MASS—SPRING SYSTEM
In Chapter 9, we began our study of the complete position-control problem with the
study of the very simple problem of controlling a single block of mass. We were then
able, in Chapter 10, to use a model of the manipulator in such a way that the problem
of controlling the entire manipulator became equivalent to controlling n independent
11t is important to remember that we are concerned here with forces of contact between end-effector
and environment, not inertial forces.
Section 11.5
Force control of a mass—spring system
masses (for a manipulator with n joints). In a similar way, we begin our look at
force control by controlling the force applied by a simple single-degree-of-freedom
In considering forces of contact, we must make some model of the environment
upon which we are acting. For the purposes of conceptual development, we will use
a very simple model of interaction between a controlled body and the environment.
We model contact with an environment as a spring—that is, we assume our system
is rigid and the environment has some stiffness, ke.
Let us consider the control of a mass attached to a spring, as in Fig. 11.5. We
wifi also include an unknown disturbance force,
which might be thought of as
modeling unknown friction or cogging in the manipulator's gearing. The variable we
wish to control is the force acting on the environment,
which is the force acting
in the spring:
The equation describing this physical system is
f = ml +keX +
or, written in terms of the variable we wish to control,
f = in k1 + fe +
Using the partitioned-controller concept, as well as
= fe +
we arrive at the control law,
f = mk1
+ kpfef] + fe +
(11.10)
FIGURE 11.5: A spring—mass system.
326
ef = fd fe is the force error between the desired force, fd' and the sensed
force on the environment, fe. If we could compute (11.10), we would have the
closed-loop system
ef+kVfef
(11.11)
in our control law, and 50 (11.10)
However, we cannot use knowledge of
is not feasible. We might leave that term out of the control law, but a steady-state
analysis shows that there is a better choice, especially when the stiffness of the
environment, ke, is high (the usual situation).
If we choose to leave the fdist term out of our control law, equate (11.9) and
(11.10), and do a steady-state analysis by setting all time derivatives to zero, we
find that
eç —
(11.12)
where a = Ink'
the effective force-feedback gain; however, if we choose to use
we find the steady-state
fd in the control law (11.10) in place of the term +
error to be
fdist
(11.13)
When the environment is stiff, as is often the case, a might be small, and so the
steady-state error calculated in (11.13) is quite an improvement over that of (11.12).
Therefore, we suggest the control law
f = ink1
+ kUfèf + kpfef] + fd.
(11.14)
Figure 11.6 is a block diagram of the closed-loop system using the control law (11.14).
Generally, practical considerations change the implementation of a forcecontrol servo quite a bit from the ideal shown in Fig. 11.6. First, force trajectories are
FIGURE 11.6:
A force control system for the spring—mass system.
FIG U RE 11.7:
A practical force-control system for the spring—mass system.
usually constants—that is, we are usually interested in controlling the contact force
to be at some constant level. Applications in which contact forces should follow
some arbitrary function of time are rare. Therefore, the fd and inputs of the
control system are very often permanently set to zero. Another reality is that sensed
forces are quite "noisy," and numerical differentiation to compute is ill-advised.
However, = kex, so we can obtain the derivative of the force on the environment
This is much more realistic, in that most manipulators have means of
as fe =
obtaining good measures of velocity. Having made these two pragmatic choices, we
write the control law as
f = in [kpfçlef —
(11.15)
with the corresponding block diagram shown in Fig. 11.7.
Note that an interpretation of the system of Fig. 11.7 is that force errors
generate a set-point for an inner velocity-control loop with gain kUf. Some forcecontrol laws also include an integral term to improve steady-state performance.
An important remaining problem is that the stiffness of the environment,
appears in our control law, but is often unknown and perhaps changes from time to
time. However, often an assembly robot is dealing with rigid parts, and ke could be
guessed to be quite high. Generally this assumption is made, and gains are chosen
such that the system is somewhat robust with respect to variations in
The purpose in constructing a control law to control the force of contact has
been to show one suggested structure and to expose a few issues. For the remainder
of this chapter, we wifi simply assume that such a force-controlling servo could be
built and abstract it away into a black box, as shown in Fig. 11.8. In practice, it is not
easy to build a high-performance force servo, and it is currently an area of active
research [11—14]. For a good review of this area, see [15].
328
FIGURE 11.8:
The force-control servo as a black box.
In this section, we introduce an architecture for a control system that implements
the hybrid position/force controller.
A Cartesian manipulator aligned with {C}
We wifi first consider the simple case of a manipulator having three degrees of
freedom with prismatic joints acting in the Z, Y, and X directions. For simplicity, we
will assume that each link has mass in and slides on frictionless bearings. Let us also
assume that the joint motions are lined up exactly with the constraint frame, {C}.
The end-effector is in contact with a surface of stiffness ke that is oriented with its
normal in the _C direction. Hence, force control is required in that direction, but
position control in the CX and CZ directions. (See Fig. 11.9.)
In this case, the solution to the hybrid position/force control problem is clear.
We should control joints 1 and 3 with the position controller developed for a unit
mass in Chapter 9. Joint 2 (operating in the Y direction) should be controlled with
the force controller developed in Section 11.4. We could then supply a position
trajectory in the CX and C z directions, while independently supplying a force
trajectory (perhaps just a constant) in the C Y direction.
If we wish to be able to switch the nature of the constraint surface such that its
normal might also be X or Z, we can slightly generalize our Cartesian arm-control
system as follows: We build the structure of the controller such that we may specify
a complete position trajectory in all three degrees of freedom and also a force
trajectory in all three degrees of freedom. Of course, we can't control so as to meet
these six constraints at any one time—rather, we will set modes to indicate which
components of which trajectory will be followed at any given time.
Consider the controller shown in Fig. 11.10. Here, we indicate the control of
all three joints of our simple Cartesian arm in a single diagram by showing both
the position controller and the force controller. The matrices S and S' have been
introduced to control which mode—position or force—is used to control each joint
of the Cartesian arm. The S matrix is diagonal, with ones and zeros on the diagonal.
Section 11.6
The hybrid position/force control scheme
FIGURE 11.9:
A Cartesian manipulator with three degrees of freedom in contact with
a surface.
FIGURE 11.10:
The hybrid controller for a 3-DOF Cartesian arm.
Where a one is present in S, a zero is present in S' and position control is in effect.
Where a zero is present in S, a one is present in S' and force control is in effect.
Hence the matrices S and 5' are simply switches that set the mode of control to
be used with each degree of freedom in {C}. In accordance with the setting of 5,
there are always three components of the trajectory being controlled, yet the mix
between position control and force control is arbitrary. The other three components
of desired trajectory and associated servo errors are being ignored. Hence, when a
certain degree of freedom is under force control, position errors on that degree of
freedom are ignored.
330
EXAMPLE 11.2
For the situation shown in Fig. 11.9, with motions in the Cy direction constrained
by the reaction surface, give the matrices S and 5'.
Because the X and Z components are to be position controlled, we enter ones
on the diagonal of S corresponding to these two components. This wifi cause the
position servo to be active in these two directions, and the input trajectory wifi be
followed. Any position trajectory input for the Y component wifi be ignored. The S'
matrix has the ones and zeros on the diagonal inverted; hence, we have
ri 0
LU 0 1
Figure 11.10 shows the hybrid controller for the special case that the joints
line up exactly with the constraint frame, {C}. In the following subsection, we use
techniques studied in previous chapters to generalize the controller to work with
general manipulators and for an arbitrary {C}; however, in the ideal case, the system
performs as if the manipulator had an actuator "lined up" with each of the degrees
of freedom in {C}.
A general manipulator
Generalizing the hybrid controller shown in Fig. 11.10 so that a general manipulator
may be used is straightforward with the concept of Cartesian-based control. Chapter
6 discussed how the equations of motion of a manipulator could be written in
terms of Cartesian motion of the end-effector, and Chapter 10 showed how such
a formulation might be used to achieve decoupled Cartesian position control of a
manipulator. The major idea is that, through use of a dynamic model written in
Cartesian space, it is possible to control so that the combined system of the actual
manipulator and computed model appear as a set of independent, uncoupled unit
masses. Once this decoupling and linearizing are done, we can apply the simple
servo already developed in Section 11.4.
Figure 11.11 shows the compensation based on the formulation of the manip-
ulator dynamics in Cartesian space such that the manipulator appears as a set of
uncoupled unit masses. For use in the hybrid control scheme, the Cartesian dynamics
and the Jacobian are written in the constraint frame, {C}. Likewise, the kinematics
are computed with respect to the constraint frame.
Because we have designed the hybrid controller for a Cartesian manipulator
aligned with the constraint frame, and because the Cartesian decoupling scheme
provides us with a system with the same input—output properties, we need only
combine the two to generate the generalized hybrid position/force controller.
Figure 11.12 is a block diagram of the hybrid controller for a general manipulator. Note that the dynamics are written in the constraint frame, as is the Jacobian.
FIGURE 11.11:
The Cartesian decoupling scheme introduced in Chapter 10.
The hybrid position/force controller for a general manipulator. For
simplicity, the velocity-feedback ioop has not been shown.
FIG U RE 11.12:
The kinematics are written to include the transformation of coordinates into the
constraint frame, and the sensed forces are likewise transformed into {C}. Servo
errors are calculated in {C}, and control modes within {C} are set through proper
choice of S.2 Figure 11.13 shows a manipulator being controlled by such a system.
2The partitioning of control modes along certain task-related directions has been generalized in [10]
from the more basic approach presented in this chapter.
332
FIGURE 11.13: A PUMA 560 manipulator washes a window under control of
the COSMOS system developed under 0. Khatib at Stanford University. These
experiments use force-sensing fingers and a control structure similar to that of
Fig. 11.12 [10].
Adding variable stiffness
Controlling a degree of freedom in strict position or force control represents control
at two ends of the spectrum of servo stiffness. An ideal position servo is infinitely
stiff and rejects all force disturbances acting on the system. In contrast, an ideal force
servo exhibits zero stiffness and maintains the desired force application regardless
of position disturbances. It could be useful to be able to control the end-effector to
exhibit stiffnesses other than zero or infinite. In general, we might wish to control
the mechanical impedance of the end-effector [14, 16, 17].
In our analysis of contact, we have imagined that the environment is very
stiff. When we contact a stiff environment, we use zero-stiffness force control.
When we contact zero stiffness (moving in free space) we use high-stiffness position
control. Hence, it appears that controlling the end-effector to exhibit a stiffness that
is approximately the inverse of the local environment is perhaps a good strategy.
Therefore, in dealing with plastic parts or springs, we could wish to set servo stiffness
to other than zero or infinite.
Within the framework of the hybrid controller, this is done simply by using
position control and lowering the position gain corresponding to the appropriate
degree of freedom in (C). Generally, if this is done, the corresponding velocity
gain is lowered so that that degree of freedom remains critically damped. The
ability to change both position and velocity gains of the position servo along the
Section 1 1.7
degrees of freedom of {C} allows
Current industrial-robot control schemes
the hybrid position/force controller to implement
a generalized impedance of the end-effector [17]. However, in many practical
situations we are dealing with the interaction of stiff parts, so that pure position
control or pure force control is desired.
11.7
CURRENT INDUSTRIAL-ROBOT CONTROL SCHEMES
True force control, such as the hybrid position/force controller introduced in this
chapter, does not exist today in industrial robots. Among the problems of practical
implementation are the rather large amount of computation required, lack of
accurate parameters for the dynamic model, lack of rugged force sensors, and the
burden of difficulty placed on the user in specifying a position/force strategy.
Passive compliance
Extremely rigid manipulators with very stiff position servos are ill-suited to tasks in
which parts come into contact and contact forces are generated. In such situations,
parts are often jammed or damaged. Ever since early experiments with manipulators
attempting to do assembly, it was realized that, to the extent that the robots could
perform such tasks, it was only thanks to the compliance of the parts, of the fixtures,
or of the arm itself. This ability of one or more parts of the system to "give" a little
was often enough to allow the successful mating of parts.
Once this was realized, devices were specially designed to introduce compliance
into the system on purpose. The most successful such device is the RCC or remote
center compliance device developed at Draper Labs [18]. The RCC was cleverly
designed so that it introduced the "right" kind of compliance, which allowed certain
tasks to proceed smoothly and rapidly with little or no chance of jamming. The
RCC is essentially a spring with six degrees of freedom, which is inserted between
the manipulator's wrist and the end-effector. By setting the stiffnesses of the six
springs, various amounts of compliance can be introduced. Such schemes are called
passive-compliance schemes and are used in industrial applications of manipulators
in some tasks.
Compliance through softening position gains
Rather than achieving compliance in a passive, and therefore fixed, way, it is
possible to devise schemes in which the apparent stiffness of the manipulator
is altered through adjustment of the gains of a position-control system. A few
industrial robots do something of this type for applications such as grinding, in
which contact with a surface needs to be maintained but delicate force control is not
required.
A particularly interesting approach has been suggested by Salisbury [16]. In
this scheme, the position gains in a joint-based servo system are modified in such a
way that the end-effector appears to have a certain stiffness along Cartesian degrees
of freedom: Consider a general spring with six degrees of freedom. Its action could
(11.17)
334
is a diagonal 6 x 6 matrix with three linear stiffnesses followed by three
torsional stiffnesses on the diagonal. How could we make the end-effector of a
manipulator exhibit this stiffness characteristic?
Recaffing the definition of the manipulator Jacobian, we have
= J(e)8e.
(11.18)
Combining with (11.17) gives
(11.19)
From static-force considerations, we have
(11.20)
which, combined with (11.19), yields
(11.21)
Here, the Jacobian is usually written in the tool frame. Equation (11.21) is an
expression for how joint torques should be generated as a function of small changes
in joint angles, Se, in order to make the manipulator end-effector behave as a
Cartesian spring with six degrees of freedom.
Whereas a simple joint-based position controller might use the control law
(11.22)
are constant diagonal gain matrices and E is servo error defined
e, Salisbury suggests using
= jT (O)K J(®)E +
(11.23)
is the desired stiffness of the end-effector in Cartesian space. For a
manipulator with six degrees of freedom,
is diagonal with the six values on the
diagonal representing the three translational and three rotational stiffnesses that
the end-effector is to exhibit. Essentially, through use of the Jacobian, a Cartesian
stiffness has been transformed to a joint-space stiffness.
Force sensing allows a manipulator to detect contact with a surface and, using this
sensation, to take some action. For example, the term guarded move is sometimes
used to mean the strategy of moving under position control until a force is felt,
then halting motion. Additionally, force sensing can be used to weigh objects that
the manipulator lifts. This can be used as a simple check during a parts-handling
operation—to ensure that a part was acquired or that the appropriate part was
acquired.
Some commercially available robots come equipped with force sensors in the
end-effector. These robots can be programmed to stop motion or take other action
when a force threshold is exceeded, and some can be programmed to weigh objects
that are grasped in the end-effector.
[1] M. Mason, "Compliance and Force Control for Computer Controlled Manipulators,"
M.S. Thesis, MIT Al Laboratory, May 1978.
J. Craig and M. Raibert, "A Systematic Method for Hybrid Position/Force Control
of a Manipulator," Proceedings of the 1979 IEEE Computer Software Applications
Conference, Chicago, November 1979.
[3] M. Raibert and J. Craig, "Hybrid Position/Force Control of Manipulators," ASME
Journal of Dynamic Systems, Measurement, and Control, June 1981.
[4] T. Lozano-Perez, M. Mason, and R. Taylor, "Automatic Synthesis of Fine-Motion
Strategies for Robots," 1st International Symposium of Robotics Research, Bretton
Woods, NH, August 1983.
[5] M. Mason, "Automatic Planning of Fine Motions: Correctness and Completeness,"
IEEE International Conference on Robotics, Atlanta, March 1984.
[6] M. Erdmann, "Using Backprojections for the Fine Motion Planning with Uncertainty," The International Journal of Robotics Research, Vol. 5, No. 1, 1986.
[7] S. Bucidey, "Planning and Teaching Compliant Motion Strategies," Ph.D. Dissertation, Department of Electrical Engineering and Computer Science, MIT, January
1986.
[8] B. Donald, "Error Detection and Recovery for Robot Motion Planning with Uncertainty," Ph.D. Dissertation, Department of Electrical Engineering and Computer
Science, MIT, July 1987.
[9] J.C. Latombe, "Motion Planning with Uncertainty: On the Preimage Backchaining Approach," in The Robotics Review, 0. Khatib, J. Craig, and T. Lozano-Perez,
Editors, MIT Press, Cambridge, MA, 1988.
[10] 0. Khatib, "A Unified Approach for Motion and Force Control of Robot Manipulators: The Operational Space Formulation," IEEE Journal ofRobotics andAutoniation,
[11] D. Whitney, "Force Feedback Control of Manipulator Fine Motions," Proceedings
Joint Automatic Control Conference, San Francisco, 1976.
[12] 5. Eppinger and W. Seering, "Understanding Bandwidth Limitations in Robot Force
Control," Proceedings of the IEEE Conference on Robotics and Automation, Raleigh,
NC, 1987.
[13] W. Townsend and J.K. Salisbury, "The Effect of Coulomb Friction and Stiction on
Force Control," Proceedings of the IEEE Conference on Robotics and Automation,
Raleigh, NC, 1987.
[14] N. Hogan, "Stable Execution of Contact Tasks Using Impedance Control," Proceed-
ings of the IEEE Conference on Robotics and Automation, Raleigh, NC, 1987.
[15] N. Hogan and E. Colgate, "Stability Problems in Contact Tasks," in The Robotics
Review, 0. Khatib, J. Craig, and T. Lozano-Perez, Editors, MIT Press, Cambridge,
[16] J.K. Salisbury, "Active Stiffness Control of a Manipulator in Cartesian Coordinates,"
19th IEEE Conference on Decision and Control, December 1980.
336
[17] J.K. Salisbury and J. Craig, "Articulated Hands: Force Control and Kinematic Issues,"
International Journal of Robotics Research, Vol. 1, No. 1.
[18] S. Drake, "Using Compliance in Lieu of Sensory Feedback for Automatic Assembly,"
Ph.D. Thesis, Mechanical Engineering Department, MIT, September 1977.
[19] R. Featherstone, S.S. Thiebaut, and 0. Khatib, "A General Contact Model for
Dynamically-Decoupled Force/Motion Control," Proceedings of the IEEE Conference
on Robotics and Automation, Detroit, 1999.
[12] Give the natural constraints present for a peg of square cross section sliding
into a hole of square cross section. Show your definition of (C) in a sketch.
11.2 [10] Give the artificial constraints (i.e., the trajectory) you would suggest in order
to cause the peg in Exercise 11.1 to slide further into the hole without jamming.
11.3 [20] Show that using the control law (11.14) with a system given by (11.9) results
in the error-space equation
ef +
+ !n'ke)ef = lfl1kefdjst,
and, hence, that choosing gains to provide critical damping is possible only if the
stiffness of the environment, ice, is known.
11.4 [17] Given
0.500 0.866 0.000 0.0
0.000 0.000 1.000 5.0
if the force—torque vector at the origin of (A) is
find the 6 x 1 force—torque vector with reference point at the origin of (B).
11.5 [17] Given
0.866 0.500 0.000 10.0
—0.500 0.866 0.000 0.0
AU—
find the 6 x 1 force—torque vector with reference point at.the origin of {B).
Programming exercise (Part 11)
11.14: A block constrained by a floor below and a wall to the side.
11.6 [18] Describe in English how you accomplish the insertion of a book into a
narrow
crack between books on your crowded bookshelf.
11.7 [201! Give the natural and artificial constraints for the task of closing a hinged
door with a manipulator. Make any reasonable assumptions needed. Show your
definition of {C} in a sketch.
11.8 [20] Give the natural and artificial constraints for the task of uncorking a bottle of
champagne with a manipulator. Make any reasonable assumptions needed. Show
your definition of {C} in a sketch.
11.9 [41] For the stiffness servo system of Section 11.7, we have made no claim that the
system is stable. Assume that (11.23) is used as the servo portion of a decoupled
and linearized manipulator (so that
ii joints appear as unit masses). Prove that
the controller is stable for any
which is negative definite.
11.10 [48] For the stiffness servo system of Section 11.7, we have made no claim that
the system is or can be critically damped. Assume that (11.23) is used as the servo
portion of a decoupled and linearized manipulator (so that the n joints appear as
unit masses). Is it possible to design a
that is a function of 0 and causes the
system to be critically damped over all configurations?
11.11 [15] As shown in Fig. 11.14, a block is constrained below by a floor and to the
side by a wall. Assuming this contacting situation is maintained over an interval
of time, give the natural constraints that are present.
PROGRAMMING EXERCISE (PART 11)
Implement a Cartesian stiffness-control system for the three-link planar manipulator by
using the control law (11.23) to control the simulated arm. Use the Jacobian written in
frame (3].
of the form
For the manipulator in position 0 [60.0 90030.0] and for
rksmau 0.0
kbig
0.0 kbig
338
simulate the application of the following static forces:
a 1-newton force acting at the origin of {3} in the
direction, and
2. a 1-newton force acting at the origin of {3} in the Y3 direction.
The values of kSmall and kbjg should be found experimentally. Use a large value of
kbig for high stiffness in the
direction and a low value of
for low stiffness in the
X3 direction. What are the steady-state deflections in the two cases?
Robot programming languages
and systems
12.1 INTRODUCTION
12.2 THE THREE LEVELS OF ROBOT PROGRAMMING
12.3 A SAMPLE APPLICATION
12.4 REQUIREMENTS OF A ROBOT PROGRAMMING LANGUAGE
12.5 PROBLEMS PECULIAR TO ROBOT PROGRAMMING LANGUAGES
12.1
In this chapter, we begin to consider the interface between the human user and
an industrial robot. It is by means of this interface that a user takes advantage of
all the underlying mechanics and control algorithms we have studied in previous
chapters.
The sophistication of the user interface is becoming extremely important as
manipulators and other programmable automation are applied to more and more
demanding industrial applications. It turns out that the nature of the user interface
is a very important concern. In fact, most of the challenge of the design and use of
industrial robots focuses on this aspect of the problem.
factory automation, manipulators can adapt to variations as the task proceeds.
In considering the programming of manipulators, it is important to remember
that they are typically only a minor part of an automated process. The term
workceil is used to describe a local collection of equipment, which may include
one or more manipulators, conveyor systems, parts feeders, and fixtures. At the
next higher level, workcells might be interconnected in factorywide networks so
that a central control computer can control the overall factory flow. Hence, the
programming of manipulators is often considered within the broader problem
of programming a variety of interconnected machines in an automated factory
workcell.
Unlike that in the previous 11 chapters, the material in this chapter (and the
next chapter) is of a nature that constantly changes. It is therefore difficult to present
this material in a detailed way. Rather, we attempt to point out the underlying
fundamental concepts, and we leave it to the reader to seek out the latest examples,
as industrial technology continues to move forward.
340
Chapter 12
Robot programming languages and systems
122 THE THREE LEVELS OF ROBOT PROGRAMMING
There
have been many styles of user interface developed for programming
robots. Before the rapid proliferation of microcomputers in industry, robot controllers resembled the simple sequencers often used to control fixed automation.
Modern approaches focus on computer programming, and issues in programming robots include all the issues faced in general computer programming—and
more.
Teach by showing
Early robots were all programmed by a method that we will call teach by showing,
which involved moving the robot to a desired goal point and recording its position in
a memory that the sequencer would read during playback. During the teach phase,
the user would guide the robot either by hand or through interaction with a teach
pendant. Teach pendants are handlield button boxes that allow control of each
manipulator joint or of each Cartesian degree of freedom. Some such controllers
allow testing and branching, so that simple programs involving logic can be entered.
Some teach pendants have alphanumeric displays and are approaching hand-held
terminals in complexity. Figure 12.1 shows an operator using a teach pendant to
program a large industrial robot.
FIGURE 12.1: The GMF S380 is often used in automobile-body spot-welding applications. Here an operator uses a teach-pendant interface to program the manipulator.
Photo courtesy of GIviFanuc Corp.
Section 12.2
The three levels of robot programming
Explicit robot programming languages
Ever since the arrival of inexpensive and powerful computers, the trend has
been increasingly toward programming robots via programs written in computer
programming languages. Usually, these computer programming languages have
special features that apply to the problems of programming manipulators and
so are called robot programming languages (RPLs). Most of the systems that
come equipped with a robot programming language have nonetheless retained a
teach-pendant-style interface also.
Robot programming languages have likewise taken on many forms. We will
split them into three categories:
1. Specialized manipulation languages. These robot programming languages have
been built by developing a completely new language that, although addressing
robot-specific areas, might well be considered a general computer program-
ming language. An example is the VAL language developed to control the
industrial robots by Unimation, Inc [1]. VAL was developed especially as a
manipulator control language; as a general computer language, it was quite
weak. For example, it did not support floating-point numbers or character
strings, and subroutines could not pass arguments. A more recent version,
V-Il, provided these features [2]. The current incarnation of this language,
V+, includes many new features [13]. Another example of a specialized manip-
ulation language is AL, developed at Stanford University [3]. Although the
AL language is now a relic of the past, it nonetheless provides good examples
of some features still not found in most modern languages (force control,
parallelism). Also, because it was built in an academic environment, there are
references available to describe it [3]. For these reasons, we continue to make
reference to it.
2. Robot library for an existing computer language. These robot programming
languages have been developed by starting with a popular computer language (e.g., Pascal) and adding a library of robot-specific subroutines. The
user then writes a Pascal program making use of frequent calls to the predefined subroutine package for robot-specific needs. An examples is AR-BASIC
from American Cimfiex [4], essentially a subroutine library for a standard
BASIC implementation. JARS, developed by NASA's Jet Propulsion Lab-
oratory, is an example of such a robot programming language based on
Pascal [5].
3. Robot library for a new general-purpose language. These robot programming languages have been developed by first creating a new general-purpose
language as a programming base and then supplying a library of predefined
robot-specific subroutines. Examples of such robot programming languages
are RAPID developed by ABB Robotics [6], AML developed by IBM [7], and
KAREL developed by GMF Robotics [8].
Studies of actual application programs for robotic workcells have shown that
a large percentage of the language statements are not robot-specific [7]. Instead,
a great deal of robot programming has to do with initialization, logic testing and
branching, communication, and so on. For this reason, a trend might develop to
342
move away from developing special languages for robot programming and move
toward developing extensions to general languages, as in categories 2 and 3 above.
Task-level programming languages
third level of robot programming methodology is embodied in task-level
progranmiing languages. These languages allow the user to command desired
subgoals of the task directly, rather than specify the details of every action the robot
is to take. In such a system, the user is able to include instructions in the application
program at a significantly higher level than in an explicit robot programming
language. A task-level robot programming system must have the ability to perform
many planning tasks automatically. For example, if an instruction to "grasp the
bolt" is issued, the system must plan a path of the manipulator that avoids coffision
with any surrounding obstacles, must automatically choose a good grasp location on
the bolt, and must grasp it. In contrast, in an explicit robot programming language,
all these choices must be made by the programmer.
The border between explicit robot programming languages and task-level
programming languages is quite distinct. Incremental advances are being made
to explicit robot programming languages to help to ease programming, but these
enhancements cannot be counted as components of a task-level programming
system. True task-level programming of manipulators does not yet exist, but it has
been an active topic of research [9, 10] and continues as a research topic today.
12.3
A SAMPLE APPLICATION
Figure 12.2 shows an automated workcell that completes a small subassembly in
a hypothetical manufacturing process. The workcell consists of a conveyor under
computer control that delivers a workpiece; a camera connected to a vision system,
used to locate the workpiece on the conveyor; an industrial robot (a PUIVIA 560 is
pictured) equipped with a force-sensing wrist; a small feeder located on the work
surface that supplies another part to the manipulator; a computer-controlled press
that can be loaded and unloaded by the robot; and a pallet upon which the robot
places finished assemblies.
The entire process is controlled by the manipulator's controller in a sequence,
as follows:
1. The conveyor is signaled to start; it is stopped when the vision system reports
that a bracket has been detected on the conveyor.
2. The vision system judges the bracket's position and orientation on the conveyor
and inspects the bracket for defects, such as the wrong number of holes.
3. Using the output of the vision system, the manipulator grasps the bracket with
a specified force. The distance between the fingertips is checked to ensure that
the bracket has been properly grasped. If it has not, the robot moves out of
the way and the vision task is repeated.
4. The bracket is placed in the fixture on the work surface. At this point, the
conveyor can be signaled to start again for the next bracket—that is, steps 1
and 2 can begin in parallel with the following steps.
Section 12.3
FIGURE 12.2:
A sample application
An automated workcell containing an industrial robot.
5. A pin is picked from the feeder and inserted partway into a tapered hole in the
bracket. Force control is used to perform this insertion and to perform simple
checks on its completion. (If the pin feeder is empty, an operator is notified
and the manipulator waits until commanded to resume by the operator.)
6. The bracket—pin assembly is grasped by the robot and placed in the press.
7. The press is commanded to actuate, and it presses the pin the rest of the way
into the bracket. The press signals that it has completed, and the bracket is
placed back into the fixture for a final inspection.
8. By force sensing, the assembly is checked for proper insertion of the pin. The
manipulator senses the reaction force when it presses sideways on the pin and
can do several checks to discover how far the pin protrudes from the bracket.
9. If the assembly is judged to be good, the robot places the finished part into the
next available pallet location. If the pallet is ftll, the operator is signaled. If
the assembly is bad, it is dropped into the trash bin.
10. Once Step 2 (started earlier in parallel) is complete, go to Step 3.
This is an example of a task that is possible for today's industrial robots. It
should be clear that the definition of such a process through "teach by showing"
techniques is probably not feasible. For example, in dealing with pallets, it is
laborious to have to teach all the pallet compartment locations; it is much preferable
to teach only the corner location and then compute the others from knowledge of
the dimensions of the pallet. Further, specifying interprocess signaling and setting
up parallelism by using a typical teach pendant or a menu-style interface is usually
344
not possible at all. This kind of application necessitates a robot programming-
language approach to process description. (See Exercise 12.5.) On the other hand,
this application is too complex for any existing task-level languages to deal with
directly. It is typical of the great many applications that must be addressed with an
explicit robot programming approach. We will keep this sample application in mind
as we discuss features of robot programming languages.
12.4
REQUIREMENTS OF A ROBOT PROGRAMMING LANGUAGE
World modeling
Manipulation programs must, by definition, involve moving objects in three-dimen-
sional space, so it is clear that any robot programming language needs a means of
describing such actions. The most common element of robot programming languages
is the existence of special geometric types. For example, types are introduced to
represent joint-angle sets, Cartesian positions, orientations, and frames. Predefined
operators that can manipulate these types often are available. The "standard
frames" introduced in Chapter 3 might serve as a possible model of the world: All
motions are described as tool frame relative to station frame, with goal frames being
constructed from arbitrary expressions involving geometric types.
Given a robot programming environment that supports geometric types, the
robot and other machines, parts, and fixtures can be modeled by defining named
variables associated with each object of interest. Figure 12.3 shows part of our
example workcell with frames attached in task-relevant locations. Each of these
frames would be represented with a variable of type "frame" in the robot program.
{Pin-grasp}
(Feeder}
{Fixture}
{Table}
FIGURE 12.3: Often, a workcell is modeled simply, as a set of frames attached to
relevant objects.
Section 12.4
Requirements of a robot programming language
In many robot progranmiing languages, this ability to define named variables
of various geometric types and refer to them in the program forms the basis of the
world model. Note that the physical shapes of the objects are not part of such a world
model, and neither are surfaces, volumes, masses, or other properties. The extent
to which objects in the world are modeled is one of the basic design decisions made
when designing a robot programming system. Most present-day systems support
only the style just described.
Some world-modeling systems allow the notion of aflixments between named
objects [3] —that is, the system can be notified that two or more named objects have
become "affixed"; from then on, if one object is explicitly moved with a language
statement, any objects affixed to it are moved with it. Thus, in our application, once
the pin has been inserted into the hole in the bracket, the system would be notified
(via a language statement) that these two objects have become affixed. Subsequent
motions of the bracket (that is, changes to the value of the frame variable "bracket")
would cause the value stored for variable "pin" to be updated along with it.
Ideally, a world-modeling system would include much more information about
the objects with which the manipulator has to deal and about the manipulator
itself. For example, consider a system in which objects are described by CAD-style
models that represent the spatial shape of an object by giving definitions of its edges,
surfaces, or volume. With such data available to the system, it begins to become
possible to implement many of the features of a task-level programming system.
These possibilities are discussed further in Chapter 13.
Motion specification
A very basic function of a robot programming language is to allow the description
of desired motions of the robot. Through the use of motion statements in the
language, the user interfaces to path planners and generators of the style described
in Chapter 7. Motion statements allow the user to specify via points, the goal point,
and whether to use joint-interpolated motion or Cartesian straight-line motion.
Additionally, the user might have control over the speed or duration of a motion.
To ifiustrate various syntaxes for motion primitives, we will consider the following example manipulator motions: (1) move to position "goall," then (2) move
in a straight line to position "goal2," then (3) move without stopping through "vial"
and come to rest at "goal3." Assuming all of these path points had already been
taught or described textually, this program segment would be written as follows:
In VAL II,
move goall
moves goal2
move vial
move goal3
In AL (here controlling the manipulator "garm"),
move garm to goall;
move garm to goal2 linearly;
move garm to goal3 via vial;
346
Most languages have similar syntax for simple motion statements like these.
Differences in the basic motion primitives from one robot programming language
to another become more apparent if we consider features such as the following:
1. the ability to do math on such structured types as frames, vectors, and rotation
matrices;
2. the ability to describe geometric entities like frames in several different
convenient representations—along with the ability to convert between representations;
3. the ability to give constraints on the duration or velocity of a particular
move—for example, many systems allow the user to set the speed to a fraction
of maximum, but fewer allow the user to specify a desired duration or a desired
maximum joint velocity directly;
4. the ability to specify goals relative to various frames, including frames defined
by the user and frames in motion (on a conveyor, for example).
Flow of execution
As in more conventional computer programming languages, a robot programming
system allows the user to specify the flow of execution—that is, concepts such as
testing and branching, looping, calls to subroutines, and even interrupts are generally
found in robot programming languages.
More so than in many computer applications, parallel processing is generally
important in automated workcell applications. First of all, very often two or more
robots are used in a single workcell and work simultaneously to reduce the cycle time
of the process. Even in single-robot applications, such as the one shown in Fig. 12.2,
other workcell equipment must be controlled by the robot controller in a parallel
fashion. Hence, signal and wait primitives are often found in robot programming
languages, and occasionally more sophisticated parallel-execution constructs are
provided [3].
Another frequent occurrence is the need to monitor various processes with
some kind of sensor. Then, either by interrupt or through polling, the robot system
must be able to respond to certain events detected by the sensors. The ability
to specify such event monitors easily is afforded by some robot programming
languages [2, 3].
Programming environment
As with any computer languages, a good programming environment fosters pro-
grammer productivity. Manipulator programming is difficult and tends to be very
interactive, with a lot of trial and error. If the user were forced to continually repeat
the "edit-compile-run" cycle of compiled languages, productivity would be low.
Therefore, most robot programming languages are now interpreted, so that individual language statements can be run one at a time during program development and
debugging. Many of the language statements cause motion of a physical device, so
the tiny amount of time required to interpret the language statements is insignificant.
Typical programming support, such as text editors, debuggers, and a file system, are
also required.
Section 12.5
Problems peculiar to robot programming languages
Sensor integration
An extremely important part of robot programming has to do with interaction with
sensors. The system should have, at a minimum, the capability to query touch and
force sensors and to use the response in if-then-else constructs. The ability to specify
event monitors to watch for transitions on such sensors in a background mode is
also very useful.
Integration with a vision system allows the vision system to send the manipulator system the coordinates of an object of interest. For example, in our sample
application, a vision system locates the brackets on the conveyor belt and returns
to the manipulator controller their position and orientation relative to the camera.
The camera's frame is known relative to the station frame, so a desired goal frame
for the manipulator can be computed from this information.
Some sensors could be part of other equipment in the workcell—for example,
some robot controllers can use input from a sensor attached to a conveyor belt so
that the manipulator can track the belt's motion and acquire objects from the belt
as it moves [2].
The interface to force-control capabilities, as discussed in Chapter 9, comes
through special language statements that allow the user to specify force strategies [3].
Such force-control strategies are by necessity an integrated part of the manipulator
control system—the robot programming language simply serves as an interface to
those capabilities. Programming robots that make use of active force control might
require other special features, such as the ability to display force data collected
during a constrained motion [3].
In systems that support active force control, the description of the desired
force application could become part of the motion specification. The AL language
describes active force contro] in the motion primitives by specifying six components
of stiffness (three translational and three rotational) and a bias force. In this way,
the manipulator's apparent stiffness is programmable. To apply a force, usually
the stiffness is set to zero in that direction and a bias force is specified—for
example,
move garm to
goal
with stif±ness=(80, 80, 0, 100, 100, 100)
with force=20*ounces along zhat;
12.5
PROBLEMS PECULIAR TO ROBOT PROGRAMMING LANGUAGES
Advances in recent years have helped, but programming robots is still difficult. Robot
programming shares all the problems of conventional computer programming, plus
some additional difficulties caused by effects of the physical world [12].
Internal world model versus external reality
A central feature of a robot programming system is the world model that is
maintained internally in the computer. Even when this model is quite simple, there
are ample difficulties in assuring that it matches the physical reality that it attempts
to model. Discrepancies between internal model and external reality result in poor
or failed grasping of objects, coffisions, and a host of more subtle problems.
348
This correspondence between internal model and the external world must be
established for the program's initial state and must be maintained throughout its
execution. During initial programming or debugging, it is generally up to the user to
suffer the burden of ensuring that the state represented in the program corresponds
to the physical state of the workcell. Unlike more conventional programming,
where only internal variables need to be saved and restored to reestablish a former
situation, in robot programming, physical objects must usually be repositioned.
Besides the uncertainty inherent in each object's position, the manipulator
itself is limited to a certain degree of accuracy. Very often, steps in an assembly
will require the manipulator to make motions requiring greater precision than it
is capable of. A common example of this is inserting a pin into a hole where
the clearance is an order of magnitude less than the positional accuracy of the
manipulator. To further complicate matters, the manipulator's accuracy usually
varies over its workspace.
In dealing with those objects whose locations are not known exactly, it is
essential to somehow refine the positional information. This can sometimes be
done with sensors (e.g., vision, touch) or by using appropriate force strategies for
constrained motions.
During debugging of manipulator programs, it is very useful to be able to
modify the program and then back up and try a procedure again. Backing up
entails restoring the manipulator and objects being manipulated to a former state.
However, in working with physical objects, it is not always easy, or even possible,
to undo an action. Some examples are the operations of painting, riveting, driJling,
or welding, which cause a physical modffication of the objects being manipulated. It
might therefore be necessary for the user to get a new copy of the object to replace
the old, modified one. Further, it is likely that some of the operations just prior
to the one being retried wifi also need to be repeated to establish the proper state
required before the desired operation can be successfully retried.
Context sensitivity
Bottom-up programming is a standard approach to writing a large computer program
in which one develops small, low-level pieces of a program and then puts them
together into larger pieces, eventually attaining a completed program. For this
method to work, it is essential that the small pieces be relatively insensitive to the
language statements that precede them and that there be no assumptions concerning
the context in which these program pieces execute. For manipulator programming,
this is often not the case; code that worked reliably when tested in isolation frequently
fails when placed in the context of the larger program. These problems generally
arise from dependencies on manipulator configuration and speed of motions.
Manipulator programs can be highly sensitive to initial conditions—for example, the initial manipulator position. In motion trajectories, the starting position will
influence the trajectory that will be used for the motion. The initial manipulator
position might also influence the velocity with which the arm wifi be moving during
some critical part of the motion. For example, these statements are true for manipulators that follow the cubic-spline joint-space paths studied in Chapter 7. These
effects can sometimes be dealt with by proper programming care, but often such
problems do not arise until after the initial language statements have been debugged
in isolation and are then joined with statements preceding them.
Because of insufficient manipulator accuracy, a program segment written to
perform an operation at one location is likely to need to be tuned (i.e., positions
retaught and the like) to make it work at a different location. Changes in location
within the workcell result in changes in the manipulator's configuration in reaching
goal locations. Such attempts at relocating manipulator motions within the workcell
test the accuracy of the manipulator kinematics and servo system, and problems
frequently arise. Such relocation could cause a change in the manipulator's kinematic
configuration—for example, from left shoulder to right shoulder, or from elbow
up to elbow down. Moreover, these changes in configuration could cause large arm
motions during what had previously been a short, simple motion.
The nature of the spatial shape of trajectories is likely to change as paths are
located in different portions of the manipulator's workspace. This is particularly
true of joint-space trajectory methods, but use of Cartesian-path schemes can also
lead to problems when singularities are nearby.
When testing a manipulator motion for the first time, it often is wise to have
the manipulator move slowly. This allows the user a chance to stop the motion if it
appears to be about to cause a coffision. It also allows the user to inspect the motion
closely. After the motion has undergone some initial debugging at a slower speed it
is then desirable to increase motion speeds. Doing so might cause some aspects of
the motion to change. Limitations in most manipulator control systems cause greater
servo errors, which are to be expected if the quicker trajectory is followed. Also, in
force-control situations involving contact with the environment, speed changes can
completely change the force strategies required for success.
The manipulator's configuration also affects the delicacy and accuracy of the
forces that can be applied with it. This is a function of how well conditioned
the Jacobian of the manipulator is at a certain configuration, something generally
difficult to consider when developing robot programs.
Error recovery
Another direct consequence of working with the physical world is that objects might
not be exactly where they should be and, hence, motions that deal with them could
fail. Part of manipulator programming involves attempting to take this into account
and making assembly operations as robust as possible, but, even so, errors are likely,
and an important aspect of manipulator progranmiing is how to recover from these
errors.
Almost any motion statement in the user's program can fail, sometimes for
a variety of reasons. Some of the more common causes are objects shifting or
dropping out of the hand, an object missing from where it should be, jamming
during an insertion, and not being able to locate a hole.
The first problem that arises for error recovery is identifying that an error has
indeed occurred. Because robots generally have quite limited sensing and reasoning
capabilities, error detection is often difficult. In order to detect an error, a robot
program must contain some type of explicit test. This test might involve checking
the manipulator's position to see that it lies in the proper range; for example, when
doing an insertion, lack of change in position might indicate jamming, or too much
350
might indicate that the hole was missed entirely or the object has slipped
out of the hand. If the manipulator system has some type of visual capabilities, then
change
it might take a picture and check for the presence or absence of an object and, if
the object is present, report its location. Other checks might involve force, such as
weighing the load being carried to check that the object is still there and has not
been dropped, or checking that a contact force remains within certain bounds during
a motion.
Every motion statement in the program might fail, so these explicit checks can
be quite cumbersome and can take up more space than the rest of the program.
Attempting to deal with all possible errors is extremely difficult; usually, just the
few statements that seem most likely to fail are checked. The process of predicting
which portions of a robot application program are likely to fail is one that requires
a certain amount of interaction and partial testing with the robot during the
program-development stage.
Once an error has been detected, an attempt can be made to recover from
it. This can be done totally by the manipulator under program control, or it might
involve manual intervention by the user, or some combination of the two. In any
event, the recovery attempt could in turn result in new errors. It is easy to see how
code to recover from errors can become the major part of the manipulator program.
The use of parallelism in manipulator programs can further complicate recovery from errors. When several processes are running concurrently and one causes
an error to occur, it could affect other processes. In many cases, it will be possible
to back up the offending process, while allowing the others to continue. At other
times, it wifi be necessary to reset several or all of the running processes.
[1] B. Shimano, "VAL: A Versatile Robot Programming and Control System," Proceed-
ings of COMIPSAC 1979, Chicago, November 1979.
[2] B. Shimano, C. Geschke, and C. Spalding, "VAL II: A Robot Programming Language
and Control System," SME Robots VIII Conference, Detroit, June 1984.
[3] 5. Mujtaba and R. Goldman, "AL Users' Manual," 3rd edition, Stanford Department
of Computer Science, Report No. STAN-CS-81-889, December 1981.
[4] A. Gilbert et al., AR-BASIC: An Advanced and User Friendly Programming System
for Robots, American Robot Corporation, June 1984.
J. Craig, "JARS—JIPL Autonomous Robot System: Documentation and Users
Guide," JPL Interoffice memo, September 1980.
[6] ABB Robotics, "The RAPID Language," in the SC4Plus Controller Manual, ABB
Robotics, 2002.
[7] R. Taylor, P. Summers, and J. Meyer, "AML: A Manufacturing Language," International Journal of Robotics Research, Vol. 1, No. 3, Fall 1982.
[8] FANUC Robotics, Inc., "KAREL Language Reference," FANUC Robotics North
America, mc, 2002.
[9] R. Taylor, "A Synthesis of Manipulator Control Programs from Task-Level Specffications," Stanford University Al Memo 282, July 1976.
[101
J.C. LaTombe, "Motion Planning with Uncertainty: On the Preimage Backchaining
Approach," in The Robotics Review, 0. Khatib, J. Craig, and T. Lozano-Perez, Editors,
MIT Press, Cambridge, MA, 1989.
[II] W. Gruver and B. Soroka, "Programming, High Level Languages," in The International Encyclopedia of Robotics, R. Dorf and S. Nof, Editors, Wiley Interscience, New
York, 1988.
[1.2] R. Goldman, Design of an Interactive Manipulator Programming Environment, UIvH
Research Press, Ann Arbor, Ivil, 1985.
[13] Adept Technology, V+ Language Reference, Adept Technology, Livermore, CA,
2002.
[151 Write a robot program (in a language of your choice) to pick a block up from
location A and place it in location B.
12.2 [201 Describe tying your shoelace in simple English commands that might form
the basis of a robot program.
12.3 [32] Design the syntax of a new robot programming language. Include ways to give
duration or speeds to motion trajectories, make I/O statements to peripherals,
give commands to control the gripper, and produce force-sensing (i.e., guarded
move) commands. You can skip force control and parallelism (to be covered in
Exercise 12.4).
12.4 [28] Extend the specification of the new robot programming language that you
started in Exercise 12.3 by adding force-control syntax and syntax for parallelism.
12.5 [38] Write a program in a commercially available robot programming language to
perform the application outlined in Section 12.3. Make any reasonable assumptions concerning I/O connections and other details.
12.6 [28] Using any robot language, write a general routine for unloading an arbitrarily
sized pallet. The routine should keep track of indexing through the pallet and
signal a human operator when the pallet is empty. Assume the parts are unloaded
onto a conveyor belt.
12.7 [35] Using any robot language, write a general routine for unloading an arbitrarily
sized source pallet and loading an arbitrarily sized destination pallet. The routine
should keep track of indexing through the pallets and signal a human operator
when the source pallet is empty and when the destination pallet is full.
12.8 [35] Using any capable robot programming language, write a program that
employs force control to fill a cigarette box with 20 cigarettes. Assume that the
manipulator has an accuracy of about 0.25 inch, so force control should be used
for many operations. The cigarettes are presented on a conveyor belt, and a vision
system returns their coordinates.
12.9 [35] Using any capable robot programming language, write a program to assemble
the hand-held portion of a standard telephone. The six components (handle,
microphone, speaker, two caps, and cord) arrive in a kit, that is, a special pallet
holding one of each kind of part. Assume there is a fixture into which the handle
can be placed that holds it. Make any other reasonable assumptions needed.
12.10 [33] Write a robot program that uses two manipulators. One, called GARM, has
a special end-effector designed to hold a wine bottle. The other arm, BARM, wifi
hold a wineglass and is equipped with a force-sensing wrist that can be used to
signal GARM to stop pouring when it senses the glass is full.
352
PROGRAMMING EXERCISE (PART 12)
Create a user interface to the other programs you have developed by writing a few
subroutines in Pascal. Once these routines are defined, a "user" could write a Pascal
program that contains calls to these routines to perform a 2-D robot application in
simulation.
Define primitives that allow the user to set station and tool frames—namely,
setstation(SrelB:vec3)
settool(TrelW:vec3);
where "SrelB" gives
"TreiW"
the station frame relative to the base frame of the robot and
defines the tool frame relative
to the wrist frame of the manipulator. Define
the motion primitives
moveto(goal:vec3);
moveby(increinent
:vec3);
where "goal" is a specification of the goal
frame relative to the station frame and
"increment" is a specification of a goal frame relative to the current tool frame. Allow
multisegment paths to be described when the user first calls the "pathmode" function,
then specifies motions to via points, and finally says "runpath"—for example,
pathmode;
(* enter path node *)
moveto(goall);
moveto(goal2);
runpath;
Write a simple
arm every
(* execute the path without stopping at goali *)
"application" program, and have your system print the location of the
seconds.
Off-line programming systems
13.1 INTRODUCTION
13.2 CENTRAL ISSUES IN OLP SYSTEMS
13.3 THE 'PILOT' SIMULATOR
13.4 AUTOMATING SUBTASKS IN OLP SYSTEMS
13.1
We define an off-line programming (OLP) system as a robot programming language
that has been sufficiently extended, generally by means of computer graphics, that
the development of robot programs can take place without access to the robot itself.1
Off-line programming systems are important both as aids in programming presentday industrial automation and as platforms for robotics research. Numerous issues
must be considered in the design of such systems. In this chapter, first a discussion
of these issues is presented [1] and then a closer look at one such system [2].
Over the past 20 years, the growth of the industrial robot market has not
been as rapid as once was predicted. One primary reason for this is that robots are
stifi too difficult to use. A great deal of time and expertise is required to install a
robot in a particular application and bring the system to production readiness. For
various reasons, this problem is more severe in some applications than in others;
hence, we see certain application areas (e.g., spot welding and spray painting)
being automated with robots much sooner than other application domains (e.g.,
assembly). It seems that lack of sufficiently trained robot-system implementors is
limiting growth in some, if not all, areas of application. At some manufacturing
companies, management encourages the use of robots to an extent greater than that
realizable by applications engineers. Also, a large percentage of the robots delivered
are being used in ways that do not take full advantage of their capabilities. These
symptoms indicate that current industrial robots are not easy enough to use to allow
successful installation and programming in a timely manner.
There are many factors that make robot programming a difficult task. First,
it is intrinsically related to general computer programming and so shares in many
of the problems encountered in that field; but the progranmiing of robots, or of
any programmable machine, has particular problems that make the development
of production-ready software even more difficult. As we saw in the last chapter,
1Chapter 13 is an edited version of two papers: one reprinted with permission from International
Symposium of Robotics Research, R. Bolles and B. Roth (editors), 1988 (ref liD; the other from Robotics:
The Algorithmic Perspective, P. Agarwal et al. (editors), 1998 (ref [2]).
354
Chapter 13
most of these special problems arise from the fact that a robot manipulator interacts
with its physical environment [3]. Even simple programming systems maintain a
"world model" of this physical enviromnent in the form of locations of objects
and have "knowledge" about presence and absence of various objects encoded
in the program strategies. During the development of a robot program (and
especially later during production use), it is necessary to keep the internal model
maintained by the programming system in correspondence with the actual state
of the robot's environment. Interactive debugging of programs with a manipulator
requires frequent manual resetting of the state of the robot's environment—parts,
tools, and so forth must be moved back to their initial locations. Such state resetting
becomes especially difficult (and sometimes costly) when the robot performs a
irreversible operation on one or more parts (e.g., drilling or routing). The most
spectacular effect of the presence of the physical environment is when a program
bug manifests itself in some unintended irreversible operation on parts, on tools, or
even on the manipulator itself.
Although difficulties exist in maintaining an accurate internal model of the
manipulator's environment, there seems no question that great benefits result from
doing so. Whole areas of sensor research, perhaps most notably computer vision,
focus on developing techniques by which world models can be verified, corrected,
or discovered. Clearly, in order to apply any computational algorithm to the robot
command-generation problem, the algorithm needs access to a model of the robot
and its surroundings.
In the development of programming systems for robots, advances in the
power of programming techniques seem directly tied to the sophistication of the
internal model referenced by the programming language. Early joint-space "teach
by showing" robot systems employed a limited world model, and there were very
limited ways in which the system could aid the programmer in accomplishing a
task. Slightly more sophisticated robot controllers included kinematic models, so
that the system could at least aid the user in moving the joints so as to accomplish
Cartesian motions. Robot programming languages (RPLs) evolved to support many
different data types and operations, which the programmer may use as needed to
model attributes of the environment and compute actions for the robot. Some RPLs
support such world-modeling primitives as afflxments, data types for forces and
moments, and other features [4].
The robot programming languages of today might be called "explicit programming languages," in that every action that the system takes must be programmed
by the application engineer. At the other end of the spectrum are the so-called
task-level-programming (TLP) systems, in which the programmer may state such
high-level goals as "insert the bolt" or perhaps even "build the toaster oven." These
systems use techniques from artificial-inteffigence research to generate motion and
strategy plans automatically. However, task-level languages this sophisticated do
not yet exist; various pieces of such systems are currently under development by
researchers [5]. Task-level-programming systems will require a very complete model
of the robot and its environment to perform automated planning operations.
Although this chapter focuses to some extent on the particular problem of
robot programming, the notion of an OLP system extends to any programmable
device on the factory floor. An argument commonly raised in favor is that an OLP
Section 13.2
Central issues in OLP systems
will not tie up production equipment when it needs to be reprogrammed;
hence, automated factories can stay in production mode a greater percentage of
the time. They also serve as a natural vehicle to tie computer-aided design (CAD)
system
data bases used in the design phase of a product's development to the actual
manufacturing of the product. In some applications, this direct use of CAD design
data can dramatically reduce the programming time required for the manufacturing
machinery.
Off-line progranmiing of robots offers other potential benefits, ones just
beginning to be appreciated by industrial robot users. We have discussed some of
the problems associated with robot programming, and most have to do with the
fact that an external, physical workcell is being manipulated by the robot program.
This makes backing up to try different strategies tedious. Programming of robots in
simulation offers a way of keeping the bulk of the programming work strictly internal
to a computer—until the application is nearly complete. Under this approach, many
of the problems peculiar to robot programming tend to diminish.
Off-line programming systems should serve as the natural growth path from
explicit programming systems to task-level-programming systems. The simplest
OLP system is merely a graphical extension to a robot programming language, but
from there it can be extended into a task-level-programming system. This gradual
extension is accomplished by providing automated solutions to various subtasks (as
these solutions become available) and letting the programmer use them to explore
options in the simulated environment. Until we discover how to build task-level
systems, the user must remain in the loop to evaluate automatically planned subtasks
and guide the development of the application program. If we take this view, an
OLP system serves as an important basis for research and development of tasklevel-planning systems, and, indeed, in support of their work, many researchers have
developed various components of an OLP system (e.g., 3-D models and graphic
display, language postprocessors). Hence, OLP systems should be a useful tool in
research as well as an aid in current industrial practice.
13.2
CENTRAL ISSUES IN OLP SYSTEMS
This section raises many of the issues that must be considered in the design of an
OLP system. The collection of topics discussed will help to set the scope of the
definition of an OLP system.
User interface
A major motivation for developing an OLP system is to create an environment
that makes programming manipulators easier, so the user interface is of crucial
importance. However, another major motivation is to remove reliance on use of
the physical equipment during programming. Upon initial consideration, these two
goals seem to conflict—robots are hard enough to program when you can see them,
so how can it be easier without the presence of physical device? This question
touches upon the essence of the OLP design problem.
Manufacturers of industrial robots have learned that the RPLs they provide
with their robots cannot be utilized successfully by a large percentage of manufacturing personnel. For this and other historical reasons, many industrial robots are
356
provided with a two-level interface [6], one for programmers and one for nonpro-
grammers. Nonprogrammers utilize a teach pendant and interact directly with the
robot to develop robot programs. Programmers write code in the RPL and interact
with the robot in order to teach robot work points and to debug program flow. In
general, these two approaches to program development trade off ease of use against
flexibility.
When viewed as an extension of a RPL, an OLP system by nature contains an
RPL as a subset of its user interface. This RPL should provide features that have
already been discovered to be valuable in robot progranmriing systems. For example,
for use as an RPL, interactive languages are much more productive than compiled
languages, which force the user to go through the "edit—compile—run" cycle for
each program modification.
The language portion of the user interface inherits much from "traditional"
RPLs; it is the lower-level (i.e., easier-to-use) interface that must be carefully
considered in an OLP system. A central component of this interface is a computer-
graphic view of the robot being programmed and of its environment. Using a
pointing device such as a mouse, the user can indicate various locations or objects on
the graphics screen. The design of the user interface addresses exactly how the user
interacts with the screen to specify a robot program. The same pointing device can
indicate items in a "menu" in order to specify modes or invoke various functions.
A central primitive is that for teaching a robot a work point or "frame" that
has six degrees of freedom by means of interaction with the graphics screen. The
availability of 3-D models of fixtures and workpieces in the OLP system often makes
this task quite easy. The interface provides the user with the means to indicate
locations on surfaces, allowing the orientation of the frame to take on a local
surface normal, and then provides methods for offsetting, reorienting, and so on.
Depending on the specifics of the application, such tasks are quite easily specified
via the graphics window into the simulated world.
A well-designed user interface should enable nonprogrammers to accomplish
many applications from start to finish. In addition, frames and motion sequences
"taught" by nonprograrnmers should be able to be translated by the OLP system into
textual RPL statements. These simple programs can be maintained and embellished
in RPL form by more experienced programmers. For programmers, the RPL
availability allows arbitrary code development for more complex applications.
3-D modeling
A central element in OLP systems is the use of graphic depictions of the simulated
robot and its workcell. This requires the robot and all fixtures, parts, and tools in
the workcell to be modeled as three-dimensional objects. To speed up program
development, it is desirable to use any CAD models of parts or tooling that are
directly available from the CAD system on which the original design was done. As
CAD systems become more and more prevalent in industry, it becomes more and
more likely that this kind of geometric data will be readily available. Because of the
strong desire for this kind of CAD integration from design to production, it makes
sense for an OLP system either to contain a CAD modeling subsystem or to be,
itself, a part of a CAD design system. If an OLP system is to be a stand-alone system,
it must have appropriate interfaces to transfer models to and from external CAD
systems; however, even a stand-alone OLP system should have at least a simple
local CAD facility for quickly creating models of noncritical workcell items or for
adding robot-specific data to imported CAD models.
OLP systems generally require multiple representations of spatial shapes. For
many operations, an exact analytic description of the surface or volume is generally
present; yet, in order to benefit from display technology, another representation is
often needed. Current technology is well suited to systems in which the underlying
display primitive is a planar polygon; hence, although an object shape might be
well represented by a smooth surface, practical display (especially for animation)
requires a faceted representation. User-interface graphical actions, such as pointing
to a spot on a surface, should internally act so as to specify a point on the true
surface, even if, graphically, the user sees a depiction of the faceted model.
An important use of the three-dimensional geometry of the object models is
in automatic coffision detection—that is, when any collisions occur between objects
in the simulated environment, the OLP system should automatically warn the user
and indicate exactly where the coffision takes place. Applications such as assembly
may involve many desired "coffisions," so it is necessary to be able to inform the
system that coffisions between certain objects are acceptable. It is also valuable to be
able to generate a coffision warning when objects pass within a specified tolerance
of a true coffision. Currently, the exact collision-detection problem for general 3-D
solids is difficult, but coffision detection for faceted models is quite practical.
Kinematic emulation
A central component in maintaining the validity of the simulated world is the faithful
emulation of the geometrical aspects of each simulated manipulator. With regard
to inverse kinematics, the OLP system can interface to the robot controller in two
distinct ways. First, the OLP system could replace the inverse kinematics of the
robot controller and always communicate robot positions in mechanism joint space.
The second choice is to communicate Cartesian locations to the robot controller and
let the controller use the inverse kinematics supplied by the manufacturer to solve
for robot configurations. The second choice is almost always preferable, especially as
manufacturers begin to build arm signature style calibration into their robots. These
calibration techniques customize the inverse kinematics for each individual robot.
In this case, it becomes desirable to communicate information at the Cartesian level
to robot controllers.
These considerations generally mean that the forward and inverse kinematic
functions used by the simulator must reflect the nominal functions used in the robot
controller supplied by the manufacturer of the robot. There are several details of
the inverse-kinematic function specified by the manufacturer that must be emulated
by the simulator software. Any inverse-kinematic algorithm must make arbitrary
choices in order to resolve singularities. For example, when joint 5 of a PUMA
560 robot is at its zero location, axes 4 and 6 line up, and a singular condition
exists. The inverse-kinematic function in the robot controller can solve for the sum
of joint angles 4 and 6, but then must use an arbitrary rule to choose individual
values for joints 4 and 6. The OLP system must emulate whatever algorithm is
used. Choosing the nearest solution when many alternate solutions exist provides
another example. The simulator must use the same algorithm as the controller in
358
order to avoid potentially catastrophic errors in simulating the actual manipulator.
A helpful feature occasionally found in robot controllers is the ability to command
a Cartesian goal and specify which of the possible solutions the manipulator should
use. The existence of this feature eliminates the requirement that the simulator
emulate the solution-choice algorithm; the OLP system can simpiy force its choice
on the controller.
Path-planning emulation
In addition to kinematic emulation for static positioning of the manipulator, an
OLP system should accurately emulate the path taken by the manipulator in moving
through space. Again, the central problem is that the OLP system needs to simulate
the algorithms in the employed robot controller, and such path-planning and
-execution algorithms vary considerably from one robot manufacturer to another.
Simulation of the spatial shape of the path taken is important for detection of
collisions between the robot and its environment. Simulation of the temporal
aspects of the trajectory are important for predicting the cycle times of applications.
When a robot is operating in a moving environment (e.g., near another robot),
accurate simulation of the temporal attributes of motion is necessary to predict
coffisions accurately and, in some cases, to predict communication or synchronization
problems, such as deadlock.
Dynamic emulation
Simulated motion of manipulators can neglect dynamic attributes if the OLP system
does a good job of emulating the trajectory-planning algorithm of the controller
and if the actual robot follows desired trajectories with negligible errors. However,
at high speed or under heavy loading conditions, trajectory-tracking errors can
become important. Simulation of these tracking errors necessitates both modeling
the dynamics of the manipulator and of the objects that it moves and emulating the
control algorithm used in the manipulator controller. Currently, practical problems
exist in obtaining sufficient information from the robot vendors to make this kind of
dynamic simulation of practical value, but, in some cases, dynamic simulation can
be pursued fruitfully.
Multiprocess simulation
Some industrial applications involve two or more robots cooperating in the same
environment. Even single-robot workcells often contain a conveyor belt, a transfer
line, a vision system, or some other active device with which the robot must interact.
For this reason, it is important that an OLP system be able to simulate multiple
moving devices and other activities that involve parallelism. As a basis for this
capability, the underlying language in which the system is implemented should
be a multiprocessing language. Such an environment makes it possible to write
independent robot-control programs for each of two or more robots in a single cell
and then simulate the action of the cell with the programs running concurrently.
Adding signal and wait primitives to the language enables the robots to interact with
each other just as they might in the application being simulated.
Simulation of sensors
Studies
have shown that a large component of robot programs consists not of
motion statements, but rather of initialization, error-checking, I/O, and other kinds
of statements [7]. Hence, the ability of the OLP system to provide an environment that allows simulation of complete applications, including interaction with
sensors, various I/O, and communication with other devices, becomes important.
An OLP system that supports simulation of sensors and multiprocessing not only
can check robot motions for feasibility, but also can verify the communication and
synchronization portion of the robot program.
Language translation to target system
An annoyance for current users of industrial robots (and of other programmable
automation) is that almost every supplier of such systems has invented a unique
language for programming its product. If an OLP system aspires to be universal in
the equipment it can handle, it must deal with the problem of translating to and from
several different languages. One choice for dealing with this problem is to choose
a single language to be used by the OLP system and then postprocess the language
in order to convert it into the format required by the target machine. An ability to
upload programs that already exist on the target machines and bring them into the
OLP system is also desirable.
Two potential benefits of OLP systems relate directly to the languagetranslation topic. Most proponents of OLP systems note that having a single,
universal interface, one that enables users to program a variety of robots, solves
the problem of learning and dealing with several automation languages. A second
benefit stems from economic considerations in future scenarios in which hundreds or
perhaps thousands of robots ifil factories. The cost associated with a powerful programming environment (such as a language and graphical interface) might prohibit
placing it at the site of each robot installation. Rather, it seems to make economic
sense to place a very simple, "dumb," and cheap controller with each robot and have
it downloaded from a powerful, "inteffigent" OLP system that is located in an office
environment. Hence, the general problem of translating an application program
from a powerful universal language to a simple language designed to execute in a
cheap processor becomes an important issue in OLP systems.
Workcell calibration
An inevitable reality of a computer model of any real-world situation is that of
inaccuracy in the model. In order to make programs developed on an OLP system
usable, methods for workcell calibration must be an integral part of the system.
The magnitude of this problem varies greatly with the application; this variability
makes off-line programming of some tasks much more feasible that of others. If
the majority of the robot work points for an application must be retaught with the
actual robot to solve inaccuracy problems, OLP systems lose their effectiveness.
Many applications involve the frequent performance of actions relative to a
rigid object. Consider, for example, the task of drilling several hundred holes in a
bulkhead. The actual location of the bulkhead relative to the robot can be taught by
using the actual robot to take three measurements. From those• data, the locations
360
of all the holes can be updated automatically if they are available in part coordinates
from a CAD system. In this situation, only these three points need be taught with
the robot, rather than hundreds. Most tasks involve this sort of "many operations
relative to a rigid object" paradigm—for example, PC-board component insertion,
routing, spot welding, arc welding, palletizing, painting, and deburring.
13.3
THE 'PILOT' SIMULATOR
In this section, we consider one such off-line simulator system: the 'Pilot' system
developed by Adept Technology [8]. The Pilot system is actually a suite of three
closely related simulation systems; here, we look at the portion of Pilot (known
as "Pilot/Cell") that is used to simulate an individual workcell in a factory. In
particular, this system is unusual in that it attempts to model several aspects of the
physical world, as a means of unburdening the programmer of the simulator. In this
section, we will discuss the "geometric algorithms" that are used to empower the
simulator to emulate certain aspects of physical reality.
The need for ease of use drives the need for the simulation system to behave
like the actual physical world. The more the simulator acts like the real world,
the simpler the user-interface paradigm becomes for the user, because the physical
world is the one we are all familiar with. At the same time, trade-offs of ease against
computational speed and other factors have driven a design in which a particular
"slice" of reality is simulated while many details are not.
Pilot is well-suited as a host for a variety of geometric algorithms. The need
to model various portions of the real world, together with the need to unburden
the user by automating frequent geometric computations, drives the need for such
algorithms. Pilot provides the environment in which some advanced algorithms can
be brought to bear on real problems occurring in industry.
One decision made very early on in the design of the Pilot simulation system
was that the programming paradigm should be as close as possible to the way
the actual robot system would be programmed. Certain higher level planning and
optimization tools are provided, but it was deemed important to have the basic
programming interaction be similar to actual hardware systems. This decision has
led the product's development down a path along which we find a genuine need for
various geometric algorithms. The algorithms needed range widely from extremely
simple to quite complex.
If a simulator is to be programmed as the physical system would be, then the
actions and reactions of the physical world must be modeled "automatically" by
the simulator. The goal is to free the user of the system from having to write any
"simulation-specific code." As a simple example, if the robot gripper is commanded
to open, a grasped part should fall in response to gravity and possibly should even
bounce and settle into a certain stable state. Forcing the user of the system to
specify these real-world actions would make the simulator fall short of its goal:
being programmed just as the actual system is. Ultimate ease of use can be achieved
only when the simulated world "knows how" to behave like the real world without
burdening the user.
Most, if not all, commercial systems for simulating robots or other mechanisms
do not attempt to deal directly with this problem. Rather, they typically "allow" the
user (actually, force the user) to embed simulation-specific commands within the
Section 13.3
The 'Pilot' simulator
program written to control the simulated device. A simple example would be the
following code sequence:
MOVE TO pick_part
CLOSE gripper
affix (gripper,part [ii);
MOVE TO place_part
OPEN gripper
unaffix(gripper,part [i]);
Here, the user has been forced to insert "affix" and "unaflix" commands, which
(respectively) cause the part to move with the gripper when grasped and to stop
moving with it when released. If the simulator allows the robot to be programmed
in its native language, generally that language is not rich enough to support these
required "simulation-specific" commands. Hence, there is a need for a second set of
commands, possibly even with a different syntax, for dealing with interactions with
the real world. Such a scheme is inherently not programmed "just as the physical
system is" and must inherently cause an increased programming burden for the
user.
From the preceding example, we see the first geometric algorithm that one
finds a need for: From the geometry of the gripper and the relative placements of
parts, figure out which part (if any) wifi be grasped when the gripper closes and
possibly how the part will self-align within the gripper. In the case of Pilot, we solve
the first part of this problem with a simple algorithm. In limited cases, the "alignment
action" of the part in the gripper is computed, but, in general, such alignments need
to be pretaught by the system's user. Hence, Pilot has not reached the ultimate goal
yet, but has taken some steps in that direction.
Physical Modeling and Interactive Systems
In a simulation system, one always trades off complexity of the model in terms
of computation time against accuracy of the simulation. In the case of Pilot and
its intended goals, it is particularly important to keep the system fully interactive.
This has led to designing Pilot so that it can use various approximate models—for
example, the use of quasi-static approximations where a full dynamic model might
be more accurate. Although there appears to be a possibility that "full dynamic"
models might soon be applicable [9], given the current state of computer hardware,
of dynamic algorithms, and of the complexity of the CAD models that industrial
users wish to employ, we feel these trade-offs still need to be made.
Geometric Algorithms for Part Tumbling
In some feeding systems employed in industrial practice, parts tumble from some
form of infeed conveyor onto a presentation surface; then computer vision is used
to locate parts to be acquired by the robot. Designing such automation systems with
the aid of a simulator means that the simulator must be able to predict how parts
fall, bounce, and take on a stable orientation, or stable state.
362
FIGURE 13.1:
The eight stable states of the part.
Stable-state probabilities
As reported in [10], an algorithm has been implemented that takes as input any
geometric shape (represented by a CAD model) and, for that shape, can compute
the N possible ways that it can rest stably on a horizontal surface. These are called
the stable states of the part. Further, the algorithm uses a perturbed quasi-static
approach to estimate the probability associated with each of the N stable states.
We have performed physical experiments with sample parts in order to assess the
resulting accuracy of stable-state prediction.
Figure 13.1 shows the eight stable states of a particular test part. Using an
Adept robot and vision system, we dropped this part more than 26,000 times and
recorded the resulting stable state, in order to compare our stable-state prediction
algorithm to reality. Table 13.1 shows the results for the test part. These results
are characteristic of our current algorithm—stable-state likelihood prediction error
typically ranges from 5% to 10%.
Adjusting probabilities as a function of drop height
Clearly, if a part is dropped from a gripper from a very small height (e.g., 1 mm)
above a surface, the probabilities of the various stable states differ from those which
occur when the part is dropped from higher than some critical height. In Pilot, we
use probabilities from the stable-state estimator algorithm when parts are dropped
from heights equal to or greater than the largest dimension of the part. For drop
Predicted versus Actual Stable-State
Probabilities for the Test Part
TABLE 13.1:
Stable State
AR/AL
Total
Actual #
% Actual
% Predicted
1871
10,600
7.03%
39.80%
2.43%
0.12%
24.28%
24.72%
1.61%
8.91%
44.29%
7.42%
8.19%
15.90%
15.29%
0.00%
6467
6583
26,630
100%
heights below that value, probabilities are adjusted to take into account the initial
orientation of the part and the height of the drop. The adjustment is such that, as
an infinitesimal drop height is approached, the part remains in its initial orientation
(assuming it is a stable orientation). This is an important addition to the overall
probability algorithm, because it is typical for parts to be released a small distance
above a support surface.
Simulation of bounce
Parts in Pilot are tagged with their coefficient of restitution; so are all surfaces
on which parts may be placed. The product of these two factors is used in a
formula for predicting how far the part wifi bounce when dropped. These details
are important, because they affect how parts scatter or clump in the simulation of
some feeding systems. When bouncing, parts are scattered radially according to a
uniform distribution. The distance of bounce (away from the initial contact point) is
a certain distribution function out to a maximum distance, which is computed as a
function of drop height (energy input) and the coefficients of restitution that apply.
Parts in Pilot can bounce recursively from surface to surface in certain
arrangements. It is also possible to mark certain surfaces such that parts are not able
to bounce off them, but can only bounce within them. Entities known as bins in Pilot
have this property —parts can fall into them, but never bounce out.
Simulation of stacking and tangling
As a simplification, parts in Pilot always rest on planar support surfaces. If parts are
tangled or stacked on one another, this is displayed as parts that are intersecting
each other (that is, the boolean intersection of their volumes would be non-empty).
This saves the enormous amount of computation that would be needed to compute
the various ways a part might be stacked or tangled with another part's geometry.
Parts in Pilot are tagged with a tangle factor. For example, something like a
marble would have a tangle factor of 0.0 because, when tumbled onto a support
surface, marbles tend never to stack or tangle, but rather tend to spread out on the
364
On the other hand, parts like coiled springs might have a tangle factor near
1.0; they quite readily become entangled with one another. When a part falls and
bounces, afindspace algorithm runs, in which the part tries to bounce into an open
space on the surface. However, exactly "how hard it tries" to find an open space is a
surface.
function of its tangle factor. By adjustment of this coefficient, Pilot can simulate parts
that tumble and become entangled more or less. Currently, there is no algorithm
for automatically computing the tangle factor from the part geometry—this is an
interesting open problem. Through the user interface, the Pilot user can set the
tangle factor to what seems appropriate.
Geometric Algorithms for Part Grasping
Much of the difficulty in programming and using actual robots has to do with the
details of teaching grasp locations on parts and with the detailed design of grippers.
This is an area in which additional planning algorithms in a simulator system could
have a large impact. In this section, we discuss the algorithms currently in place in
Pilot. The current approaches are quite simple, so this is an area of ongoing work.
Computing which part to grasp
When a tool closes, or a suction end-effector actuates, Pilot applies a simple
algorithm to compute which part (if any) should become grasped by the robot. First,
the system figures out which support surface is immediately beneath the gripper.
Then, for all parts on that surface, it searches for each whose bounding box (for the
current stable state) contains the TCP (tool center point) of the gripper. If more than
one part satisfies this criterion, then it chooses the nearest among those which do.
Computation of default grasp location
Pilot automatically assigns a grasp location for each stable orientation predicted by
the stable-state estimator previously described. The current algorithm is simplistic,
so a graphical user interface is also provided so that the user can edit and redefine
these grasp points. The current grasp algorithm is a function of the part's bounding
box and the geometry of the gripper, which is assumed to be either a paralleljaw gripper or a suction cup. Along with computing a default grasp location for
each stable state, a default approach and depart height are also automatically
computed.
Computation of alignment of the part during grasp
In some important cases in industrial practice, the system designer counts on the
fact that, when the robot end-effector actuates, the captured part wifi align itself in
some way with surfaces of the end-effector. This effect can be important in removing
small misalignments in the presentation of parts to the robot.
A very real effect which needs to be simulated is that, with suction cup grippers,
it can be the case that, when suction is applied, the part is "lifted" up against the
suction cup in a way which significantly alters its orientation relative to the endeffector. Pilot simulates this effect by piercing the part geometry with a vertical line
aligned with the center line of the suction cup. Whichever facet of the polygonal
part model is pierced is used in computing the orientation at grasp—the normal of
this facet becomes anti-aligned with the normal of the bottom of the suction cup. In
altering the part orientation, rotation about this piercing line is minimized (the part
does not spin about the axis of the suction cup when picked). Without simulation of
this effect, the simulator would be unable to depict realistically some pick-and-place
strategies employing suction grippers.
We have also implemented a planner that allows parts to rotate about the Z
axis when a parallel jaw gripper closes on them. This case is automatic only for a
simple case—in other situations, the user must teach the resulting alignment (i.e.,
we are still waiting for a more nearly complete algorithm).
Geometric Algorithms for Part Pushing
One style of part pushing occurs between the jaws of a gripper, as mentioned in
the previous section. In current industrial practice, parts sometimes get pushed by
simple mechanisms. For example, after a part is presented by a bowl feeder, it might
be pushed by a linear actuator right into an assembly that has been brought into the
cell by a tray-conveyor system.
Pilot has support for simulating the pushing of parts: an entity called a pushbar, which can be attached to a pneumatic cylinder or a leadscrew actuator in the
simulator. When the actuator moves the push-bar along a linear path, the leading
surface of the push-bar wifi move parts. In the future, it is planned, push-bars will
also be able to be added as guides along conveyors or placed anywhere that requires
that parts motion be affected by their presence. The current pushing is still very
simple, but it suffices for many real-world tasks.
Geometric Algorithms for Tray Conveyors
Pilot supports the simulation of tray-conveyor systems in which trays move along
tracks composed of straight-line and circular-section components. Placed along the
tracks at key locations can be gates, which pop up temporarily to block a tray when
so commanded. Additionally, sensors that detect a passing tray can be placed in
the track at user-specified locations. Such conveyor systems are typical in many
automation schemes.
Connecting tray conveyors and sources and sinks
Tray conveyors can be connected together to allow various styles of branching.
Where two conveyors "flow together," a simple collision-avoidance scheme is
provided to cause trays from the spur conveyor to be subordinate to trays on the
main conveyor. Trays on the spur conveyor wifi wait whenever a coffision would
occur. At "flow apart" connections, a device called a director is added to the main
conveyor, which can be used to control which direction a tray wifi take at the
intersection. Digital I/O lines connected to the simulated robot controller are used
to read sensors, activate gates, and activate directors.
At the ends of a tray conveyor are a source and a sink. Sources are set up by
the user to generate trays at certain statistical intervals. The trays generated could
either be empty or be preloaded with parts or fixtures. At the end of a tray conveyor,
trays (and their contents) disappear into sinks. Each time a tray enters a sink, its
arrival time and contents are recorded. These so-called sink records can then be
366
replayed through a source elsewhere in the system. Hence, a line of cells can be
studied in the simulator one cell at a time, by setting the source of cell N + 1 to the
sink record from cell N.
Pushing of trays
Pushing is also implemented for trays: A push-bar can be used to push a tray off a
tray conveyor system and into a particular work cell. Likewise, trays can be pushed
onto a tray conveyor. The updating of various data structures when trays come off a
conveyor or onto one is an automatic part of the pushing code.
Geometric Algorithms for Sensors
Simulation of various sensor systems is required, so that the user wifi not be burdened
with the writing of code to emulate their behavior in the cell.
Proximity sensors
Pilot supports the simulation of proximity sensors and other sensors. In the case of
proximity sensors, the user tags the device with its minimum and maximum range
and with a threshold. If an object is within range and closer than the threshold,
then the sensor wifi detect it. To perform this computation in the simulated world,
a line segment is temporarily added to the world, one that stretches from minimum
to maximum sensor range. Using a coffision algorithm, the system computes the
locations at which this line segment intersects other CAD geometry. The intersection
point nearest the sensor corresponds to the real-world item that would have stopped
the beam. A comparison of the distance to this point and the threshold gives the
output of the sensor. At present, we do not make use of the angle of the encountered
surface or of its reflectance properties, although those features might be added in
the future.
2-D vision systems
Pilot simulates the performance of the Adept 2-D vision system. The way the
simulated vision system works is closely related to the way the real vision system
works, even to how it is programmed in the AIM language [11] used by Adept
robots. The following elements of this vision system are simulated:
• The shape and extent of the field of view.
• The stand-off distance and a simple model of focus.
• The time required to perform vision processing (approximate).
• The spatial ordering of results in the queue in the case of many parts being
found in one image.
• The ability to distinguish parts according to which stable state they are in.
• The inability to recognize parts that are touching or overlapping.
• Within the context of AIM, the ability to update robot goals based on vision
results.
Section 13.4
Automating subtasks in OLP systems
The use of a vision system is well integrated with the AIM robot programming
system, so implementation of the AIM language in the simulator implies implementation of vision system emulation. AIM supports several constructs that make the
use of vision easy for robot guidance. Picking parts that are identified visually from
both indexing and tracking conveyors is easily accomplished.
A data structure keeps track of which support surface the vision system is
looking at. For all parts supported on that surface, we compute which are within the
vision system's field of view. We prune out any parts that are too near or too far from
the camera (e.g., out of focus). We prune out any parts that are touching neighboring
parts. From the remaining parts, we choose those which are in the sought-after stable
state and put them in a list. Finally, this list is sorted to emulate the ordering the
Adept vision system uses when multiple parts are found in one scene.
Inspector sensors
A special class of sensor is provided, called an inspector. The inspector is used to
give a binary output for each part placed in front of it. Parts in Pilot can be tagged
with a defect rate, and inspectors can ferret out the defective parts. Inspectors play
the role of several real-world sensor systems.
Conclusion
As is mentioned throughout this section, although some simple geometric algorithms
are currently in place in the simulator, there is a need for more and better
algorithms. In particular, we would like to investigate the possibility of adding a
quasi-static simulation capability for predicting the motion of objects in situations
in which friction effects dominate any inertial effects. This could be used to simulate
parts being pushed or tipped by various actions of end-effectors or other pushing
mechanisms.
13.4
AUTOMATING SUBTASKS IN OLP SYSTEMS
In this section, we briefly mention some advanced features that could be integrated
into the "baseline" OLP-system concept already presented. Most of these features
accomplish automated planning of some small portion of an industrial application.
Automatic robot placement
One of the most basic tasks that can be accomplished by means of an OLP system
is the determination of the workcell layout so that the manipulator(s) can reach all
of the required workpoints. Determining correct robot or workpiece placement by
trial and error is more quickly completed in a simulated world than in the physical
cell. An advanced feature that automates the search for feasible robot or workpiece
location(s) goes one step further in reducing burden on the user.
Automatic placement can be computed by direct search or (sometimes) by
heuristic-guided search techniques. Most robots are mounted flat on the floor (or
ceiling) and have the first rotary joint perpendicular to the floor, so no more is
generally necessary than to search by tessellation of the three-dimensional space
of robot-base placement. The search might optimize some criterion or might halt
upon location of the first feasible robot or part placement.. Feasibility can be
368
defined as coffision-free ability to reach all workpoints (or perhaps be given an even
stronger definition). A reasonable criterion to maximize might be some form of a
measure of manipulability, as was discussed in Chapter 8. An implementation using
a similar measure of manipulability has been discussed in [12]. The result of such an
automatic placement is a cell in which the robot can reach all of its workpoints in
well-conditioned configurations.
Collision avoidance and path optimization
Research on the planning of coffision-free paths [13,14] and the planning of time-
optimal paths [15,16] generates natural candidates for inclusion in an OLP system.
Some related problems that have a smaller scope and a smaller search space are
also of interest. For example, consider the problem of using a six-degree-of-freedom
robot for an arc-welding task whose geometry specifies only five degrees of freedom.
Automatic planning of the redundant degree of freedom can be used to avoid
collisions and singularities of the robot [17].
Automatic planning of coordinated motion
In many arc-welding situations, details of the process require that a certain relationship between the workpiece and the gravity vector be maintained during the weld.
This results in a two- or three-degree-of-freedom-orienting system on which the part
is mounted, operating simultaneously with the robot and in a coordinated fashion. In
such a system, there could be nine or more degrees of freedom to coordinate. Such
systems are generally programmed today by using teaching-pendant techniques. A
planning system that could automatically synthesize the coordinated motions for
such a system might be quite valuable [17,18].
Force-control simulation
In a simulated world in which objects are represented by their surfaces, it is possible to
investigate the simulation of manipulator force-control strategies. This task involves
the difficult problem of modeling some surface properties and expanding the dynamic
simulator to deal with the constraints imposed by various contacting situations. In
such an environment, it might be possible to assess various force-controlled assembly
operations for feasibility [19].
Automatic scheduling
Along with the geometric problems found in robot progranuning, there are often
difficult scheduling and communication problems. This is particularly the case if
we expand the simulation beyond a single workcell to a group of workcells. Some
discrete-time simulation systems offer abstract simulation of such systems [20], but
few offer planning algorithms. Planning schedules for interacting processes is a
difficult problem and an area of research [21,22]. An OLP system would serve as an
ideal test bed for such research and would be immediately enhanced by any useful
algorithms in this area.
Automatic assessment of errors and tolerances
An OLP system might be given some of the capabilities discussed in recent work
in modeling positioning-error sources and the effect of data from imperfect sensors
[23,24]. The world model could be made to include various error bounds and
tolerancing information, and the system could assess the likelihood of success
of various positioning or assembly tasks. The system might suggest the use and
placement of sensors so as to correct potential problems.
Off-line programming systems are useful in present-day industrial applications
and can serve as a basis for continuing robotics research and development. A large
motivation in developing OLP systems is to fill the gap between the explicitly
programmed systems available today and the task-level systems of tomorrow.
[1] J. Craig, "Issues in the Design of Off-Line Programming Systems," International
Symposium of Robotics Research, R. Bolles and B. Roth, Eds., MIT Press, Cambridge,
[2] J. Craig, "Geometric Algorithms in AdeptRAP1D," Robotics: The Algorithmic Perspective: 1998 WAFR, P. Agarwal, L. Kavraki, and M. Mason, Eds., AK Peters, Natick,
MA, 1998.
[3] R. Goldman, Design of an Interactive Manipulator Programming Environment, UMI
[4] S. Mujtaba and R. Goldman, "AL User's Manual," 3rd edition, Stanford Department
[5] T. Lozano-Perez, "Spatial Planning: A Configuration Space Approach," IEEE Transactions on Systems, Man, and cybernetics, Vol. SMC-11, 1983.
[6] B. Shimano, C. Geschke, and C. Spalding, "VAL - II: A Robot Programming Language and Control System," SME Robots VIII Conference, Detroit, June 1984.
[7j R. Taylor, P. Summers, and J. Meyer, "AML: A Manufacturing Language," International Journal of Robotics Research, Vol. 1, No. 3, Fall 1982.
[8] Adept Technology Inc., "The Pilot User's Manual," Available from Adept Technology
Inc., Livermore, CA, 2001.
[9] B. Mirtich and J. Canny, "Impulse Based Dynamic Simulation of Rigid Bodies,"
Symposium on Interactive 3D Graphics, ACM Press, New York, 1995.
[10] B. Mirtich, Y. Zhuang, K. Goldberg, et al., "Estimating Pose Statistics for Robotic
Part Feeders," Proceedings of the IEEE Robotics and Automation Conference,
Minneapolis, April, 1996.
[II] Adept Technology Inc., "AIM Manual," Available from Adept Technology Inc., San
Jose, CA, 2002.
[12] B. Nelson,K. Pedersen,andM. Donath, "LocatingAssemblyTasksinaManipulator's
Workspace," IEEE Conference on Robotics and Automation, Raleigh, NC, April
1987.
[13] plus 1.67pt minus 1.llpt T. Lozano-Perez, "A Simple Motion Planning Algorithm for
General Robot Manipulators," IEEE Journal of Robotics andAutoniation, Vol. RA-3,
No. 3, June 1987.
370
[14] R. Brooks, "Solving the Find-Path Problem by Good Representation of Free Space,"
IEEE Transaction on Systems, Man, and cybernetics, SMC-13:190—197, 1983.
[15] J. Bobrow, S. Dubowsky, and J. Gibson, "On the Optimal Control of Robotic Manipulators with Actuator Constraints," Proceedings of the Amen can Control Conference,
[16] K. Shin and N. McKay, "Minimum-Time Control of Robotic Manipulators with Geometric Path Constraints," IEEE Transactions on Automatic Control, June 1985.
[17] J.J. Craig, "Coordinated Motion of Industrial Robots and 2-DOF Orienting Tables,"
Proceedings of the 17th International Symposium on Industrial Robots, Chicago,
April 1987.
[18] S. Ahmad and S. Luo, "Coordinated Motion Control of Multiple Robotic Devices
for Welding and Redundancy Coordination through Constrained Optimization in
Cartesian Space," Proceedings of the IEEE Conference on Robotics and Automation,
Philadelphia, 1988.
[19] M. Peshkin and A. Sanderson, "Planning Robotic Manipulation Strategies for Sliding
Objects," IEEE Conference on Robotics and Automation, Raleigh, NC, April 1987.
[201 E. Russel, "Building Simulation Models with Simcript 11.5," C.A.C.I., Los Angeles,
1983.
[21] A. Kusiak and A. Vifia, "Architectures of Expert Systems for Scheduling Flexible
Manufacturing Systems," IEEE Conference on Robotics and Automation, Raleigh,
NC, April 1987.
[22] R. Akella and B. Krogh, "Hierarchical Control Structures for Multicell Flexible
Assembly System Coordination," IEEE Conference on Robotics and Automation,
Raleigh, NC, April 1987.
[23] R. Smith, M. Self, and P. Cheeseman, "Estimating Uncertain Spatial Relationships in
Robotics," IEEE Conference on Robotics and Automation, Raleigh, NC, April 1987.
[24] H. Durrant-Whyte, "Uncertain Geometry in Robotics," IEEE Conference on
Robotics and Automation, Raleigh, NC, April 1987.
[10] In a sentence or two, define collision detection, collision avoidance, and
coffision-free path planning.
13.2 [10] In a sentence or two, define world model, path planning emulation, and
dynamic emulation.
13.3 [10] In a sentence or two, define automatic robot placement, time-optimal paths,
and error-propagation analysis.
13.4 [10] In a sentence or two, define RPL, TLP, and OLP.
13.5 [10] In a sentence or two, define calibration, coordinated motion, and automatic
scheduling.
13.6 [20] Make a chart indicating how the graphic ability of computers has increased
over the past ten years (perhaps in terms of the number of vectors drawn per
second per $10,000 of hardware).
13.7 [20] Make a list of tasks that are characterized by "many operations relative to a
rigid object" and so are candidates for off-line programming.
13.8 [20] Discuss the advantages and disadvantages of using a programming system
that maintains a detailed world model internally.
Programming exercise (Part 13)
PROGRAMMING EXERCISE (PART 13)
Consider the planar shape of a bar with semicircular end caps. We wifi call this
shape a "capsule." Write a routine that, given the location of two such capsules,
computes whether they are touching. Note that all surface points of a capsule are
equidistant from a single line segment that might be called its "spine."
2. Introduce a capsule-shaped object near your simulated manipulator and test for
collisions as you move the manipulator along a path. Use capsule-shaped links for
the manipulator. Report any collisions detected.
3. If time and computer facffities permit, write routines to depict graphically the
capsules that make up your manipulator and the obstacles in the workspace.
APPENDIX A
Trigonometric identities
Formulas for rotation about the principal axes by 0:
(A.1)
(A.2)
0 sin0 1
cos0
LU sin0
cos0 —sin0
L—sino
rcoso —sin0 01
(A.3)
Identities having to do with the periodic nature of sine and cosine:
sin0 =
— sin(—0)
= — cos(0 + 90°) =
cos0 = cos(—0) = sin(0 + 90°) =
cos(0
— sin(0 —90°).
The sine and cosine for the sum or difference of angles
cos(01 + 02) =
sin(01
cos(01
90°),
and 02:
c1c2 —
= c1s2 + s1c2,
+ 02) =
(A.4)
(A.5)
= c1c2 + s1s2,
sin(01 — 02)
s1c2 — c1s2.
The sum of the squares of the sine and cosine of the same angle is unity:
c20 + s20 =
(A.6)
If a triangle's angles are labeled a, b, and c, where angle a is opposite side A,
and so on, then the "law of cosines" is
(A.7)
A2 = B2 + C2 — 2BCcosa.
The "tangent of the half angle" substitution:
sm0=
1 +u2
(A.8)
Appendix A
To rotate a vector Q about a unit vector K by 9, use Rothiques's formula:
Q' = Q cos9 + sin9(K x Q) + (1— cos9)(k. Q)K.
(A.9)
See Appendix B for equivalent rotation matrices for the 24 angle-set conventions and Appendix C for some inverse-kinematic identities.
APPENDIX
The 24 angIe-set conventions
The 12 Euler angle sets are given by
Rxiy,z,(a,
Rx,z,yt(a,
sas$cy + casy
+ cacy —sacj3
+ sasy cac,8 cas,Bsy
sac,3 sasj9sy+cacy
cas,Bcy+sasy cac/9
—sasj3sy+cacy
[—sac,8
Rz,xiyi(a,
cas,8sy
+ sasy
+ sacy
c$cy
[cac$ ca!s,8sy—sacy
Rz,y,xt(a,
Rx,zix,(a,
SaS,8
Rxiy,x,(a,
sac$
—SaCI3Sy + cacy —sac,Bcy — casy
cac/3sy+sac)'
sasy —cac,Bsy — sacy
sacficy+casy —sac,8sy+cacy
[—sacfisy+cacy sasfi sac,8cy+casy
L sas,8
Ry,x,y,(a, $, y) =
L—cac$sy—sacy casfi cac,8cy—sasy
Appendix B
Ry,ziy,(a,
The 24 angle-set conventions
—sac18sy+cacy
sas$
—sac,Bcy—casy
— sasy
cac,Bsy
Rz,y,z,(a,
+ casy —sac$sy + cacy sas$
sac,Bcy
s$sy
The 12 fixed angle sets are given by
Rxyz(y,$,a)
sas,Bcy—casy
Rxzy(y,
Ryxz(y,
a) =
Rzxy(y,
—cas$cy+sasy
—c$sy
—sas,Bsy+cacy
[—sas,8sy+cacy —sac,B sasflcy+casy
casj3sy + sacy
cac18
cas$cy+sasy cac,8 cas,8sy—sacy
[sas$cy—casy sac,8
Ryzx(y,13,a)
L —s$
r sas,8sy+cacy sas,8cy—casy
Rzyx(y, $, a) =
cas,8cy+sasy
c18c)/
+ cacy —sac,8
[—cas,8cy-j-sasy cas$sy+sacy
Rxyx(y,
+ cacy —sac,8cy — casy
sas,8
L—cas$ cac,8sy+sacy
Rxzx(y,
cac,8cy—sasy
cas,8
sasy —cacfisy
sac,8cy+casy —sacfisy+cacy
sas,8 sacficy+casy
Ryxy(y,
—sficy
L —cac,8sy
sacy cask cac,Bcy — sasy
376
Appendix B
Ryzy()i,$,a)
sasfi
cacj5sy
cac,Bcy — sasy
—cas18
r cac,Bcy—sasy
Rzyz(y,
+ casy —sac,8sy + cacy
APPENDIX
Some inverse-kinematic
formulas
The single equation
sin9=a
(C.1)
has two solutions, given by
8 = ±Atan2(-./1
(C.2)
Likewise, given
(C.3)
there are two solutions:
= Atan2(b,
b2).
(C.4)
If both (C.1) and (C.3) are given, then there is a unique solution given by
9 = Atan2(a, b).
(C.5)
acos9+bsin9=O
(C.6)
The transcendental equation
has the two solutions
9 = Atan2(a,
(C.7)
9 = Atan2(—a, b).
(C.8)
acos9+bsin0 =c,
(C.9)
The equation
which we solved in Section 4.5 with the tangent-of-the-half-angle substitutions, is
also solved by
9 = Atan2(b, a) ± Atan2(i/a2 + b2 — c2, c).
(C.1O)
The set of equations
acos8—bsin0 =c,
asin9+bcos9=d,
(C.11)
which was solved in Section 4.4, also is solved by
8 = Atan2(ad
ac + bd).
(C.12)
Solutions to selected exercises
CHAPTER 2
SPATIAL DESCRIPTIONS AND TRANSFORMATIONS EXERCISES
2.1)
R = ROT(1,
0 1[co
0 Cq5
Cq5CO —Sçb
sç/c0
2.12) Velocity is a "free vector" and wifi be affected only by rotation, not by
translation:
AVARBV
0.866 0
0 1 r 10
—0.5
1][3o
[—1.34 22.32 30.0
2.27)
0—100
2.33)
—0.866 —0.5
CHAPTER 3
MANIPULATOR KINEMATICS EXERCISES
3.1)
380
0 L1
C3 —S3 0 L2
C123 =
+ 02 + 03)
=sm(01 +02+03)
3.8) When {G} = {T}, we have
T1 BT 5T
4.14) No. Pieper's method gives the closed-form solution for any 3-DOF manipula-
tor. (See his thesis for all the cases.)
4.18) 2
4.22) 1
CHAPTER 5
JACOBIANS: VELOCITIES AND STATIC FORCES EXERCISES
5.1) The Jacobian in frame {0} is
°J(0) — [ —L151
DET(°J(0)) =
L2512 —L2S12
L2C12
—(L2C12)(L151 + L2S12) + (L2S12)(L1C1 + L2C12)
= —L1L251C12 —
+ L1L2C1512 +
= L1L2C1S12 — L1L2S1C12 = L1L2(C1S12 —
= L1L2S2
S1C12)
The same result as when you start with 3J(9), namely, the singular
configurations are °2 =
or 180°.
Solutions to selected exercises
5.8) The Jacobian of this 2-link is
L1S2
An isotropic point exists if
3J[L2 0
L1S2 = L2
L1C2 + L2 =0
= ±.707.
Under this condition, S2 =
and C2 = — .707.
An isotropic point exists if L1 =
= ±135°.
and in that case it exists when
In this configuration, the manipulator looks momentarily like a Cartesian
5.13)
[—L1S1—L2S12 L1C1+L2C121[10
—L2S12
] [ 0
= 10S1L1 — 10L2S12
= 10L2512
CHAPTER 6
MANIPULATOR DYNAMICS EXERCISES
6.1) Use (6.17), but written in polar form, because that is easier. For example, for
J—H/2J0
pH/2
(x2+y2)prdrd0dz
y = Rsin0,
J—H/2 0
x2+y2 = R2(r2)
pr3dr d0dz
382
VOLUME = irr2H
Mass = M = p7rr2H
Similarly (only harder) is
From symmetry (or integration),
= Ixz = Iyz =
cj=I
6.12) 91(t) = Bt + Ct2, so
= B+2ct,0 =2c
[2cj
=14c1+I
E —2(B + 2ct)2
6.18) Any reasonable F(9, 0) probably has the property that the friction force (or
torque) on joint i depends only on the velocity of joint i, i.e.,
F(O,0)=[f1(9,01) F7(9,é2)
....FN(9,ON)]T
Also, each
should be "passive"; i.e., the function should lie in the first
& third quadrants.
"h Solution written by candlelight in aftermath of 7.0 earthquake, Oct. 17,
1989!
CHAPTER 7
TRAJECTORY GENERATION EXERCISES
Three cubics are required to connect a start point, two via points, and a goal
point—that is, three for each joint, for a total of 18 cubics. Each cubic has four
coefficients, so 72 coefficients are stored.
7.17) By differentiation,
7.1)
Then, evaluating at t =
180t
and t =
180t2
360t
6(0)=10 8(0)=0 9(0)= 180
9(1) =
—180
8.3) Using (8.1), we have
—(0+0)+(0+0)+(0+(U—L))= U—L
sphere
8.6) From (8.14),
KTQTAL =
= 4.333 x 10
KTOTAL = 230.77
8.16) From (8.15),
K — Grrd4
— 32L
(0.33
x 7.5 x
(32) (0.40)
This is very flimsy, because the diameter is 1 mm!
0.006135
384
9.2) From (9.5),
s1 =—————+
—1.5
=—1.5+0.5=—1.0
—2.0
quadx(t) = c1e_t + c2e_2t and
_c1e_t
2c2e_2t
Att=0 x(0)=l=c1+c2
—c1 — 2c2
Adding (1) and (2) gives
so c2 =
and c1 =
—c2
9.10) Using (8.24) and assuming aluminum yields
(0.333)(2 x lOll)
123,000.0
Using info from Figure 9.13, the equivalent mass is (0.23)(5) =
1.15
327.04
1.15 kg,
This is very high—so the designer is probably wrong in thinking that this link
vibrating represents the lowest unmodeled resonance!
9.13) As in problem 9.12, the effective stiffness is K = 32000. Now, the effective
inertia is I = 1 + (0.1)(64) = 7.4.
CHAPTER 10
10.47 Hz
NONLINEAR CONTROL OF MANIPULATORS EXERCISES
10.2) Let
t = crc" + fi
and r' = 9D +
where e =
10.10)
with a =
andf'=XD+kVê+kPe,
= 20,
CHAPTER 11
11.2)
e=XD—X
FORCE CONTROL OF MANIPULATORS EXERCISES
The artificial constraints for the task in question would be
where a1 is the speed of insertion.
11.4) Use (5.105) with frames {A} and {B} reversed. First, find
0.866 0.5 0 —8.66
0.866 0 5.0
1—5.0
so invert
= [1
1.73
[—6.3 —30.9 —15.8
BF = [1.0 1.73 —3 —6.3 —30.9 —15.8
Index
Acceleration of a rigid body, 166—167
angular acceleration, 167
linear acceleration, 166—167
Accuracy, 233
Actuation schemes, 244—247
actuator location, 244—245
reductionltransmission systems,
245—247
Actuator location:
direct-drive configuration,
244—245
speed-reduction system, 245
transmission system, 245
Actuator positions, 77
Actuator space, 77
Actuator vectors, 77
Actuators, 278—279
joint, 9fn
and stiffness, 250—252
vane, 250—251
Adaptive control, 311—312
Adept 2-D vision system, 366—367
Afflxments, 345
AL language, 341, 345
Algebraic solution, 106, 109—112
by reduction to polynomial,
113—114
Algorithms:
control, 11—12
nonlinear control, 12—13
Alternating current (AC) motors and
stepper motors, 252
Angle sets, 144
Angle-axis representation, 218—219
Angles:
Euler, 44
joint, 5, 66, 185
yaw, 41
Angle-set conventions, 46, 374—376
Angular acceleration, 167
Angular velocity, 141—144
representations of, 142—143
Angular-velocity matrix, 142
Angular-velocity vector, 137—138,
gaining physical insight
concerning, 142—143
Anthropomorphic manipulator,
Antialiasing, 278
AR-BASIC (American Cimliex),
Arm signature style calibration, 357
Armature, 278
ARMIT (Advanced Research
Manipulator II)
manipulator arm, 288
Articulated manipulator, 235
Artificial constraints, 320—321
Assembly, 3
Assembly strategy, 321
Automated subtasks in OLP systems:
automatic assessment of errors
and tolerances, 369
automatic planning of
coordinated motion, 368
automatic robot placement,
367—368
automatic scheduling, 368
coffision avoidance and path
optimization, 368
force-control simulation, 368
Automatic coffision detection,
Automation, fixed, 3, 14
Autonomous system, 305
Azimuth, 7
Back emf constant, 279
Backlash, 245
Ball-bearing screws, 246—247
Base frame (B), 5, 89, 125
Bearing flexibility, 250
Belts, 246
and stiffness, 249
BIBO stability, 276
388
Bolted joints, and hysteresis, 254
Bottom-up programming, 348
Bounded-input, bounded-output
(BIBO) stability, 276
Brushless motors, 252
Cables, 246
Calculation, kinematic, 91—92
Calibration matrix, 253
Calibration techniques, 127
Candidate Lyapunov functions, 305
Cartesian configuration space torque
equation, 187—188
Cartesian manipulator, 234—235
Cartesian mass matrix, 186
Cartesian motion, 218
Cartesian paths, geometric problems
with, 219—222
high joint rates near singularity,
220—221
intermediate points
unreachable, 220
start and goal reachable in
different solutions, 221—222
Cartesian space, 6, 76—77
formulating manipulator
dynamics in, 185—188
Cartesian state-space equation,
185—187
Cartesian trajectory generation, 10
Cartesian-based control systems,
307—311
Cartesian decoupling scheme,
310—311
defined, 308
intuitive schemes of Cartesian
control, 309—310
joint-based schemes compared
with, 307—309
Cartesian-space paths, generation,
223—224
Cartesian-space schemes, 216—219
Cartesian straight-line motion,
217—219
Cayley's formula for orthonormal
matrices, 40
Centrifugal force, 181
Chain drives, 246
Characteristic equation, 265
Cincinatti Milacron, 238
Closed-form dynamic equations,
example of, 177—180
Closed-form solutions, 106
Closed-form-solvable manipulators,
Closed-loop stiffness, 272
Closed-loop structures, 242—244
Grübler's formula, 243
Stewart mechanism, 243—244
Closed-loop system, 264
Collision-free path planning, 225
Co-located sensor and actuator pairs,
Complex roots, 266, 267—269
Computation, 52—54
Computed points, 127
Computed-torque method, 290
Concatenating link transformations,
Configuration-space equation,
181—182
Constraints:
artificial, 320—321
force, 320—321
natural, 319—321
position, 320—321
spatial, 202
Continuous vs. discrete time control,
277—278
Control algorithm, 11—12
Control gains, 272
Control law, 271
Control theory, 3
Control-law partitioning, 273—275
Coriolis force, 181
Coulomb friction, 188—189, 293
Coulomb-friction constant, 188
Critical damping, 266, 291
Cubic polynomials, 203—205
for a path with via points,
205—209
Current amplifier, 279—280
Cycle time, 233
Cylindrical configuration, 236—237
Index
Damped natural frequency, 268
Damping, effective, 280
Damping ratio, 268
Deburring, 318
DEC LSI-11 computer, 284—285
Decoupling, 295
Decoupling control, approximations,
Degrees of freedom, 5, 231—232
Denavit—Hartenberg notation, 67
Denavit—Hartenberg parameters,
Descriptions, 19—23
defined, 19
of a frame, 22—23
of an orientation, 20—22
of a position, 20
Dextrous workspace, 102
Differentiation:
numerical, 252
of position vectors, 13 6—137
Direct current (DC) brush motors,
251—252
Direct icinematics, 101
Direct-drive configuration, 244—245
Direct-drive manipulator, 281
Direction cosines, 22
Discrete-time control, 277—278, 297
Disturbance rejection, 276—277, 278
addition of an integral term, 277
PID control law, 277
steady-state error, 276
Draper Labs, 333
Dual-rate computed-torque
implementation, 298—299
Dynamic emulation, 358
Dynamic equations:
configuration-space equation,
state-space equation, 180—181
structure of, 177—180
Dynamic simulation, 189—190
Dynamically simple manipulator, 191
Dynamics, 9—10
defined, 9
Dynamics of manipulators, 165—200
acceleration of a rigid body,
166—167
computation, 190—192
efficiency, 190—191
efficiency of closed forms vs.
iterative form, 190—191
efficient dynamics for
simulation, 191
memorization scheme, 192
dynamic equations, structure of,
177—180
dynamic simulation, 189—190
Euler's equation, 171—172
iterative Newton—Euler
dynamic formulation,
173—176
iterative vs. closed form,
176—177
Lagrangian dynamic
formulation, 182—185
mass distribution, 167—171
Newton's equation, 171—172
nonrigid body effects, inclusion
of, 188—189
Dynamics of mechanisms, 165
Effective damping, 280
Effective inertia, 280
Efficiency:
of closed forms vs. iterative
form, 190—191
historical note concerning,
190—191
Elbow manipulator, 235
Elevation, 7
End-effector, 5
End-of-arm tooling, 230
Equivalent angle—axis
representation, 46—50
Error detection/recovery, 349—350
Error space, 275
Euler angles, 44
Z—Y—X, 43—45
Z—Y—Z, 45—46
Euler integration,. 189
390
Euler parameters, 50—51
Euler's formula, 267
Euler's theorem on rotation, 46frz
Event monitors, 346
Explicit programming languages,
341 —342
Feedback, 263
Feedforward nonlinear control,
297—298
Fictitious joints, 232, 238
Finite-element techniques, 250
Fixed angles, X—Y—Z, 41—43
Fixed automation, 3, 14
Flexible bands, 246
Flexible elements in parallel and in
series, 247
Flexure, 253
Foil gauges, 254
Force constraints, 320—321
Force control, 13
hybrid position/force control
problem, 323—324, 328—333
Cartesian manipulator aligned
with constraint frame (C),
328—330
general manipulator, 330—332
variable stiffness, adding,
332—333
industrial robots, application to
assembly tasks, 318
industrial-robot control
schemes, 333—335
compliance through softening
position gains, 333—334
force sensing, 334—335
passive compliance, 333
of manipulators, 317—338
of a mass—spring system,
324—328
partially constrained tasks,
framework for control in,
318—323
Force domain, Jacobians in, 156—157
Force sensing, 253—254, 334—335
design issues, 253—254
flexure, 253
hysteresis, 253—254
limit stops, 253—254
overload protection, 253
Force-control law, 13
Force-moment transformation,
158—159
Force-sensing fingers, 253
Forward kinematics, 4—6
4-quadrant arc tangent, 43frz
Frames, 4, 34
affixing to links, convention for,
67—73
base, 5
compound, 34—35
defined, 23
description of, 22—23
graphical representation of, 23
with standard names, 89—91
tool, 5
Free vectors:
defined, 51—52
transformation of, 51—52
Friction, 245
Gantry robots, 234
Gear ratio, 245, 246
Gears, 245
and stiffness, 248—249
General frames, mappings involving,
27—29
Generalizing kinematics, 91
Geometric solution, 106, 112—113
Geometric types, 344
GIVIF S380, 340
Goal frame (G), 91, 125
Gravity compensation, addition,
302 —3 03
Grinding, 318
GrUbler's formula, 243
Guarded move, 334
High repeatability and accuracy, 233
Higher-order polynomials, 209—210
Homogeneous transform, 28—29, 34
Hybrid control, 13
Hybrid position/force control
problem, 328—333
Hybrid position/force controller, 317
Hydraulic cylinders, 250—251
Hysteresis, eliminating, 254
Independent joint control, 264
Index pulse, 252
Individual-joint Pifi control,
301—302
Industrial robot:
applications, 1—3
as automation trend in
manufacturing process, 1
growth in use of, 1
Industrial-robot control schemes,
333—335
Industrial-robot control systems,
301—303
decoupling control,
approximations of, 303
gravity compensation, addition
of, 302—303
individual-joint PID control,
Industrial-robot controller,
architecture of, 284—285
Inertia:
effective, 280
mass moments of, 168
mass products of, 168—169
moment of, 167
pendulum, 171
principal moments of, 169
tensor, 167, 171
Inertia effipsoid, 241
Initial conditions, 265
Inspector, 367
Instantaneous axis of rotation, 143
Interactive languages, 356
Interpretations, 34
Intuitive schemes of Cartesian
Inverse kinematics, 6—7, 101
Inverse manipulator kinematics,
101—134
algebraic solution by reduction
to polynomial, 114—117
algebraic vs. geometric solution,
109—113
computation, 127—128
examples of, 117—125
PUMA 560 (Unimation),
117—121
Yasukawa Motoman L-3,
121—125
manipulator subspace, 107—109
Pieper's solution when three
axes intersect, 114—117
solvability, 101—106
existence of solutions,
102—103
method of solution, 105—106
multiple solutions, 103—105
Inverse-Jacobian controller, 309
Inverse-kinematic formulas, 377
Iterative Newton—Euler dynamic
formulation, 173—180
closed-form dynamic equations,
dynamics algorithm, 175—176
inclusion of gravity forces in,
force/torque acting on a link, 174
inward iterations, 174—175
outward iterations, 173—174
Jacobian matrix, 135frz
Jacobian transpose, 157
Jacobians, 7, 135—164
defined, 149—150
in the force domain, 156—157
frame of reference, changing,
velocity "propagation" from
link to link, 144—149
392
JARS, 341
Joint actuators, 9
Joint angles, 5, 66, 185
Lagrangian, defined, 183
Lagrangian dynamic formulation,
182—185
Joint axes, 64
Joint offset, 5
Joint space, 6, 76—77, 185
Language translation to target
Joint torques, 9
Joint variable, 67
Joint vector, 76
Joint-based control schemes,
Lead screws, 246—247
307—309
Jointed manipulator, 235
Joints, 5
bolted, 254
press-fit, 254
prismatic, 5, 63
revolute, 5, 63
welded, 254
Joint-space paths, generation of,
222—223
Joint-space schemes, 203—216
cubic polynomials, 203—205
cubic polynomials for a path
with via points, 205—209
higher-order polynomials,
209—210
linear function with parabolic
blends, 210—212
212—216
KAREL (GMF Robotics), 341
Khatib, 0., 332
Kinematic emulation, 357—358
Kinematics, 4—6
calculating, 91—92
defined, 4, 62
link description, 62—65
link-connection description,
65—67
of PUMA
(Unimation),
77—83
of two industrial robots, 77—89
of Yasukawa Motoman L-3,
83—89
Kinetically simple manipulator,
system, 359
Laplace transforms, 265
Leading subscripts/superscripts, in
notation, 16
Length sum, 240
L'Hópital's rule, 269
Limit stops, 253—254
Line of action, 51—52
Line vectors, defined, 51—52
Linear acceleration, 166—167
Linear control of manipulators,
262—289
closed-loop control, 263—264
continuous vs. discrete time
control, 277—278
control-law partitioning,
273—275
disturbance rejection, 276—277
feedback, 263
mdustrial-robot controller,
second-order linear systems,
264—271
characteristic equation, 265
complex roots, 266, 267—269
control of, 271 —273
initial conditions, 265
poles, 265
real and equal roots, 267,
269—271
real and unequal roots,
266—267
single joint,
modeling/controlling,
278—284
effective inertia, 280
estimating resonant
frequency, 282—283
motor-armature inductance,
279—280
index
umnodeled flexibility,
281—282
trajectory-following control, 275
Linear function with parabolic
Linear position control, 11—12
Linear velocity, 138—139
simultaneous rotational velocity,
140—141
Linear-control systems, 262
Linearizing and decoupling control
law, 295
Linearizing control law, 291
Link length, 64
Link offset, 66
Link parameters, 67
of a three-link planar
manipulator, 71
Link transformations:
concatenating, 76
derivation of, 73—76
Link twist, 64—65
Link-connection description, 65—67
first and last links in the chain,
66—67
intermediate links in the chain,
link parameters, 67
Link-frame assignment, 72
Links, 5
convention for affixing frames
to, 67—73
intermediate links in the
chain, 68
link parameter summary, 69
link-frame attachment
procedure, 69
and stiffness, 249—250
Load capacity, 233
Local linearization, 291
Locally degenerate mechanism, 9
Lower pair, 62—63
Low-pass ifiter, 279—280
Lumped models, 282—283
Lyapunov stability analysis, 303—307
Lyapunov's method, 290
Lyapunov's second (direct) method,
Manipulability measure, 241
Manipulator control, problem of,
294—295
Manipulator kinematics, 62—100
inverse, 101—134
link transformations:
"standard" frames, 89—91
Manipulator subspace, 107—109
Manipulator-mechanism design,
230—261
actuation schemes, 244—247
reduction/transmission
systems, 245 —247
articulated manipulator, 235
basing design on task
requirements, 231—233
accuracy, 233
degrees of freedom, number
of, 231—232
load capacity, 233
repeatability, 233
speed, 233
workspace, 233
closed-loop structures, 242—244
cylindrical configuration,
236—237
force sensing, 253—254
kinematic configuration,
234—239
position sensing, 252
redundant structures, 241—242
SCARA configuration, 235—236
spherical configuration, 236
stiffness/deflections, 246—252
actuators, 250—252
belts, 249
flexible elements in parallel
and in series, 247
394
gears, 248—249
links, 249—250
shafts, 247—248
well-conditioned workspaces,
workspace attributes,
quantitative measures of,
239—241
workspace generation, efficiency
of design in terms of, 240
wrist configuration, 237—239
Manipulators, 3
accuracy of, 127
control problems for, 295—296
design, 10—11
dynamics, 9—10, 165—200
force control, 13
forward kinematics of, 4—6
inverse kinematics of, 6—7
kinematics, 62—100
linear position control, 11—12
mechanics and control of, 4—15
nonlinear position control,
12—13
off-line programming and
simulation, 15
position and orientation, 4
programming robots, 13—15
repeatability, 127
sensors, 10—12
singularities, 7—9
static forces, 79
static forces in, 153—156
trajectory generation, 9—10
velocities, 79
workspace, 102
Mappings, 7, 24—29
involving general frames, 27—29
involving rotated frames, 25—27
involving translated frames,
24—25
Mass distribution, 167—171
inertia tensor, 167, 171
mass moments of inertia, 168
mass products of inertia,
168—169
parallel-axis theorem, 170
principal axes, 169
principal moments of inertia, 169
Mass matrix, 177
Mass moments of inertia, 168
Mass products of inertia, 168—169
Mechanical impedance, 332
Mechanical manipulators, See
Manipulators
Memorization scheme, 192
Micromanipulators, 242
Model-based portion, 273
Moment of inertia, 167
Motion specification, 345—346
Motor torque constant, 278
Motor-armature inductance, 279—280
Mouse, 356
Moving linearization, 291
Multi-input, multi-output (MIMO)
control systems, 264, 295
Multiprocess simulation, 358
Natural constraints, 319—321
Natural frequency, 268
Noise, 276
Nonautonomous system, 305
Nonlinear control algorithms, 12—13
Nonlinear control of manipulators,
290—313
adaptive control, 311—312
to, 307—309
current industrial-robot control
systems, 301—303
Lyapunov stability analysis,
303—307
manipulators, control problems
for, 295—296
multi-input, multi-output
(MIMO) control systems,
nonlinear systems, 291 —294
language translation to target
practical considerations,
multiprocess simulation, 358
path-planning emulation, 358
Pilot simulator, 360—367
sensors, simulation of, 359
296—301
dual-rate computed-torque
feedforward nonlinear
control, 297—298
parameters, lack of knowledge
of, 299—301
time required to compute the
model, 296—297
time-varying systems, 291 —294
Nonlinear position control, 12—13
Nonproper orthonormal matrices, 40
Nonrigid body effects, 188—189
Coulomb friction, 188—189
viscous friction, 188—189
Notation, 16
Denavit—Hartenberg notation,
for orientation, 135—138
for time-varying positions,
135—138
vector, 16
Numerical differentiation, 252
Numerical solutions, 106
Numerically controlled (NC) milling
machines, 3
Off-line programming (OLP)
systems, 353—371
automating subtasks in, 367—369
automatic assessment of
errors and tolerances, 369
3-D modeling, 356—357
user interface, 355—356
workcell calibration, 359—360
Off-line programming system, 15
Operating point, 291
Open-loop scheme, 263—264
Operational point, 14
Operational space, 6fn,
Operators, 30—34
rotational, 31—32
transformation, 33—34
translational, 30—31
Orientation:
angle-set conventions, 46
description of, 20—22
equivalent angle—axis
notation for, 135—138
predefined, 51
proper orthonormal matrices, 40
taught, 51
X—Y—Z fixed angles, 41—43
Z—Y—X Euler angles, 43—45
Z—Y—Z Euler angles, 45—46
Orienting structure, 234
Orthogonal intersecting shafts, 245
Orthonormal matrix, property of the
derivative of, 141
Overdamped system, 266
Overload protection, 253
central issues in, 355—360
defined, 353
dynamic emulation, 358
kinematic emulation, 357—358
Parallel shafts, 245
Parallel-axis theorem, 170
Parallelism, 358
Parts-mating tasks, 318
Pascal, 341
Passive compliance, 333
Path generation at run time, 222—224
Cartesian-space paths,
generation of, 223—224
396
joint-space paths, generation of,
Path generator, 216
Path planning, 224—225
coffision-free, 225
Path points, 202
Path-planning emulation, 358
Path-update rate, 201
Pick and place locations, 233
Pick and place operations, 318
PID control law, 277, 284—285
adjusting probabilities as a
function of drop height,
362—363
alignment of the part during
grasp, computation of,
364—365
bins, 363
bounce, simulation of, 363
computing which part to grasp,
connecting tray
conveyors/sources and
sinks, 365—366
default grasp location,
computation of, 364
flndspace algorithm, 364
inspector sensors, 367
part grasping, geometric
algorithms for, 364
part pushing, geometric
algorithms for, 365
part tumbling, geometric
algorithms for, 361—362
physical modeling and
interactive systems, 361
proximity sensors, 366
pushbar, 365
pushing of trays, 366
sensors, geometric algorithms
for, 366
stable-state estimator algorithm,
stable-state probabilities, 362
stacking/tangling, simulation of,
363—364
tray conveyors, geometric
2-D vision systems, 366—367
Pitch, 41
Pneumatic cylinders, 251
Points:
computed, 127
operating, 291
operational, 14
path, 202
pseudo via, 216—217
taught, 127
TCP (Tool Center Point), 14
through, 216
via, 10, 14, 202, 205—209,
wrist, 234
Poles, 265
Polynomials:
and closed-form solutions, 114
cubic, 203—205
higher-order, 209—210
Position constraints, 320—321
Position control system, 11
Position sensing, 252
Position vector, 20
Position vectors, differentiation of,
136—137
Position-control law, 13
Positioning structure, 234
Position-regulation system, 271—272
Positive definite matrix, 182
Potentiometers, 252
Predefined orientations, 51
Press-fit joints, and hysteresis, 254
Principal axes, 169
Principal moments of inertia, 169
Prismatic joints, 5, 63
Programming environment, 346
Programming paradigm, 360
Programming robots, 13—15
Proper orthonormal matrices, 40
Proprioceptive sensors, 230
Pseudo via points, 216—217
PUMA 560 (Unimation), 235, 284,
defined, 83—84
inverse manipulator kinematics,
kinematics of, 77—83
link parameters, 80
solutions, 104—105
Quadratic form, 182
internal world model vs.
external reality, 347—348
requirements of, 344—347
flow of execution, 346
motion specification, 345—346
programming environment,
sensor integration, 347
RAPID (ABB Robotics), 341
RCC (remote center compliance),
Reachable workspace, 102
Real and equal roots, 267, 269—271
Real and unequal roots, 266—267
Redundancies, 241—242
Redundant degree of freedom,
231—232
Reference inputs, tracking, 278
Remote center compliance (RCC),
Repeatability, 127, 233
Repeated roots, 269
Resolvers, 252
Resonances, 246, 247
structural, 278
unmodeled, 281
Resonant frequency, estimating,
282—283
Revolute joints, 5, 63
Rigid-body dynamics, form of, 295
specialized, 11
universal, 11
Robot programming:
levels of, 340—342
teach by showing method, 340
(RPLs), 13—15, 339—350,
categories of, 341
defined, 342
description of paths with, 224
explicit progranmiing languages,
problems peculiar to, 347—350
context sensitivity, 348—349
error recovery, 349—350
world modeling, 344—345
robot library for a new
general-purpose language,
robot library for an existing
computer language, 341
sample application, 342—344
specialized manipulation
languages, 341
task-level programming
languages, 342, 354
Robotic manipulation, 19
gantry, 234
motion of the robot links, 144
programming, 13—15
tool, positionlorientation of, 91
Robust controller, 298
Rodriques's formula, 58, 373
Roll, 41
Roller chains, 246
Rotary optical encoder, 252
Rotated frames, mappings involving,
25—27
Rotation matrix, 21
Rotational operators, 31—32
Rotational velocity, 139—140
simultaneous linear velocity,
Rotor, 278
RRR mechanism, 69—71
Run time:
defined, 222
path generation at, 222—224
Sampling rate, 297
Second-order linear systems,
398
control of, 271—273
real and unequal roots, 266—267
Semiconductor strain gauges, 254
Sensor integration, 347
Sensors, 10—12
proprioceptive, 230
simulation of, 359
wrist, 253
Servo error, 264, 331
Servo portion, 273, 292
Servo rate, 277
Set-point, 285
Shafts, 247—248
Similarity transform, 57
Simple applications, 318
Simulation, 9
Simulation specific code, 360
Single joint, modeling/controlling,
estimating resonant frequency,
unmodeled flexibility, 281 —282
Single-input, single-output (SISO)
control systems, 264
Singularities of the mechanism
(singularities), 9, 151—153
workspace-boundary
singularities, 151
workspace-interior singularities,
Sink records, 365—366
Skew shafts, 245
Skew-symmetric matrices, 142
Softening position gains, compliance
through, 333—334
Solvability, 101—106
existence of solutions, 102—103
SOLVE function, 126
Spatial constraints on motion, 202
Spatial descriptions, 19—23
Specialized robot, 11
Speed, 233
Speed-reduction system, 245
Spherical configuration, 236
Spline, 10
Spot welding, 318
Spray painting, 318
Stable system, 264
Standard frames, 89—91
base frame (B), 89, 125
goal frame (G), 91, 125
location of, 125
station frame (S), 90, 125
tool frame (T), 90, 125—126
use in a general robot system,
125—126
wrist frame (W), 90
State-space equation, 180—181
centrifugal force, 181
Static forces, 153—156
Cartesian transformation of
velocities and, 157—159
Station frame (5), 90, 125
Stator, 278
Steady-state analysis, 276
Steady-state error, 276
Stiffness:
flexible elements in parallel and
in series, 247
Strain gauges, 253
Structural length index, 240
Structural resonances, 278
Subspace, 107
Sum-of-angle formulas, 82
Tachometers, 252
Tangle factor, 363
Task space, 6fn
Task-level programming languages,
Task-oriented space, 76
Taught orientations, 51
Taught point, 127
Teach and playback manipulators,
Teach pendant, 285, 340
Temporal attributes of motion, 202
Three roll wrist, 238
Through points, 216
Time-varying positions, notation for,
Tool frame, 5
Tool frame (T), 90, 125—126
Tool, position/orientation of, 91
Torque ripple, 279
Tracking reference inputs, 278
Trailing subscripts/superscripts, in
Trajectory, defined, 201
Trajectory generation, 10, 201—239
Cartesian paths, geometric
problems with, 219—222
Cartesian-space schemes,
216—219
joint-space schemes, 203—216
blends for a path with via
points, 212—216
path description and generation,
201—203
path generation at run time,
222—224
joint-space paths, generation
of, 222—223
path planning, 224—225
collision-free, 225
robot programming languages,
Trajectory-conversion process,
Trajectory-following control, defined,
Trajectory-following control system,
Transducers, flexibility in, 254
Transform equations, 37—39
Transform mapping, 34
Transform operator, 34
Transformation:
of free vectors, 51—52
order of, 53
Transformation arithmetic, 34—37
compound transformations,
34—35
inverting a transform, 35—37
Transformation operators, 33—34
Translated frames, mappings
involving, 24—25
Translational mapping, 24—25
Translational operators, 30—31
Transmission system, 245
Transpose-Jacobian controller,
Trigonometric identities, 372—373
Types, 344
Underdamped system, 266
Unit quaternion, 50
Universal robot, 11
Universe coordinate system, 19
Unmodeled flexibility, 281—282
Unmodeled resonances, 281
Unstable performance, 264
400
UPDATE simulation routine,
User interface, 355—356
VAL language, 285, 341, 345
Vane actuators, 250—251
Vector cross-product, 142
Vector notation, 16
Vectors:
actuator, 77
angular, 137—138
position, differentiation of,
Velocities, Cartesian transformation
of, 157—159
Velocity:
angular, 141—144
linear, 138—139
of a point due to rotating
reference frame, 141—142
rotational, 139—140
Velocity transformation, 158—159
Via points, 10, 14, 202
Work envelope, 233
Work volume, 233
Workcell, 339, 344
calibration, 359—360
Workspace, 7, 102—103, 233
generation of, efficiency of
design in terms of, 240
and tool-frame transformation,
Workspace attributes, quantitative
measures of, 239—241
Workspace-boundary singularities,
Workspace-interior singularities, 152
World modeling, 344—345
Wrist configuration, 237—239
Wrist frame (W), 90
Wrist point, 234
Wrist sensors, 253
Wrist-partitioned class of
mechanisms, 234
with, 205—209
Virtual work, 156
Viscous friction, 188—189
Welded joints, and hysteresis, 254
Well-conditioned workspaces,
designing, 241
WHERE function, 91
Yasukawa Motoman L-3, 235, 245
defined, 83
kinematics of, 83—89
link frames, assignment of, 87
link parameters of, 88
Yaw angles, 41
